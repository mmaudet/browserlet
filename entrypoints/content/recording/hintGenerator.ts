/**
 * Semantic hint generator for recording user actions
 * Extracts 10 semantic hint types from DOM elements
 */

import { SemanticHint, HintType } from './types';
import { getElementRole, findAssociatedLabel, getNearbyText } from '../../../utils/hints/dom';
import { getVisibleText, normalizeText } from '../../../utils/hints/text';

/**
 * Generate semantic hints from a DOM element.
 * Returns an array of hints that can be used to relocate the element later.
 * Target: complete in <50ms for simple elements.
 */
export function generateHints(element: Element): SemanticHint[] {
  const hints: SemanticHint[] = [];

  // 1. Role (ARIA or implicit)
  const role = getElementRole(element);
  if (role) {
    hints.push({ type: 'role', value: role });
  }

  // 2. ID (if present and looks stable - not auto-generated)
  const id = element.getAttribute('id');
  if (id && !looksAutoGenerated(id)) {
    hints.push({ type: 'id', value: id });
  }

  // 3. Text content (truncated to 100 chars)
  const text = getVisibleText(element);
  if (text && text.length > 0 && text.length <= 100) {
    hints.push({ type: 'text_contains', value: normalizeText(text) });
  }

  // 4. Type attribute (input/button)
  const type = element.getAttribute('type');
  if (type) {
    hints.push({ type: 'type', value: type });
  }

  // 5. Name attribute
  const name = element.getAttribute('name');
  if (name) {
    hints.push({ type: 'name', value: name });
  }

  // 6. Aria-label
  const ariaLabel = element.getAttribute('aria-label');
  if (ariaLabel) {
    hints.push({ type: 'aria_label', value: ariaLabel });
  }

  // 7. Placeholder
  const placeholder = element.getAttribute('placeholder');
  if (placeholder) {
    hints.push({ type: 'placeholder_contains', value: placeholder });
  }

  // 8. Near label (associated <label> element)
  const label = findAssociatedLabel(element);
  if (label && label.textContent) {
    hints.push({ type: 'near_label', value: normalizeText(label.textContent) });
  }

  // 9. Class contains (only semantic-looking classes, skip utility classes)
  const semanticClasses = getSemanticClasses(element);
  const firstSemanticClass = semanticClasses[0];
  if (firstSemanticClass) {
    hints.push({ type: 'class_contains', value: firstSemanticClass });
  }

  // 10. Data attributes (data-testid, data-cy, data-action, etc.)
  for (const attr of element.attributes) {
    if (attr.name.startsWith('data-') && isSemanticDataAttribute(attr.name)) {
      hints.push({
        type: 'data_attribute',
        value: { name: attr.name, value: attr.value }
      });
    }
  }

  return hints;
}

/**
 * Check if an ID looks auto-generated (contains random strings, UUIDs, etc.)
 * Returns true if the ID is likely dynamic and unreliable for re-execution.
 */
function looksAutoGenerated(id: string): boolean {
  // UUID pattern
  if (/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i.test(id)) return true;

  // Random alphanumeric (8+ chars with mixed case/numbers)
  if (/^[a-zA-Z0-9]{8,}$/.test(id) && /\d/.test(id) && /[a-zA-Z]/.test(id)) return true;

  // Starts with common auto-gen prefixes
  if (/^(ember|react|vue|ng-|:r|__|_[A-Z])/i.test(id)) return true;

  // Pattern like _vOp9aabcMs2RkdUP7sKLsQM_75 (underscore + mixed case random + underscore + number)
  if (/^_[a-zA-Z0-9]{10,}_\d+$/.test(id)) return true;

  // Contains long random-looking sequences (12+ mixed alphanumeric)
  if (/[a-zA-Z0-9]{12,}/.test(id) && /[A-Z]/.test(id) && /[a-z]/.test(id) && /\d/.test(id)) return true;

  // Ends with random suffix (underscore or dash + 4+ alphanumeric)
  if (/[-_][a-zA-Z0-9]{4,}$/.test(id) && /\d/.test(id)) return true;

  // Hash-like patterns (hex strings 6+ chars)
  if (/^[a-f0-9]{6,}$/i.test(id)) return true;

  return false;
}

/**
 * Get semantic-looking classes (skip utility classes like Tailwind)
 */
function getSemanticClasses(element: Element): string[] {
  const semanticClasses: string[] = [];
  const skipPatterns = [
    /^(flex|grid|block|inline|hidden)/, // Layout
    /^(p|m|w|h|min-|max-)-/, // Spacing/sizing
    /^(text-|font-|bg-|border-)/, // Styling
    /^(hover:|focus:|active:)/, // States
    /^(sm:|md:|lg:|xl:)/, // Responsive
  ];

  for (const className of element.classList) {
    const isUtility = skipPatterns.some(p => p.test(className));
    if (!isUtility && className.length > 2) {
      semanticClasses.push(className);
    }
  }

  return semanticClasses;
}

/**
 * Check if a data attribute is semantic (useful for selection)
 */
function isSemanticDataAttribute(name: string): boolean {
  const semanticPrefixes = [
    'data-testid',
    'data-test-id',
    'data-cy',
    'data-qa',
    'data-action',
    'data-component',
    'data-id',
    'data-name',
    'data-value',
  ];
  return semanticPrefixes.some(prefix => name.startsWith(prefix));
}
