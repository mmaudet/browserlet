/**
 * Semantic hint generator for recording user actions
 * Extracts 15 semantic hint types from DOM elements (10 original + 4 structural context + 1 positional)
 */

import { SemanticHint, HintType } from './types';
import type { SPAContext, SPAFramework } from './types';
import { getElementRole, findAssociatedLabel, getNearbyText } from '../../../utils/hints/dom';
import { getVisibleText, normalizeText } from '../../../utils/hints/text';
import { extractDOMContext } from '../playback/domContextExtractor';

/**
 * Generate semantic hints from a DOM element.
 * Returns an array of hints that can be used to relocate the element later.
 * Target: complete in <50ms for simple elements.
 */
export function generateHints(element: Element): SemanticHint[] {
  const hints: SemanticHint[] = [];

  // 1. Role (ARIA or implicit)
  const role = getElementRole(element);
  if (role) {
    hints.push({ type: 'role', value: role });
  }

  // 2. ID (if present and looks stable - not auto-generated)
  const id = element.getAttribute('id');
  if (id && !looksAutoGenerated(id)) {
    hints.push({ type: 'id', value: id });
  }

  // 3. Text content (truncated to 100 chars)
  const text = getVisibleText(element);
  if (text && text.length > 0 && text.length <= 100) {
    hints.push({ type: 'text_contains', value: normalizeText(text) });
  }

  // 4. Type attribute (input/button)
  const type = element.getAttribute('type');
  if (type) {
    hints.push({ type: 'type', value: type });
  }

  // 5. Name attribute
  const name = element.getAttribute('name');
  if (name) {
    hints.push({ type: 'name', value: name });
  }

  // 6. Aria-label
  const ariaLabel = element.getAttribute('aria-label');
  if (ariaLabel) {
    hints.push({ type: 'aria_label', value: ariaLabel });
  }

  // 7. Placeholder
  const placeholder = element.getAttribute('placeholder');
  if (placeholder) {
    hints.push({ type: 'placeholder_contains', value: placeholder });
  }

  // 8. Near label (associated <label> element)
  const label = findAssociatedLabel(element);
  if (label && label.textContent) {
    hints.push({ type: 'near_label', value: normalizeText(label.textContent) });
  }

  // 9. Class contains (only semantic-looking classes, skip utility classes)
  const semanticClasses = getSemanticClasses(element);
  const firstSemanticClass = semanticClasses[0];
  if (firstSemanticClass) {
    hints.push({ type: 'class_contains', value: firstSemanticClass });
  }

  // 10. Data attributes (data-testid, data-cy, data-action, etc.)
  for (const attr of element.attributes) {
    if (attr.name.startsWith('data-') && isSemanticDataAttribute(attr.name)) {
      hints.push({
        type: 'data_attribute',
        value: { name: attr.name, value: attr.value }
      });
    }
  }

  // Structural context hints via DOMContextExtractor (single call, reuse result)
  const domContext = extractDOMContext(element);

  // 11. Fieldset context -- captures fieldset legend for form section disambiguation
  if (domContext.fieldset_legend) {
    hints.push({ type: 'fieldset_context', value: domContext.fieldset_legend });
  }

  // 12. Associated label (aria-labelledby, label[for], parent label)
  // Uses DOMContextExtractor which handles aria-labelledby (existing near_label from dom.ts does not)
  // Only add if different from existing near_label hint to avoid redundancy
  if (domContext.associated_label) {
    const existingNearLabel = hints.find(h => h.type === 'near_label');
    const alreadyCaptured = existingNearLabel &&
      typeof existingNearLabel.value === 'string' &&
      existingNearLabel.value === domContext.associated_label;
    if (!alreadyCaptured) {
      hints.push({ type: 'associated_label', value: domContext.associated_label });
    }
  }

  // 13. Section context -- nearest heading for section disambiguation
  if (domContext.section_heading) {
    hints.push({ type: 'section_context', value: domContext.section_heading });
  }

  // 14. Landmark context -- nearest ARIA landmark region for page-structure disambiguation
  if (domContext.landmark) {
    hints.push({ type: 'landmark_context', value: domContext.landmark });
  }

  // 15. Position context -- disambiguates when multiple identical elements exist
  const positionContext = generatePositionContext(element, hints);
  if (positionContext) {
    hints.push(positionContext);
  }

  return hints;
}

/**
 * Check if an ID looks auto-generated (contains random strings, UUIDs, etc.)
 * Returns true if the ID is likely dynamic and unreliable for re-execution.
 */
export function looksAutoGenerated(id: string): boolean {
  // UUID pattern
  if (/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i.test(id)) return true;

  // Random alphanumeric (8+ chars with mixed case/numbers)
  if (/^[a-zA-Z0-9]{8,}$/.test(id) && /\d/.test(id) && /[a-zA-Z]/.test(id)) return true;

  // Starts with common auto-gen prefixes
  if (/^(ember|react|vue|ng-|:r|__|_[A-Z])/i.test(id)) return true;

  // Vue 3 / React 18 SSR hydration IDs: :r0:, :r1a:, :rN: (colon-wrapped)
  if (/^:[a-z0-9]+:$/i.test(id)) return true;

  // Angular generated IDs: ng-* prefix patterns
  if (/^ng[-_]/i.test(id)) return true;

  // Pattern like _vOp9aabcMs2RkdUP7sKLsQM_75 (underscore + mixed case random + underscore + number)
  if (/^_[a-zA-Z0-9]{10,}_\d+$/.test(id)) return true;

  // Contains long random-looking sequences (12+ mixed alphanumeric)
  if (/[a-zA-Z0-9]{12,}/.test(id) && /[A-Z]/.test(id) && /[a-z]/.test(id) && /\d/.test(id)) return true;

  // Ends with random suffix (underscore or dash + 4+ alphanumeric)
  if (/[-_][a-zA-Z0-9]{4,}$/.test(id) && /\d/.test(id)) return true;

  // Hash-like patterns (hex strings 6+ chars)
  if (/^[a-f0-9]{6,}$/i.test(id)) return true;

  // CSS Modules ID patterns: styles__name___hash
  if (/__.*___[a-zA-Z0-9]+$/.test(id)) return true;

  return false;
}

/**
 * Check if a class name looks like a CSS Module or CSS-in-JS hashed class.
 * These contain build-time hashes that change between deployments,
 * making them unreliable as element identifiers.
 */
export function looksLikeHashedClass(className: string): boolean {
  // CSS Modules: styles__name___hash (double underscore separator + hash suffix)
  if (/__.*___[a-zA-Z0-9]+$/.test(className)) return true;
  // CSS Modules: name__hash (double underscore + 4+ char hash at end)
  if (/__[a-zA-Z0-9]{4,}$/.test(className)) return true;

  // styled-components: sc-abc123
  // Emotion: css-1a2b3c
  if (/^(css|sc)-[a-z0-9]+$/i.test(className)) return true;

  // CSS-in-JS generic: classes with double underscore AND hash-like suffix (_1mc8z, -a3f2d)
  if (className.includes('__') && /[-_][a-z0-9]{5,}$/.test(className)) return true;

  return false;
}

/**
 * Get semantic-looking classes (skip utility classes like Tailwind)
 */
function getSemanticClasses(element: Element): string[] {
  const semanticClasses: string[] = [];

  // Patterns to skip - comprehensive Tailwind utility class detection
  const skipPatterns = [
    // Layout utilities
    /^(flex|grid|block|inline|inline-flex|inline-block|inline-grid|hidden|visible|invisible|contents|table|table-row|table-cell|flow-root)$/,
    /^(flex-|grid-|place-|items-|justify-|content-|self-)/, // Flexbox/grid alignment
    /^(order-|col-|row-)/, // Grid/flex ordering

    // Spacing (p, m, px, py, pt, pr, pb, pl, mx, my, mt, mr, mb, ml, gap, space)
    /^[pm][xytblr]?-/, // p-4, px-2, mt-3, mb-3, etc.
    /^(gap-|space-[xy]-)/, // gap-4, space-x-2

    // Sizing (w, h, min-w, min-h, max-w, max-h, size)
    /^(w-|h-|min-w-|min-h-|max-w-|max-h-|size-)/, // w-full, h-screen, etc.

    // Typography
    /^(text-|font-|leading-|tracking-|decoration-|underline|line-through|no-underline)/,
    /^(uppercase|lowercase|capitalize|normal-case|truncate|break-|whitespace-)/,

    // Colors and backgrounds
    /^(bg-|from-|via-|to-|gradient-)/, // Backgrounds and gradients
    /^(border|rounded|outline|ring|shadow)/, // Borders and effects
    /^(opacity-|mix-blend-)/, // Opacity

    // State modifiers (hover:, focus:, active:, disabled:, etc.)
    /^(hover:|focus:|active:|disabled:|visited:|checked:|required:|invalid:|group-|peer-)/,
    /^(first:|last:|odd:|even:|empty:|focus-within:|focus-visible:)/,

    // Responsive prefixes
    /^(sm:|md:|lg:|xl:|2xl:|dark:|print:|portrait:|landscape:)/,

    // Arbitrary variants with brackets: data-[...]:, aria-[...]:, supports-[...]:
    /^(data-\[|aria-\[|supports-\[)/,
    // Any class containing state modifiers (catches data-[active=true]:focus:bg-accent)
    /:(hover|focus|active|disabled|checked|focus-within|focus-visible):/,

    // Positioning
    /^(static|fixed|absolute|relative|sticky)$/,
    /^(inset-|top-|right-|bottom-|left-|z-)/,
    /^(float-|clear-|object-|overflow-|overscroll-)/,

    // Display and visibility
    /^(aspect-|container|columns-|box-)/,

    // Transforms and transitions
    /^(transform|rotate-|scale-|skew-|translate-|origin-)/,
    /^(transition|duration-|ease-|delay-|animate-)/,

    // Filters and effects
    /^(blur|brightness-|contrast-|grayscale|hue-rotate-|invert|saturate-|sepia|backdrop-|drop-shadow)/,

    // Interactivity
    /^(cursor-|pointer-events-|resize|scroll-|snap-|touch-|select-|will-change-)/,

    // SVG
    /^(fill-|stroke-)/,

    // Accessibility
    /^(sr-only|not-sr-only)$/,

    // Tailwind group/peer utilities (used for group-hover:, peer-focus:, etc.)
    /^(group|peer)$/,

    // Additional Tailwind utilities found in real sites
    /^(antialiased|subpixel-antialiased)$/,  // Font smoothing
    /^(appearance-none|appearance-auto)$/,   // Form appearance
    /^(prose|prose-sm|prose-lg|prose-xl|prose-2xl|prose-invert)$/,  // Typography plugin
    /^(line-clamp-|clamp-)/, // Line clamping
    /^(shrink|grow|basis-)/, // Flex item sizing
    /^(list-|auto-rows-|auto-cols-)/, // List and grid auto
    /^(ring-offset-)/, // Ring offset utilities
    /^(slide-in-|slide-out-|fade-in|fade-out|zoom-in|zoom-out|spin-in|spin-out)/, // Animation utilities
    /^-/, // Negative values like -translate-x-1/2, -inset-px, -z-10
    /^!/, // Important modifier like !h-64
  ];

  for (const className of element.classList) {
    // Skip if matches any utility pattern
    const isUtility = skipPatterns.some(p => p.test(className));
    // Skip very short classes (likely utilities like 'w', 'h', etc.)
    // Skip classes containing colons (state modifiers)
    const hasStateModifier = className.includes(':');
    // Skip classes with brackets (arbitrary values like w-[100px])
    const hasArbitraryValue = className.includes('[') || className.includes(']');

    if (!isUtility && !hasStateModifier && !hasArbitraryValue && className.length > 2 && !looksLikeHashedClass(className)) {
      semanticClasses.push(className);
    }
  }

  return semanticClasses;
}

/**
 * Check if a data attribute is semantic (useful for selection)
 */
function isSemanticDataAttribute(name: string): boolean {
  // Reject Vue scoped attributes (data-v-xxxxxxxx)
  if (/^data-v-[a-f0-9]+$/i.test(name)) return false;

  // Reject Angular internal attributes
  if (name.startsWith('_ngcontent-') || name.startsWith('_nghost-') || name.startsWith('ng-reflect-')) return false;

  const semanticPrefixes = [
    'data-testid',
    'data-test-id',
    'data-cy',
    'data-qa',
    'data-action',
    'data-component',
    'data-id',
    'data-name',
    'data-value',
  ];
  return semanticPrefixes.some(prefix => name.startsWith(prefix));
}

// ---------------------------------------------------------------------------
// Position context -- disambiguates repeated identical elements
// ---------------------------------------------------------------------------

/**
 * Generate a position_context hint when multiple sibling elements share the
 * same role AND text. Returns null if the element is unique (no disambiguation needed).
 *
 * Performance: capped at 200 candidates via querySelectorAll to avoid full-DOM scans.
 */
function generatePositionContext(element: Element, hints: SemanticHint[]): SemanticHint | null {
  const roleHint = hints.find(h => h.type === 'role');
  const textHint = hints.find(h => h.type === 'text_contains');

  // Only disambiguate when we have both role and text
  if (!roleHint || !textHint) return null;

  const role = typeof roleHint.value === 'string' ? roleHint.value : null;
  const text = typeof textHint.value === 'string' ? textHint.value : null;
  if (!role || !text) return null;

  // Build selector for same-role elements
  const tagMap: Record<string, string> = {
    button: 'button, [role="button"]',
    link: 'a[href], [role="link"]',
    textbox: 'input:not([type="checkbox"]):not([type="radio"]):not([type="submit"]):not([type="button"]), textarea, [role="textbox"]',
    checkbox: 'input[type="checkbox"], [role="checkbox"]',
    radio: 'input[type="radio"], [role="radio"]',
    combobox: 'select, [role="combobox"]',
  };
  const selector = tagMap[role] || `[role="${role}"]`;

  let candidates: Element[];
  try {
    candidates = Array.from(document.querySelectorAll(selector)).slice(0, 200);
  } catch {
    return null;
  }

  // Filter by matching text content
  const normalizedText = text.toLowerCase().trim();
  const sameTextElements = candidates.filter(el => {
    const elText = (el.textContent || '').toLowerCase().trim();
    return elText === normalizedText || elText.includes(normalizedText);
  });

  if (sameTextElements.length < 2) return null; // Element is unique

  const index = sameTextElements.indexOf(element);
  if (index === -1) return null;

  // Check for table context (use row index for better semantics)
  const row = element.closest('tr');
  if (row) {
    const tbody = row.parentElement;
    if (tbody) {
      const rows = Array.from(tbody.children).filter(c => c.tagName === 'TR');
      const rowIndex = rows.indexOf(row);
      if (rowIndex >= 0) {
        return { type: 'position_context', value: `row ${rowIndex + 1} of ${rows.length}` };
      }
    }
  }

  // General position
  return { type: 'position_context', value: `item ${index + 1} of ${sameTextElements.length}` };
}

// ---------------------------------------------------------------------------
// SPA framework detection
// ---------------------------------------------------------------------------

/**
 * Detect SPA framework context for the given element.
 * Returns undefined when no SPA signals are present (plain HTML page).
 */
export function detectSPAContext(element: Element): SPAContext | undefined {
  const framework = detectFramework();
  if (framework === 'unknown') return undefined;

  const component = detectComponent(element);
  const is_dynamic_zone = detectDynamicZone(element);

  return { framework, component, is_dynamic_zone };
}

function detectFramework(): SPAFramework {
  // React signals
  if (typeof window !== 'undefined' && '__REACT_DEVTOOLS_GLOBAL_HOOK__' in window) return 'react';
  if (document.querySelector('[data-reactroot]')) return 'react';

  // Vue signals
  if (typeof window !== 'undefined' && '__VUE__' in window) return 'vue';
  if (document.querySelector('[data-v-app]')) return 'vue';

  // Angular signals
  if (typeof window !== 'undefined' && 'ng' in (window as Window & typeof globalThis & { ng?: unknown })) return 'angular';
  if (document.querySelector('[ng-version]')) return 'angular';

  return 'unknown';
}

function detectComponent(element: Element): string | undefined {
  let current: Element | null = element;
  let depth = 0;
  while (current && depth < 5) {
    const comp = current.getAttribute('data-component');
    if (comp) return comp;
    current = current.parentElement;
    depth++;
  }
  return undefined;
}

function detectDynamicZone(element: Element): boolean {
  return !!(
    element.closest('router-view') ||
    element.closest('[data-router-view]') ||
    element.closest('ng-view') ||
    element.closest('[ng-view]')
  );
}
