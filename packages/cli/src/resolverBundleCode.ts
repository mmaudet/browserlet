// AUTO-GENERATED by scripts/build-resolver.ts -- DO NOT EDIT
// Regenerate with: npx tsx scripts/build-resolver.ts
export const RESOLVER_BUNDLE = "\"use strict\";\nvar __browserletResolver = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n  // resolver-bundle/entry.ts\n  var entry_exports = {};\n\n  // resolver-bundle/types.ts\n  var HINT_WEIGHTS = {\n    data_attribute: 1,\n    role: 1,\n    type: 1,\n    aria_label: 0.9,\n    name: 0.9,\n    id: 0.85,\n    text_contains: 0.8,\n    placeholder_contains: 0.7,\n    fieldset_context: 0.7,\n    associated_label: 0.7,\n    section_context: 0.6,\n    near_label: 0.6,\n    class_contains: 0.5\n  };\n\n  // resolver-bundle/domUtils.ts\n  function normalizeText(text, removeAccents = true) {\n    if (!text) return \"\";\n    let normalized = text.trim().toLowerCase().replace(/\\s+/g, \" \").replace(/[\\u2018\\u2019\\u201A\\u201B\\u0060\\u00B4]/g, \"'\").replace(/[\\u201C\\u201D\\u201E\\u201F]/g, '\"');\n    if (removeAccents) {\n      normalized = normalized.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\n    }\n    return normalized;\n  }\n  var IMPLICIT_ROLES = {\n    \"a\": \"link\",\n    \"button\": \"button\",\n    \"input\": \"textbox\",\n    // Simplified, depends on type\n    \"select\": \"combobox\",\n    \"textarea\": \"textbox\",\n    \"img\": \"img\",\n    \"table\": \"table\",\n    \"td\": \"cell\",\n    \"th\": \"cell\",\n    \"tr\": \"row\",\n    \"nav\": \"navigation\",\n    \"main\": \"main\",\n    \"header\": \"banner\",\n    \"footer\": \"contentinfo\",\n    \"article\": \"article\",\n    \"aside\": \"complementary\",\n    \"form\": \"form\",\n    \"ul\": \"list\",\n    \"ol\": \"list\",\n    \"li\": \"listitem\",\n    \"h1\": \"heading\",\n    \"h2\": \"heading\",\n    \"h3\": \"heading\",\n    \"h4\": \"heading\",\n    \"h5\": \"heading\",\n    \"h6\": \"heading\",\n    \"p\": \"paragraph\"\n  };\n  var INPUT_TYPE_ROLES = {\n    \"button\": \"button\",\n    \"submit\": \"button\",\n    \"reset\": \"button\",\n    \"checkbox\": \"checkbox\",\n    \"radio\": \"radio\",\n    \"range\": \"slider\",\n    \"search\": \"searchbox\",\n    \"email\": \"textbox\",\n    \"tel\": \"textbox\",\n    \"url\": \"textbox\",\n    \"number\": \"spinbutton\",\n    \"password\": \"\"\n    // No ARIA role for password fields (security)\n  };\n  function getElementRole(element) {\n    const explicitRole = element.getAttribute(\"role\");\n    if (explicitRole) return explicitRole;\n    const tagName = element.tagName.toLowerCase();\n    if (tagName === \"input\") {\n      const type = element.type || \"text\";\n      const role = INPUT_TYPE_ROLES[type];\n      if (role === \"\") return null;\n      return role ?? \"textbox\";\n    }\n    return IMPLICIT_ROLES[tagName] || null;\n  }\n  function isElementVisible(element) {\n    if (!(element instanceof HTMLElement)) return true;\n    const style = window.getComputedStyle(element);\n    if (style.display === \"none\") return false;\n    if (style.visibility === \"hidden\") return false;\n    if (style.opacity === \"0\") return false;\n    const rect = element.getBoundingClientRect();\n    if (rect.width === 0 && rect.height === 0) return false;\n    return true;\n  }\n  function findAssociatedLabel(element) {\n    const id = element.getAttribute(\"id\");\n    if (id) {\n      const label = document.querySelector(`label[for=\"${id}\"]`);\n      if (label) return label;\n    }\n    const parentLabel = element.closest(\"label\");\n    if (parentLabel) return parentLabel;\n    if (element.tagName === \"TD\") {\n      const row = element.closest(\"tr\");\n      if (row) {\n        const th = row.querySelector(\"th\");\n        if (th) return th;\n      }\n    }\n    const prevSibling = element.previousElementSibling;\n    if (prevSibling) {\n      const tagName = prevSibling.tagName;\n      if (tagName === \"LABEL\" || tagName === \"TH\" || tagName === \"DT\" || tagName === \"STRONG\" || tagName === \"B\" || prevSibling.classList.contains(\"label\")) {\n        return prevSibling;\n      }\n    }\n    const parent = element.parentElement;\n    if (parent) {\n      const children = Array.from(parent.children);\n      const elementIndex = children.indexOf(element);\n      for (let i = elementIndex - 1; i >= 0; i--) {\n        const sibling = children[i];\n        if (sibling.tagName === \"LABEL\" || sibling.classList.contains(\"label\")) {\n          return sibling;\n        }\n      }\n    }\n    return null;\n  }\n\n  // resolver-bundle/domContextExtractor.ts\n  var FORM_CONTROL_TAGS = /* @__PURE__ */ new Set([\"INPUT\", \"SELECT\", \"TEXTAREA\", \"BUTTON\"]);\n  var TAG_TO_LANDMARK = {\n    NAV: \"navigation\",\n    MAIN: \"main\",\n    ASIDE: \"complementary\",\n    HEADER: \"banner\",\n    FOOTER: \"contentinfo\",\n    FORM: \"form\"\n  };\n  var LANDMARK_ROLES = /* @__PURE__ */ new Set([\n    \"navigation\",\n    \"main\",\n    \"complementary\",\n    \"banner\",\n    \"contentinfo\",\n    \"form\"\n  ]);\n  function extractDOMContext(element) {\n    return {\n      fieldset_legend: extractFieldsetLegend(element),\n      associated_label: extractAssociatedLabel(element),\n      near_label: extractNearLabel(element),\n      sibling_texts: extractSiblingTexts(element),\n      landmark: extractLandmark(element),\n      section_heading: extractSectionHeading(element)\n    };\n  }\n  function extractFieldsetLegend(element) {\n    const fieldset = element.closest(\"fieldset\");\n    if (!fieldset) return null;\n    const legend = fieldset.querySelector(\":scope > legend\");\n    if (!legend) return null;\n    const text = normalizeText(legend.textContent);\n    return text || null;\n  }\n  function extractAssociatedLabel(element) {\n    const labelledBy = element.getAttribute(\"aria-labelledby\");\n    if (labelledBy) {\n      const ids = labelledBy.split(/\\s+/).filter(Boolean);\n      const texts = [];\n      for (const id of ids) {\n        const referencedEl = document.getElementById(id);\n        if (referencedEl) {\n          const text = normalizeText(referencedEl.textContent);\n          if (text) texts.push(text);\n        }\n      }\n      if (texts.length > 0) {\n        return texts.join(\" \");\n      }\n    }\n    const labelElement = findAssociatedLabel(element);\n    if (labelElement) {\n      const text = normalizeText(labelElement.textContent);\n      return text || null;\n    }\n    return null;\n  }\n  function extractNearLabel(element, maxDepth = 3) {\n    let current = element.parentElement;\n    let distance = 1;\n    while (current && distance <= maxDepth) {\n      for (const child of current.children) {\n        if (child === element || child.contains(element)) continue;\n        if (FORM_CONTROL_TAGS.has(child.tagName)) continue;\n        const isLabelLike = child.tagName === \"LABEL\" || child.tagName === \"LEGEND\" || child.tagName === \"DT\" || child.tagName === \"STRONG\" || child.tagName === \"SPAN\" && (child.textContent?.length ?? 0) < 50;\n        if (isLabelLike) {\n          const text = normalizeText(child.textContent);\n          if (text) {\n            return { text, distance };\n          }\n        }\n      }\n      for (const node of current.childNodes) {\n        if (node.nodeType === Node.TEXT_NODE) {\n          const text = normalizeText(node.textContent);\n          if (text && text.length < 50) {\n            return { text, distance };\n          }\n        }\n      }\n      current = current.parentElement;\n      distance++;\n    }\n    return null;\n  }\n  function extractSiblingTexts(element) {\n    const parent = element.parentElement;\n    if (!parent) return { before: [], after: [] };\n    const children = Array.from(parent.children);\n    const index = children.indexOf(element);\n    if (index === -1) return { before: [], after: [] };\n    const before = [];\n    const after = [];\n    for (let i = index - 1; i >= 0 && before.length < 3; i--) {\n      const sibling = children[i];\n      if (FORM_CONTROL_TAGS.has(sibling.tagName)) continue;\n      const text = normalizeText(sibling.textContent);\n      if (text) before.push(text);\n    }\n    for (let i = index + 1; i < children.length && after.length < 3; i++) {\n      const sibling = children[i];\n      if (FORM_CONTROL_TAGS.has(sibling.tagName)) continue;\n      const text = normalizeText(sibling.textContent);\n      if (text) after.push(text);\n    }\n    before.reverse();\n    return { before, after };\n  }\n  function extractLandmark(element) {\n    const landmark = element.closest(\n      'nav, main, aside, header, footer, form, [role=\"navigation\"], [role=\"main\"], [role=\"complementary\"], [role=\"banner\"], [role=\"contentinfo\"], [role=\"form\"]'\n    );\n    if (!landmark) return null;\n    const explicitRole = landmark.getAttribute(\"role\");\n    if (explicitRole && LANDMARK_ROLES.has(explicitRole)) {\n      return explicitRole;\n    }\n    return TAG_TO_LANDMARK[landmark.tagName] || null;\n  }\n  function extractSectionHeading(element) {\n    let current = element;\n    let level = 0;\n    const maxLevels = 5;\n    while (current && level < maxLevels) {\n      const parent = current.parentElement;\n      if (!parent) break;\n      const parentRole = parent.getAttribute(\"role\");\n      if (parentRole && LANDMARK_ROLES.has(parentRole) || TAG_TO_LANDMARK[parent.tagName]) {\n        const heading = parent.querySelector(\":scope > h1, :scope > h2, :scope > h3, :scope > h4, :scope > h5, :scope > h6\");\n        if (heading) {\n          const text = normalizeText(heading.textContent);\n          if (text) return text;\n        }\n        break;\n      }\n      let sibling = current.previousElementSibling;\n      while (sibling) {\n        if (/^H[1-6]$/.test(sibling.tagName)) {\n          const text = normalizeText(sibling.textContent);\n          if (text) return text;\n        }\n        sibling = sibling.previousElementSibling;\n      }\n      for (const child of parent.children) {\n        if (child === current) break;\n        if (/^H[1-6]$/.test(child.tagName)) {\n          const text = normalizeText(child.textContent);\n          if (text) return text;\n        }\n      }\n      current = parent;\n      level++;\n    }\n    return null;\n  }\n\n  // resolver-bundle/semanticResolver.ts\n  function getInitialCandidates(hints) {\n    const priorityHints = [\"type\", \"role\", \"name\", \"id\"];\n    for (const priorityType of priorityHints) {\n      const hint = hints.find((h) => h.type === priorityType);\n      if (hint && typeof hint.value === \"string\") {\n        let elements;\n        switch (priorityType) {\n          case \"role\": {\n            const explicitRole = Array.from(document.querySelectorAll(`[role=\"${hint.value}\"]`));\n            const implicitRole = getElementsByImplicitRole(hint.value);\n            elements = [.../* @__PURE__ */ new Set([...explicitRole, ...implicitRole])];\n            break;\n          }\n          case \"type\":\n            elements = document.querySelectorAll(`[type=\"${hint.value}\"]`);\n            break;\n          case \"id\": {\n            const el = document.getElementById(hint.value);\n            elements = el ? [el] : [];\n            break;\n          }\n          case \"name\":\n            elements = document.querySelectorAll(`[name=\"${hint.value}\"]`);\n            break;\n          default:\n            elements = [];\n        }\n        if (elements.length > 0) {\n          return Array.from(elements);\n        }\n      }\n    }\n    const standardInteractive = Array.from(document.querySelectorAll(\n      'a, button, input, select, textarea, [role=\"button\"], [role=\"link\"], [role=\"textbox\"], [role=\"checkbox\"], [role=\"radio\"], [tabindex], [onclick]'\n    ));\n    const hasTextHint = hints.some((h) => h.type === \"text_contains\");\n    if (hasTextHint) {\n      const textElements = getTextContainingElements();\n      const clickableElements = getClickableElements();\n      const combined = /* @__PURE__ */ new Set([...standardInteractive, ...textElements, ...clickableElements]);\n      return Array.from(combined);\n    }\n    return standardInteractive;\n  }\n  function getClickableElements() {\n    const candidates = [];\n    const potentialClickables = document.querySelectorAll(\n      'div, span, li, td, article, section, [class*=\"btn\"], [class*=\"button\"], [class*=\"card\"], [class*=\"click\"]'\n    );\n    for (const el of potentialClickables) {\n      const style = window.getComputedStyle(el);\n      if (style.cursor === \"pointer\") {\n        candidates.push(el);\n      }\n    }\n    return candidates;\n  }\n  function getTextContainingElements() {\n    return Array.from(document.querySelectorAll(\n      'h1, h2, h3, h4, h5, h6, p, span, div, li, td, th, label, strong, em, b, i, code, pre, blockquote, figcaption, [class*=\"title\"], [class*=\"heading\"], [class*=\"text\"], [class*=\"label\"], [class*=\"name\"], [class*=\"value\"]'\n    ));\n  }\n  function getElementsByImplicitRole(role) {\n    const roleToTags = {\n      \"button\": [\"button\", 'input[type=\"button\"]', 'input[type=\"submit\"]', 'input[type=\"reset\"]'],\n      \"link\": [\"a[href]\"],\n      \"textbox\": [\"input:not([type])\", 'input[type=\"text\"]', 'input[type=\"email\"]', 'input[type=\"tel\"]', 'input[type=\"url\"]', 'input[type=\"search\"]', \"textarea\"],\n      \"checkbox\": ['input[type=\"checkbox\"]'],\n      \"radio\": ['input[type=\"radio\"]'],\n      \"combobox\": [\"select\"],\n      \"listbox\": [\"select[multiple]\"],\n      \"searchbox\": ['input[type=\"search\"]'],\n      \"spinbutton\": ['input[type=\"number\"]'],\n      \"slider\": ['input[type=\"range\"]'],\n      \"navigation\": [\"nav\"],\n      \"main\": [\"main\"],\n      \"banner\": [\"header\"],\n      \"contentinfo\": [\"footer\"],\n      \"form\": [\"form\"],\n      \"list\": [\"ul\", \"ol\"],\n      \"listitem\": [\"li\"],\n      \"table\": [\"table\"],\n      \"cell\": [\"td\", \"th\"],\n      \"row\": [\"tr\"],\n      \"columnheader\": [\"th\"],\n      \"rowheader\": ['th[scope=\"row\"]'],\n      \"img\": [\"img\"],\n      \"article\": [\"article\"],\n      \"complementary\": [\"aside\"],\n      \"heading\": [\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"],\n      \"paragraph\": [\"p\"]\n    };\n    const selectors = roleToTags[role];\n    if (!selectors) return [];\n    const elements = [];\n    for (const selector of selectors) {\n      elements.push(...Array.from(document.querySelectorAll(selector)));\n    }\n    return elements;\n  }\n  function matchHint(element, hint) {\n    switch (hint.type) {\n      case \"role\": {\n        if (typeof hint.value !== \"string\") return false;\n        const elementRole = getElementRole(element);\n        return elementRole === hint.value;\n      }\n      case \"id\": {\n        if (typeof hint.value !== \"string\") return false;\n        return element.id === hint.value;\n      }\n      case \"text_contains\": {\n        if (typeof hint.value !== \"string\") return false;\n        const textContent = element.textContent || \"\";\n        return normalizeText(textContent).includes(normalizeText(hint.value));\n      }\n      case \"type\": {\n        if (typeof hint.value !== \"string\") return false;\n        return element.getAttribute(\"type\") === hint.value;\n      }\n      case \"name\": {\n        if (typeof hint.value !== \"string\") return false;\n        return element.getAttribute(\"name\") === hint.value;\n      }\n      case \"aria_label\": {\n        if (typeof hint.value !== \"string\") return false;\n        return element.getAttribute(\"aria-label\") === hint.value;\n      }\n      case \"placeholder_contains\": {\n        if (typeof hint.value !== \"string\") return false;\n        const placeholder = element.getAttribute(\"placeholder\") || \"\";\n        return normalizeText(placeholder).includes(normalizeText(hint.value));\n      }\n      case \"near_label\": {\n        if (typeof hint.value !== \"string\") return false;\n        const label = findAssociatedLabel(element);\n        if (!label) return false;\n        const labelText = label.textContent || \"\";\n        return normalizeText(labelText).includes(normalizeText(hint.value));\n      }\n      case \"class_contains\": {\n        if (typeof hint.value !== \"string\") return false;\n        return element.classList.contains(hint.value);\n      }\n      case \"data_attribute\": {\n        if (typeof hint.value === \"string\") return false;\n        const { name, value } = hint.value;\n        return element.getAttribute(name) === value;\n      }\n      case \"fieldset_context\": {\n        if (typeof hint.value !== \"string\") return false;\n        const context = extractDOMContext(element);\n        return context.fieldset_legend !== null && normalizeText(context.fieldset_legend).includes(normalizeText(hint.value));\n      }\n      case \"associated_label\": {\n        if (typeof hint.value !== \"string\") return false;\n        const ctx = extractDOMContext(element);\n        return ctx.associated_label !== null && normalizeText(ctx.associated_label).includes(normalizeText(hint.value));\n      }\n      case \"section_context\": {\n        if (typeof hint.value !== \"string\") return false;\n        const sctx = extractDOMContext(element);\n        return sctx.section_heading !== null && normalizeText(sctx.section_heading).includes(normalizeText(hint.value));\n      }\n      default:\n        return false;\n    }\n  }\n  function resolveElement(hints) {\n    if (hints.length === 0) {\n      return {\n        element: null,\n        confidence: 0,\n        matchedHints: [],\n        failedHints: []\n      };\n    }\n    const allCandidates = getInitialCandidates(hints);\n    const candidates = allCandidates.filter((el) => {\n      const rect = el.getBoundingClientRect();\n      return rect.width > 0 && rect.height > 0;\n    });\n    const finalCandidates = candidates.length > 0 ? candidates : allCandidates;\n    const maxPossibleScore = hints.reduce((sum, hint) => sum + HINT_WEIGHTS[hint.type], 0);\n    let bestMatch = null;\n    let bestScore = 0;\n    let bestMatchedHints = [];\n    let bestFailedHints = [];\n    for (const candidate of finalCandidates) {\n      let score = 0;\n      const matchedHints = [];\n      const failedHints = [];\n      for (const hint of hints) {\n        const hintDescription = typeof hint.value === \"string\" ? `${hint.type}:${hint.value}` : `${hint.type}:${hint.value.name}=${hint.value.value}`;\n        if (matchHint(candidate, hint)) {\n          score += HINT_WEIGHTS[hint.type];\n          matchedHints.push(hintDescription);\n        } else {\n          failedHints.push(hintDescription);\n        }\n      }\n      if (score > bestScore) {\n        bestScore = score;\n        bestMatch = candidate;\n        bestMatchedHints = matchedHints;\n        bestFailedHints = failedHints;\n      }\n    }\n    const confidence = maxPossibleScore > 0 ? bestScore / maxPossibleScore : 0;\n    const CONFIDENCE_THRESHOLD = 0.7;\n    if (confidence >= CONFIDENCE_THRESHOLD && bestMatch) {\n      return {\n        element: bestMatch,\n        confidence,\n        matchedHints: bestMatchedHints,\n        failedHints: bestFailedHints\n      };\n    }\n    return {\n      element: null,\n      confidence,\n      matchedHints: bestMatchedHints,\n      failedHints: bestFailedHints\n    };\n  }\n  function isElementInteractable(element) {\n    if (!isElementVisible(element)) {\n      return false;\n    }\n    if (element.hasAttribute(\"disabled\")) {\n      return false;\n    }\n    if (element.getAttribute(\"aria-disabled\") === \"true\") {\n      return false;\n    }\n    const rect = element.getBoundingClientRect();\n    if (rect.width === 0 || rect.height === 0) {\n      return false;\n    }\n    return true;\n  }\n\n  // resolver-bundle/structuralScorer.ts\n  var STRUCTURAL_BOOST_VALUES = {\n    FIELDSET_LEGEND: 0.15,\n    // RSLV-05: fieldset legend match\n    ASSOCIATED_LABEL: 0.15,\n    // RSLV-06: label[for] or aria-labelledby match\n    NEAR_LABEL: 0.1,\n    // RSLV-07: near_label proximity match (max, before distance weighting)\n    LANDMARK: 0.1,\n    // landmark region match\n    SECTION_HEADING: 0.08\n    // section heading match\n  };\n  var MAX_STRUCTURAL_BOOST = 0.35;\n  function hintValuesToStrings(hints) {\n    const values = [];\n    for (const hint of hints) {\n      if (typeof hint.value === \"string\") {\n        const normalized = normalizeText(hint.value);\n        if (normalized) values.push(normalized);\n      }\n    }\n    return values;\n  }\n  function findMatchingHintValue(text, hintValues) {\n    const normalizedText = normalizeText(text);\n    if (!normalizedText) return null;\n    for (const value of hintValues) {\n      if (normalizedText.includes(value) || value.includes(normalizedText)) {\n        return value;\n      }\n    }\n    return null;\n  }\n  function computeStructuralBoost(context, hints) {\n    const details = [];\n    let total = 0;\n    const hintValues = hintValuesToStrings(hints);\n    if (context.fieldset_legend) {\n      const match = findMatchingHintValue(context.fieldset_legend, hintValues);\n      if (match) {\n        const boost = STRUCTURAL_BOOST_VALUES.FIELDSET_LEGEND;\n        total += boost;\n        details.push({\n          type: \"fieldset\",\n          boost,\n          reason: `fieldset legend '${context.fieldset_legend}' matches hint '${match}'`\n        });\n      }\n    }\n    if (context.associated_label) {\n      const labelHintValues = hints.filter((h) => h.type === \"near_label\" || h.type === \"aria_label\" || h.type === \"text_contains\").filter((h) => typeof h.value === \"string\").map((h) => normalizeText(h.value));\n      const allValues = [.../* @__PURE__ */ new Set([...labelHintValues, ...hintValues])];\n      const match = findMatchingHintValue(context.associated_label, allValues);\n      if (match) {\n        const boost = STRUCTURAL_BOOST_VALUES.ASSOCIATED_LABEL;\n        total += boost;\n        details.push({\n          type: \"label\",\n          boost,\n          reason: `associated label '${context.associated_label}' matches hint '${match}'`\n        });\n      }\n    }\n    if (context.near_label) {\n      const proximityHintValues = hints.filter((h) => h.type === \"near_label\" || h.type === \"text_contains\" || h.type === \"placeholder_contains\").filter((h) => typeof h.value === \"string\").map((h) => normalizeText(h.value));\n      const allValues = [.../* @__PURE__ */ new Set([...proximityHintValues, ...hintValues])];\n      const match = findMatchingHintValue(context.near_label.text, allValues);\n      if (match) {\n        const distanceWeight = 1 - (context.near_label.distance - 1) / 3;\n        const boost = STRUCTURAL_BOOST_VALUES.NEAR_LABEL * distanceWeight;\n        total += boost;\n        details.push({\n          type: \"near_label\",\n          boost,\n          reason: `near label '${context.near_label.text}' at distance ${context.near_label.distance} matches hint '${match}'`\n        });\n      }\n    }\n    if (context.landmark) {\n      const landmarkMatch = hints.some((h) => {\n        if (typeof h.value !== \"string\") return false;\n        const normalizedValue = normalizeText(h.value);\n        const normalizedLandmark = normalizeText(context.landmark);\n        return normalizedValue === normalizedLandmark || normalizedValue.includes(normalizedLandmark);\n      });\n      const nameMatch = !landmarkMatch && findMatchingHintValue(context.landmark, hintValues);\n      if (landmarkMatch || nameMatch) {\n        const boost = STRUCTURAL_BOOST_VALUES.LANDMARK;\n        total += boost;\n        details.push({\n          type: \"landmark\",\n          boost,\n          reason: `landmark '${context.landmark}' matches hint`\n        });\n      }\n    }\n    if (context.section_heading) {\n      const match = findMatchingHintValue(context.section_heading, hintValues);\n      if (match) {\n        const boost = STRUCTURAL_BOOST_VALUES.SECTION_HEADING;\n        total += boost;\n        details.push({\n          type: \"heading\",\n          boost,\n          reason: `section heading '${context.section_heading}' matches hint '${match}'`\n        });\n      }\n    }\n    total = Math.min(total, MAX_STRUCTURAL_BOOST);\n    return { total, details };\n  }\n\n  // resolver-bundle/cascadeResolver.ts\n  function getStabilityBoost(_hints) {\n    return 0;\n  }\n  function recordSuccess(_hints, _matchedKeys) {\n  }\n  function recordFailure(_hints) {\n  }\n  async function sendMicroPrompt(input) {\n    try {\n      const bridge = window.__browserlet_microPrompt;\n      if (typeof bridge !== \"function\") {\n        return null;\n      }\n      const responseJson = await bridge(JSON.stringify(input));\n      const response = JSON.parse(responseJson);\n      if (response?.success && response.data?.success && response.data.output) {\n        return response.data.output.data;\n      }\n      const errorMsg = response?.data?.error || response?.error || \"Unknown micro-prompt failure\";\n      console.warn(`[CascadeResolver] Micro-prompt ${input.type} failed: ${errorMsg}`);\n      return null;\n    } catch (error) {\n      console.warn(`[CascadeResolver] Micro-prompt ${input.type} bridge error:`, error);\n      return null;\n    }\n  }\n  function getMicroPromptsEnabled() {\n    return typeof window.__browserlet_microPrompt === \"function\";\n  }\n  var STAGE_1_CONFIDENCE = 0.85;\n  var STAGE_2_CONFIDENCE = 0.7;\n  var HIGH_WEIGHT_THRESHOLD = 0.9;\n  var STAGE_2_COMPETITOR_GAP = 0.2;\n  function hasHighWeightMatch(matchedHints, hints) {\n    const matchedTypes = /* @__PURE__ */ new Set();\n    for (const matched of matchedHints) {\n      const colonIndex = matched.indexOf(\":\");\n      if (colonIndex > 0) {\n        matchedTypes.add(matched.substring(0, colonIndex));\n      }\n    }\n    for (const type of matchedTypes) {\n      const weight = HINT_WEIGHTS[type];\n      if (weight !== void 0 && weight >= HIGH_WEIGHT_THRESHOLD) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function gatherCompetitors(hints, bestConfidence) {\n    const highWeightHints = hints.filter((h) => {\n      const weight = HINT_WEIGHTS[h.type];\n      return weight !== void 0 && weight >= HIGH_WEIGHT_THRESHOLD;\n    });\n    const candidateSet = /* @__PURE__ */ new Set();\n    for (const hint of highWeightHints) {\n      if (typeof hint.value !== \"string\") continue;\n      let elements = [];\n      switch (hint.type) {\n        case \"role\":\n          elements = Array.from(document.querySelectorAll(`[role=\"${hint.value}\"]`));\n          break;\n        case \"type\":\n          elements = Array.from(document.querySelectorAll(`[type=\"${hint.value}\"]`));\n          break;\n        case \"name\":\n          elements = Array.from(document.querySelectorAll(`[name=\"${hint.value}\"]`));\n          break;\n        case \"id\": {\n          const el = document.getElementById(hint.value);\n          if (el) elements = [el];\n          break;\n        }\n        case \"aria_label\":\n          elements = Array.from(document.querySelectorAll(`[aria-label=\"${hint.value}\"]`));\n          break;\n        case \"data_attribute\":\n          break;\n      }\n      for (const el of elements) {\n        const rect = el.getBoundingClientRect();\n        if (rect.width > 0 && rect.height > 0) {\n          candidateSet.add(el);\n        }\n      }\n    }\n    if (candidateSet.size === 0) {\n      const textHint = hints.find((h) => h.type === \"text_contains\" && typeof h.value === \"string\");\n      const classHint = hints.find((h) => h.type === \"class_contains\" && typeof h.value === \"string\");\n      if (textHint && typeof textHint.value === \"string\") {\n        const needle = normalizeText(textHint.value);\n        const potentials = document.querySelectorAll(\n          \"a, button, div, span, li, td, article, section, [tabindex], [onclick], [role]\"\n        );\n        for (const el of potentials) {\n          const text = normalizeText(el.textContent);\n          if (text.includes(needle)) {\n            const rect = el.getBoundingClientRect();\n            if (rect.width > 0 && rect.height > 0) {\n              if (classHint && typeof classHint.value === \"string\") {\n                if (el.classList.contains(classHint.value)) {\n                  candidateSet.add(el);\n                }\n              } else {\n                candidateSet.add(el);\n              }\n            }\n          }\n        }\n      }\n    }\n    const maxPossibleScore = hints.reduce((sum, hint) => sum + HINT_WEIGHTS[hint.type], 0);\n    if (maxPossibleScore === 0) return [];\n    const results = [];\n    for (const candidate of candidateSet) {\n      let score = 0;\n      const matchedHints = [];\n      const failedHints = [];\n      for (const hint of hints) {\n        const hintDescription = typeof hint.value === \"string\" ? `${hint.type}:${hint.value}` : `${hint.type}:${hint.value.name}=${hint.value.value}`;\n        if (matchHintSimple(candidate, hint)) {\n          score += HINT_WEIGHTS[hint.type];\n          matchedHints.push(hintDescription);\n        } else {\n          failedHints.push(hintDescription);\n        }\n      }\n      const confidence = score / maxPossibleScore;\n      if (confidence >= bestConfidence - STAGE_2_COMPETITOR_GAP) {\n        results.push({ element: candidate, confidence, matchedHints, failedHints });\n      }\n    }\n    return results;\n  }\n  function matchHintSimple(element, hint) {\n    if (typeof hint.value === \"string\") {\n      const value = hint.value;\n      switch (hint.type) {\n        case \"role\": {\n          const explicitRole = element.getAttribute(\"role\");\n          if (explicitRole === value) return true;\n          const tag = element.tagName.toLowerCase();\n          if (tag === \"input\") {\n            const inputType = element.type || \"text\";\n            const implicitRoles = {\n              \"button\": \"button\",\n              \"submit\": \"button\",\n              \"reset\": \"button\",\n              \"checkbox\": \"checkbox\",\n              \"radio\": \"radio\",\n              \"range\": \"slider\",\n              \"search\": \"searchbox\",\n              \"email\": \"textbox\",\n              \"tel\": \"textbox\",\n              \"url\": \"textbox\",\n              \"number\": \"spinbutton\",\n              \"text\": \"textbox\"\n            };\n            return implicitRoles[inputType] === value;\n          }\n          const tagRoles = {\n            \"a\": \"link\",\n            \"button\": \"button\",\n            \"select\": \"combobox\",\n            \"textarea\": \"textbox\",\n            \"nav\": \"navigation\",\n            \"main\": \"main\",\n            \"header\": \"banner\",\n            \"footer\": \"contentinfo\"\n          };\n          return tagRoles[tag] === value;\n        }\n        case \"id\":\n          return element.id === value;\n        case \"type\":\n          return element.getAttribute(\"type\") === value;\n        case \"name\":\n          return element.getAttribute(\"name\") === value;\n        case \"aria_label\":\n          return element.getAttribute(\"aria-label\") === value;\n        case \"text_contains\": {\n          const text = normalizeText(element.textContent);\n          return text.includes(normalizeText(value));\n        }\n        case \"placeholder_contains\": {\n          const placeholder = element.getAttribute(\"placeholder\") || \"\";\n          return normalizeText(placeholder).includes(normalizeText(value));\n        }\n        case \"near_label\":\n          return false;\n        case \"class_contains\":\n          return element.classList.contains(value);\n      }\n    } else if (hint.type === \"data_attribute\") {\n      const { name, value: attrValue } = hint.value;\n      return element.getAttribute(name) === attrValue;\n    }\n    return false;\n  }\n  function formatDOMContextString(ctx) {\n    const parts = [];\n    if (ctx.fieldset_legend) parts.push(`inside fieldset '${ctx.fieldset_legend}'`);\n    if (ctx.associated_label) parts.push(`label '${ctx.associated_label}'`);\n    if (ctx.near_label) parts.push(`near '${ctx.near_label.text}'`);\n    if (ctx.landmark) parts.push(`in ${ctx.landmark} landmark`);\n    if (ctx.section_heading) parts.push(`under heading '${ctx.section_heading}'`);\n    return parts.join(\", \") || \"no structural context\";\n  }\n  function getDOMExcerpt() {\n    const main = document.querySelector(\"main\") || document.querySelector('[role=\"main\"]') || document.body;\n    const excerpt = main.innerHTML.slice(0, 500);\n    return excerpt;\n  }\n  async function resolveElementCascade(hints, _retryDepth = 0) {\n    const startTime = performance.now();\n    if (hints.length === 0) {\n      return {\n        element: null,\n        confidence: 0,\n        matchedHints: [],\n        failedHints: [],\n        stage: 1,\n        resolutionTimeMs: performance.now() - startTime\n      };\n    }\n    const stabilityBoost = getStabilityBoost(hints);\n    const stage1Result = resolveElement(hints);\n    const stage1Confidence = Math.min(stage1Result.confidence + stabilityBoost, 1);\n    if (stage1Result.element && stage1Confidence >= STAGE_1_CONFIDENCE && hasHighWeightMatch(stage1Result.matchedHints, hints)) {\n      const result = {\n        ...stage1Result,\n        confidence: stage1Confidence,\n        stage: 1,\n        stabilityBoost: stabilityBoost > 0 ? stabilityBoost : void 0,\n        resolutionTimeMs: performance.now() - startTime\n      };\n      recordSuccess(hints, stage1Result.matchedHints);\n      return result;\n    }\n    const competitors = gatherCompetitors(hints, stage1Result.confidence);\n    if (stage1Result.element) {\n      const alreadyIncluded = competitors.some((c) => c.element === stage1Result.element);\n      if (!alreadyIncluded) {\n        competitors.push({\n          element: stage1Result.element,\n          confidence: stage1Result.confidence,\n          matchedHints: stage1Result.matchedHints,\n          failedHints: stage1Result.failedHints\n        });\n      }\n    }\n    if (competitors.length === 0) {\n      const microPromptsEnabled2 = getMicroPromptsEnabled();\n      if (microPromptsEnabled2 && _retryDepth === 0) {\n        const formInputHintTypes = /* @__PURE__ */ new Set([\"placeholder_contains\"]);\n        const formInputTypeValues = /* @__PURE__ */ new Set([\"text\", \"password\", \"email\", \"tel\", \"number\", \"search\", \"url\"]);\n        const hintsReferenceFormElement = hints.some(\n          (h) => formInputHintTypes.has(h.type) || h.type === \"type\" && typeof h.value === \"string\" && formInputTypeValues.has(h.value)\n        );\n        const pageHasFormElements = document.querySelectorAll(\"input, select, textarea\").length > 0;\n        if (hintsReferenceFormElement && !pageHasFormElements) {\n          console.log(\"[CascadeResolver] Stage 3: skipping hint_suggester -- hints reference form elements but page has none (likely wrong page)\");\n        } else {\n          console.log(\"[CascadeResolver] Stage 3: hint_suggester (zero candidates)\");\n          const hintSuggesterInput = {\n            type: \"hint_suggester\",\n            data: {\n              original_hints: hints,\n              dom_excerpt: getDOMExcerpt(),\n              page_url: window.location.href,\n              action_type: \"click\"\n              // Default; caller doesn't pass action type currently\n            }\n          };\n          const suggestion = await sendMicroPrompt(hintSuggesterInput);\n          if (suggestion && suggestion.suggested_hints.length > 0) {\n            console.log(\"[CascadeResolver] Stage 3: retrying with\", suggestion.suggested_hints.length, \"suggested hints\");\n            const retryResult = await resolveElementCascade(suggestion.suggested_hints, _retryDepth + 1);\n            if (retryResult.element && retryResult.confidence >= STAGE_2_CONFIDENCE) {\n              return {\n                ...retryResult,\n                stage: 3,\n                resolutionTimeMs: performance.now() - startTime\n              };\n            }\n          }\n        }\n      }\n      const result = {\n        ...stage1Result,\n        stage: microPromptsEnabled2 ? 3 : 2,\n        resolutionTimeMs: performance.now() - startTime\n      };\n      recordFailure(hints);\n      return result;\n    }\n    let bestCandidate = null;\n    for (const candidate of competitors) {\n      const domContext = extractDOMContext(candidate.element);\n      const structuralBoost = computeStructuralBoost(domContext, hints);\n      const adjustedConfidence = Math.min(\n        candidate.confidence + structuralBoost.total + stabilityBoost,\n        1\n      );\n      if (!bestCandidate || adjustedConfidence > bestCandidate.adjustedConfidence) {\n        bestCandidate = {\n          element: candidate.element,\n          adjustedConfidence,\n          matchedHints: candidate.matchedHints,\n          failedHints: candidate.failedHints,\n          structuralBoost\n        };\n      }\n    }\n    if (bestCandidate && bestCandidate.adjustedConfidence >= STAGE_2_CONFIDENCE) {\n      const result = {\n        element: bestCandidate.element,\n        confidence: bestCandidate.adjustedConfidence,\n        matchedHints: bestCandidate.matchedHints,\n        failedHints: bestCandidate.failedHints,\n        stage: 2,\n        structuralBoost: bestCandidate.structuralBoost,\n        stabilityBoost: stabilityBoost > 0 ? stabilityBoost : void 0,\n        resolutionTimeMs: performance.now() - startTime\n      };\n      recordSuccess(hints, bestCandidate.matchedHints);\n      return result;\n    }\n    const microPromptsEnabled = getMicroPromptsEnabled();\n    if (microPromptsEnabled && competitors.length >= 2) {\n      const highScorers = competitors.filter((c) => {\n        const ctx = extractDOMContext(c.element);\n        const boost = computeStructuralBoost(ctx, hints);\n        return c.confidence + boost.total + stabilityBoost >= STAGE_2_CONFIDENCE;\n      });\n      if (highScorers.length >= 2) {\n        console.log(\"[CascadeResolver] Stage 4: disambiguator (\" + highScorers.length + \" candidates >= 0.70)\");\n        const candidateInfos = highScorers.slice(0, 5).map((c, idx) => {\n          const ctx = extractDOMContext(c.element);\n          const el = c.element;\n          const attrs = {};\n          for (const attr of el.attributes) {\n            if ([\"id\", \"name\", \"type\", \"role\", \"class\", \"aria-label\", \"placeholder\", \"href\"].includes(attr.name)) {\n              attrs[attr.name] = attr.value;\n            }\n          }\n          return {\n            index: idx,\n            tag: el.tagName.toLowerCase(),\n            text: (el.textContent || \"\").trim().slice(0, 50),\n            attributes: attrs,\n            structural_context: formatDOMContextString(ctx)\n          };\n        });\n        const disambiguatorInput = {\n          type: \"disambiguator\",\n          data: {\n            candidates: candidateInfos,\n            original_hints: hints,\n            action_type: \"click\"\n          }\n        };\n        const disambiguation = await sendMicroPrompt(disambiguatorInput);\n        if (disambiguation && disambiguation.selected_index >= 0 && disambiguation.selected_index < highScorers.length) {\n          const selected = highScorers[disambiguation.selected_index];\n          const selectedCtx = extractDOMContext(selected.element);\n          const selectedBoost = computeStructuralBoost(selectedCtx, hints);\n          console.log(\"[CascadeResolver] Stage 4: disambiguator selected index\", disambiguation.selected_index, \"confidence:\", disambiguation.confidence);\n          const result = {\n            element: selected.element,\n            confidence: Math.min(selected.confidence + selectedBoost.total + stabilityBoost, 1),\n            matchedHints: selected.matchedHints,\n            failedHints: selected.failedHints,\n            stage: 4,\n            structuralBoost: selectedBoost,\n            stabilityBoost: stabilityBoost > 0 ? stabilityBoost : void 0,\n            resolutionTimeMs: performance.now() - startTime\n          };\n          recordSuccess(hints, selected.matchedHints);\n          return result;\n        }\n      }\n    }\n    if (microPromptsEnabled && bestCandidate) {\n      const candidateConfidence = bestCandidate.adjustedConfidence;\n      if (candidateConfidence >= 0.5 && candidateConfidence < STAGE_2_CONFIDENCE) {\n        console.log(\"[CascadeResolver] Stage 5: confidence_booster (confidence:\", candidateConfidence.toFixed(2), \")\");\n        const el = bestCandidate.element;\n        const ctx = extractDOMContext(el);\n        const attrs = {};\n        for (const attr of el.attributes) {\n          if ([\"id\", \"name\", \"type\", \"role\", \"class\", \"aria-label\", \"placeholder\", \"href\"].includes(attr.name)) {\n            attrs[attr.name] = attr.value;\n          }\n        }\n        const boosterInput = {\n          type: \"confidence_booster\",\n          data: {\n            candidate: {\n              tag: el.tagName.toLowerCase(),\n              text: (el.textContent || \"\").trim().slice(0, 50),\n              attributes: attrs,\n              structural_context: formatDOMContextString(ctx)\n            },\n            original_hints: hints,\n            matched_hints: bestCandidate.matchedHints,\n            failed_hints: bestCandidate.failedHints,\n            confidence: candidateConfidence\n          }\n        };\n        const boost = await sendMicroPrompt(boosterInput);\n        if (boost && boost.is_correct) {\n          console.log(\"[CascadeResolver] Stage 5: confidence_booster confirmed element\");\n          const result = {\n            element: bestCandidate.element,\n            confidence: Math.min(candidateConfidence + 0.2, 1),\n            // Boost confidence by 0.20 on LLM confirmation\n            matchedHints: bestCandidate.matchedHints,\n            failedHints: bestCandidate.failedHints,\n            stage: 5,\n            structuralBoost: bestCandidate.structuralBoost,\n            stabilityBoost: stabilityBoost > 0 ? stabilityBoost : void 0,\n            resolutionTimeMs: performance.now() - startTime\n          };\n          recordSuccess(hints, bestCandidate.matchedHints);\n          return result;\n        } else if (boost && !boost.is_correct) {\n          console.log(\"[CascadeResolver] Stage 5: confidence_booster rejected element\");\n        }\n      }\n    }\n    const failResult = {\n      element: bestCandidate?.element ?? null,\n      confidence: bestCandidate?.adjustedConfidence ?? stage1Result.confidence,\n      matchedHints: bestCandidate?.matchedHints ?? stage1Result.matchedHints,\n      failedHints: bestCandidate?.failedHints ?? stage1Result.failedHints,\n      stage: microPromptsEnabled ? 5 : 2,\n      structuralBoost: bestCandidate?.structuralBoost,\n      stabilityBoost: stabilityBoost > 0 ? stabilityBoost : void 0,\n      resolutionTimeMs: performance.now() - startTime\n    };\n    recordFailure(hints);\n    return failResult;\n  }\n  function waitForElementCascade(hints, timeoutMs = 1e4) {\n    return new Promise((resolve, reject) => {\n      const overallStart = performance.now();\n      resolveElementCascade(hints).then((immediateResult) => {\n        if (immediateResult.element && isElementInteractable(immediateResult.element)) {\n          resolve(immediateResult);\n          return;\n        }\n        let observer = null;\n        let timeoutId = null;\n        let resolving = false;\n        const cleanup = () => {\n          if (observer) {\n            observer.disconnect();\n            observer = null;\n          }\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n          }\n        };\n        const checkElement = () => {\n          if (resolving) return;\n          resolving = true;\n          resolveElementCascade(hints).then((result) => {\n            resolving = false;\n            if (result.element && isElementInteractable(result.element)) {\n              cleanup();\n              result.resolutionTimeMs = performance.now() - overallStart;\n              resolve(result);\n            }\n          }).catch(() => {\n            resolving = false;\n          });\n        };\n        observer = new MutationObserver(() => {\n          checkElement();\n        });\n        observer.observe(document.body, {\n          childList: true,\n          subtree: true,\n          attributes: true,\n          attributeFilter: [\"class\", \"style\", \"hidden\", \"aria-hidden\", \"disabled\", \"aria-disabled\"]\n        });\n        timeoutId = setTimeout(() => {\n          cleanup();\n          const hintsDebug = hints.map(\n            (h) => typeof h.value === \"string\" ? `${h.type}:${h.value}` : `${h.type}:${h.value.name}=${h.value.value}`\n          ).join(\", \");\n          reject(new Error(\n            `waitForElementCascade timeout after ${timeoutMs}ms. Could not find interactable element matching hints: [${hintsDebug}]`\n          ));\n        }, timeoutMs);\n      }).catch(reject);\n    });\n  }\n\n  // resolver-bundle/entry.ts\n  globalThis.__browserletResolver = {\n    resolveElementCascade,\n    waitForElementCascade,\n    resolveElement,\n    isElementInteractable,\n    extractDOMContext,\n    computeStructuralBoost,\n    HINT_WEIGHTS\n  };\n  return __toCommonJS(entry_exports);\n})();\n";
