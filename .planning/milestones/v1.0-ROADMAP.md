# Milestone v1.0: Browserlet MVP

**Status:** ✅ SHIPPED 2026-01-31
**Phases:** 1-6
**Total Plans:** 33

## Overview

Browserlet delivers semantic web automation for legacy applications through six phases: establish the Chrome extension foundation (service worker, storage, messaging), capture user interactions with AI-powered semantic hints, build a professional script management interface, execute scripts deterministically with resilient selectors, enhance recording with LLM-generated semantic analysis, and finally enable contextual automation with smart suggestions. Each phase delivers a complete component that builds toward deterministic, cost-free automation for legacy apps without APIs.

## Phases

### Phase 1: Foundation
**Goal**: Extension infrastructure ready for recording and playback
**Depends on**: Nothing (first phase)
**Plans**: 3 plans

Plans:
- [x] 01-01-PLAN.md — WXT project setup + service worker message router
- [x] 01-02-PLAN.md — Content script with context invalidation + side panel stub
- [x] 01-03-PLAN.md — Unit tests + manual E2E verification

**Success Criteria:**
1. Extension loads in Chrome and appears in extensions list
2. Service worker receives and routes messages between components
3. Extension state persists across browser restarts via chrome.storage.local
4. Context invalidation is detected and communicated to user
5. All communication patterns work (service worker <-> content script <-> side panel)

### Phase 2: Recording
**Goal**: User can record interactions and generate semantic BSL scripts
**Depends on**: Phase 1
**Plans**: 5 plans

Plans:
- [x] 02-01-PLAN.md — Recording types, hint utilities, and hint generator
- [x] 02-02-PLAN.md — Visual feedback overlay system
- [x] 02-03-PLAN.md — Event capture, navigation capture, and RecordingManager
- [x] 02-04-PLAN.md — Side Panel controls, iframe injection, message wiring
- [x] 02-05-PLAN.md — E2E verification checkpoint

**Success Criteria:**
1. User can start recording mode from Side Panel
2. User's clicks, typing, and navigation are captured with visual feedback
3. Captured actions include semantic hints (role, aria-label, text, data-attribute)
4. Recording works inside iframes
5. Captured action sequence is available for script generation

### Phase 3: Side Panel
**Goal**: Professional UI for managing and editing BSL scripts
**Depends on**: Phase 2
**Plans**: 7 plans

Plans:
- [x] 03-01-PLAN.md — Install dependencies, configure Monaco + i18n
- [x] 03-02-PLAN.md — Script types and storage CRUD operations
- [x] 03-03-PLAN.md — Monaco Editor component with YAML support
- [x] 03-04-PLAN.md — Script list with search/filter
- [x] 03-05-PLAN.md — Import/export as YAML files
- [x] 03-06-PLAN.md — Execution view with progress and results
- [x] 03-07-PLAN.md — UI integration and E2E verification

**Success Criteria:**
1. User can see list of saved scripts with search and filtering
2. User can edit BSL scripts in Monaco Editor with YAML syntax highlighting
3. User can import and export scripts as YAML files
4. Execution progress displays current step with progress bar
5. Execution results can be copied as JSON or CSV
6. UI appears in French or English based on browser language
7. Scripts are persisted locally and survive browser restart

### Phase 4: Playback
**Goal**: Deterministic execution of BSL scripts with resilient semantic selectors
**Depends on**: Phase 3
**Plans**: 7 plans

Plans:
- [x] 04-01-PLAN.md — Playback types and BSL step parser
- [x] 04-02-PLAN.md — Humanization delay utilities
- [x] 04-03-PLAN.md — Semantic resolver with weighted scoring
- [x] 04-04-PLAN.md — Action executor (all 8 BSL actions)
- [x] 04-05-PLAN.md — Session detector for authentication
- [x] 04-06-PLAN.md — PlaybackManager orchestrator
- [x] 04-07-PLAN.md — UI wiring and E2E verification

**Success Criteria:**
1. User can execute a BSL script from Side Panel
2. Semantic resolver finds elements using multi-hint strategy
3. All 8 BSL actions work (click, type, select, extract, wait_for, navigate, scroll, hover)
4. Execution handles missing elements with clear error messages
5. User can stop execution at any time
6. Extension detects when user is logged out and pauses for manual authentication
7. Humanization layer adds realistic delays to avoid bot detection

### Phase 5: LLM Integration
**Goal**: AI-enhanced semantic selector generation during recording
**Depends on**: Phase 4
**Plans**: 5 plans

Plans:
- [x] 05-01-PLAN.md — Install dependencies, manifest host_permissions, encryption utils
- [x] 05-02-PLAN.md — Provider types, rate limiter, prompt builder, fallback generator
- [x] 05-03-PLAN.md — Claude provider, Ollama provider, LLM service facade
- [x] 05-04-PLAN.md — Message handlers, config store, Settings UI component
- [x] 05-05-PLAN.md — UI integration, recording wiring, E2E verification

**Success Criteria:**
1. User can configure Claude API or Ollama with their own API key
2. Recorded actions are sent to LLM for BSL script generation
3. Generated BSL scripts use semantic hints from LLM analysis
4. Rate limiting prevents API exhaustion with exponential backoff
5. Extension falls back to basic selectors if LLM unavailable
6. API keys are stored encrypted in chrome.storage

### Phase 6: Contextual Triggers
**Goal**: Smart automation with context-aware script suggestions
**Depends on**: Phase 5
**Plans**: 6 plans

Plans:
- [x] 06-01-PLAN.md — Trigger types and storage layer
- [x] 06-02-PLAN.md — Content script context detection (URL + element)
- [x] 06-03-PLAN.md — Background trigger engine and notifications
- [x] 06-04-PLAN.md — Message wiring (content <-> background)
- [x] 06-05-PLAN.md — Side Panel UI components (TriggerConfig, SuggestedScripts)
- [x] 06-06-PLAN.md — UI integration and E2E verification

**Success Criteria:**
1. Extension detects current page context (URL, visible elements, entities)
2. Relevant scripts appear in Side Panel when context matches (suggest mode)
3. Scripts can auto-execute when context matches with user notification
4. Triggers support URL patterns and element presence conditions
5. User can enable or disable triggers per site
6. Context detection works continuously without performance impact

---

## Milestone Summary

**Key Decisions:**
- WXT framework for Chrome extension scaffolding
- VanJS for reactive UI (lightweight, no build step)
- Monaco Editor for YAML editing
- 10 semantic hint types for element identification
- AES-GCM 256-bit encryption for API keys
- In-page notifications for cross-platform support (macOS fix)
- Cooldown system for auto-execute triggers

**Issues Resolved:**
- Cross-page navigation state persistence
- Context invalidation detection
- macOS notification button support (in-page overlay solution)
- VanJS reactivity for modal components

**Technical Debt:**
- Pre-existing TypeScript errors in LLM providers (WXT-generated types)
- Provider comparison needed (rate limits, accuracy, cost)

---

*Archived: 2026-01-31 as part of v1.0 milestone completion*
*For current project status, see .planning/ROADMAP.md*
