---
phase: 22-firefox-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - entrypoints/sidepanel/components/RecordingView.tsx
  - entrypoints/sidepanel/components/CredentialManager.tsx
  - entrypoints/background/index.ts
  - utils/storage/browserCompat.ts
autonomous: true

must_haves:
  truths:
    - "Extension builds for Firefox with zero TypeScript errors via npm run build:firefox"
    - "Extension builds for Chrome with zero TypeScript errors via npm run build (no regressions)"
    - "Firefox sidebar opens via browser action click (sidebarAction.toggle)"
    - "chrome.scripting.executeScript calls are guarded for Firefox where scripting permission is unavailable"
    - "All storage operations use browserCompat polyfill consistently"
  artifacts:
    - path: "utils/storage/browserCompat.ts"
      provides: "Cross-browser storage API polyfill"
      contains: "browserAPI"
    - path: "entrypoints/background/index.ts"
      provides: "Background entry with Firefox sidebar toggle"
      contains: "sidebarAction"
    - path: "entrypoints/sidepanel/components/RecordingView.tsx"
      provides: "Recording UI with guarded scripting API"
      contains: "isFirefox"
    - path: "entrypoints/sidepanel/components/CredentialManager.tsx"
      provides: "Credential UI with guarded scripting API"
      contains: "isFirefox"
  key_links:
    - from: "entrypoints/background/index.ts"
      to: "utils/browser-detect.ts"
      via: "import isFirefox"
      pattern: "isFirefox"
    - from: "entrypoints/sidepanel/components/RecordingView.tsx"
      to: "utils/browser-detect.ts"
      via: "import isFirefox for scripting guard"
      pattern: "isFirefox.*scripting"
---

<objective>
Verify the Firefox build succeeds and fix all runtime compatibility issues between Chrome MV3 and Firefox MV3.

Purpose: Ensure the extension can build, load, and initialize correctly in Firefox before functional validation. This plan addresses API differences (sidePanel vs sidebar_action, chrome.scripting availability, storage serialization).

Output: Both `npm run build` (Chrome) and `npm run build:firefox` (Firefox) produce zero-error builds. Runtime API calls are guarded for browser differences.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@wxt.config.ts
@utils/storage/browserCompat.ts
@utils/browser-detect.ts
@utils/firefoxPolyfill.ts
@entrypoints/background/index.ts
@entrypoints/sidepanel/components/RecordingView.tsx
@entrypoints/sidepanel/components/CredentialManager.tsx
@entrypoints/background/triggers/notifications.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Firefox build verification and chrome.scripting guards</name>
  <files>
    entrypoints/sidepanel/components/RecordingView.tsx
    entrypoints/sidepanel/components/CredentialManager.tsx
  </files>
  <action>
1. Run `npm run build:firefox` and capture output. If build succeeds with zero errors, proceed. If errors, fix them before continuing.

2. Run `npm run build` (Chrome) and verify zero errors (no regressions).

3. Guard `chrome.scripting.executeScript` calls in two files. Firefox MV3 does NOT include the `scripting` permission (see wxt.config.ts line 54 -- `firefoxPermissions` omits `scripting`). The two locations that call `chrome.scripting.executeScript` are:

   **RecordingView.tsx** (around line 327): Content script injection fallback when PING fails.
   - Import `isFirefox` from `utils/browser-detect`.
   - Wrap the `chrome.scripting.executeScript(...)` block in `if (!isFirefox)`.
   - For Firefox, skip the injection attempt and fall through to the error message. Content scripts are registered via WXT manifest and auto-injected on Firefox, so manual injection is unnecessary. The catch block should show a message like "Content script not loaded. Please refresh the page." for Firefox instead of attempting injection.

   **CredentialManager.tsx** (around line 503): Same pattern for credential capture injection.
   - Import `isFirefox` from `utils/browser-detect`.
   - Apply the same guard: if Firefox, skip `chrome.scripting.executeScript` and show a user-friendly message to refresh the page instead.

4. After changes, run both builds again to confirm zero errors on both targets.
  </action>
  <verify>
    Run `npm run build:firefox 2>&1 | tail -5` -- must show success with zero errors.
    Run `npm run build 2>&1 | tail -5` -- must show success with zero errors.
    Run `grep -n "isFirefox" entrypoints/sidepanel/components/RecordingView.tsx` -- must show the guard.
    Run `grep -n "isFirefox" entrypoints/sidepanel/components/CredentialManager.tsx` -- must show the guard.
  </verify>
  <done>
    Both Chrome and Firefox builds succeed with zero errors.
    chrome.scripting.executeScript is guarded behind !isFirefox in RecordingView.tsx and CredentialManager.tsx.
  </done>
</task>

<task type="auto">
  <name>Task 2: Storage compatibility audit and browserCompat hardening</name>
  <files>
    utils/storage/browserCompat.ts
    entrypoints/background/index.ts
  </files>
  <action>
1. **Audit all storage access patterns** to verify they use the browserCompat polyfill consistently. Search for any direct `chrome.storage` calls that bypass the polyfill:
   - `grep -rn "chrome\.storage\." entrypoints/ utils/` -- any results NOT in browserCompat.ts itself are potential issues.
   - The cascadeResolver.ts uses `chrome.storage.local.get('browserlet_llm_config')` directly (line 269 of cascadeResolver.ts). This works because the firefoxPolyfill.ts replaces `chrome` with `browser` globally, so `chrome.storage` in Firefox actually calls `browser.storage`. This is acceptable -- document but do not change. The key insight is that `firefoxPolyfill.ts` makes ALL `chrome.*` calls work cross-browser by aliasing.

2. **Verify firefoxPolyfill.ts is imported** at the top of all three entry points:
   - `entrypoints/background/index.ts` -- already has `import '../../utils/firefoxPolyfill'` on line 1.
   - `entrypoints/sidepanel/main.tsx` -- already has it on line 1.
   - `entrypoints/content/index.ts` -- already has it on line 1.
   - If any are missing, add the import as the FIRST line.

3. **Verify storage serialization edge cases**: Firefox `browser.storage.local` has a known issue where storing very large objects (>5MB per key) silently truncates. The hint stability data (`browserlet_hint_stability_{hostname}`) is bounded to 200 keys per site (hintStabilityTracker.ts line 34), so each entry is well under 100KB. Document this is safe.

4. **Verify the `storage.onChanged` listener** in background/index.ts (line 18) works cross-browser. Firefox fires `onChanged` with `(changes, areaName)` -- same signature as Chrome MV3. The current code checks `namespace !== 'local'` which works on both. No changes needed.

5. Run both builds to confirm no regressions:
   - `npm run build:firefox` -- zero errors
   - `npm run build` -- zero errors
  </action>
  <verify>
    Run `grep -rn "chrome\.storage\." entrypoints/ utils/ --include="*.ts" --include="*.tsx" | grep -v node_modules | grep -v browserCompat.ts` and examine each result to confirm they are covered by firefoxPolyfill.ts aliasing.
    Run `grep -n "firefoxPolyfill" entrypoints/background/index.ts entrypoints/sidepanel/main.tsx entrypoints/content/index.ts` -- all three must show import on line 1.
  </verify>
  <done>
    All storage access patterns verified cross-browser compatible (either via browserCompat polyfill or firefoxPolyfill global alias).
    All three entry points import firefoxPolyfill as first import.
    No storage serialization risks for bounded data structures.
    Both builds pass with zero errors.
  </done>
</task>

</tasks>

<verification>
1. `npm run build:firefox` exits 0 with no TypeScript or bundling errors
2. `npm run build` exits 0 with no TypeScript or bundling errors (Chrome regression check)
3. `chrome.scripting.executeScript` calls are guarded with `isFirefox` checks
4. All entry points import firefoxPolyfill as first line
5. No direct `chrome.storage` calls bypass the polyfill/alias system
</verification>

<success_criteria>
- FFOX-01 satisfied: Extension builds and loads successfully in Firefox via `npm run build:firefox` with zero errors
- FFOX-04 partially: sidebar_action is correctly configured in manifest (already done in wxt.config.ts), sidebarAction.toggle works from background
- FFOX-05 partially: Storage operations verified compatible via polyfill/alias audit
- Chrome builds unchanged (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/22/22-01-SUMMARY.md`
</output>
