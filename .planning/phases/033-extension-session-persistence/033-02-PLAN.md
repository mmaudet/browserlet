---
phase: 033-extension-session-persistence
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - entrypoints/background/sessions.ts
  - entrypoints/content/index.ts
  - entrypoints/content/localStorageBridge.ts
autonomous: true

must_haves:
  truths:
    - Extension can restore cookies via chrome.cookies.set API with full metadata
    - Extension can inject and restore localStorage from content script context
    - Content script can capture localStorage state and send to background
    - Session restoration happens before script playback begins
  artifacts:
    - path: "entrypoints/background/sessions.ts"
      provides: "restoreSession function with cookie restoration via chrome.cookies.set"
      contains: "chrome.cookies.set"
    - path: "entrypoints/content/localStorageBridge.ts"
      provides: "LocalStorage capture and restoration bridge"
      min_lines: 80
      exports: ["captureLocalStorage", "restoreLocalStorage"]
    - path: "entrypoints/content/index.ts"
      provides: "Message handlers for localStorage operations"
      contains: "CAPTURE_LOCALSTORAGE"
  key_links:
    - from: "entrypoints/background/sessions.ts"
      to: "chrome.cookies.set"
      via: "Cookie restoration with metadata"
      pattern: "chrome\\.cookies\\.set"
    - from: "entrypoints/content/localStorageBridge.ts"
      to: "window.localStorage"
      via: "Direct localStorage API access"
      pattern: "localStorage\\.getItem|localStorage\\.setItem"
---

<objective>
Build the session restoration infrastructure that restores cookies via chrome.cookies.set API and restores localStorage via content script injection, enabling authenticated sessions to be reused across script executions.

Purpose: Complete the session persistence loop by implementing the restore-side infrastructure. This plan adds cookie restoration using chrome.cookies.set (which supports HttpOnly cookies) and localStorage restoration via content script injection, which Plan 03 will wire into the script execution flow.

Output: Session restoration module with localStorage bridge, enabling scripts to skip re-authentication by restoring captured sessions.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/phases/033-extension-session-persistence/033-01-PLAN.md

# Extension architecture files
@entrypoints/background/sessions.ts
@entrypoints/background/messaging.ts
@entrypoints/content/index.ts
@utils/crypto/encryption.ts
</context>

<tasks>

<task type="auto">
  <name>Add restoreSession function with chrome.cookies.set API</name>
  <files>entrypoints/background/sessions.ts, entrypoints/background/messaging.ts</files>
  <action>
Extend SessionStorage module with session restoration capabilities.

**In entrypoints/background/sessions.ts:**

1. Update SessionSnapshot interface to include localStorage:
   ```typescript
   interface SessionSnapshot {
     cookies: CookieSnapshot[];
     localStorage: Record<string, string>;  // NEW
     capturedAt: number;
     ttl: number;
   }
   ```

2. Update CookieSnapshot interface with full metadata:
   ```typescript
   interface CookieSnapshot {
     name: string;
     value: string;
     domain: string;
     path: string;
     secure: boolean;
     httpOnly: boolean;
     sameSite: 'no_restriction' | 'lax' | 'strict' | 'unspecified';
     expiresAt?: number;  // Unix timestamp
   }
   ```

3. Implement **restoreSession(scriptId: string, domain: string, tabId: number): Promise<boolean>**
   - Construct storage key from scriptId and domain
   - Read StoredSessionSnapshot from chrome.storage.local
   - If not found: return false (no session to restore)
   - Check TTL expiration (capturedAt + ttl < Date.now())
   - If expired: delete snapshot, return false
   - Get decryption key via getOrCreateSessionKey()
   - Decrypt snapshot via decryptApiKey(encrypted, key)
   - Parse JSON to SessionSnapshot
   - For each cookie in snapshot.cookies:
     - Prepare chrome.cookies.set details object:
       - url: construct from domain and path (https://${domain}${path})
       - name, value, domain, path
       - secure, httpOnly, sameSite (map to chrome.cookies enum)
       - expirationDate: convert expiresAt to Unix timestamp if present
     - Call chrome.cookies.set(details)
     - Catch individual cookie set errors (log warning, continue with others)
   - Send RESTORE_LOCALSTORAGE message to content script in tab:
     - chrome.tabs.sendMessage(tabId, { type: 'RESTORE_LOCALSTORAGE', payload: { data: snapshot.localStorage } })
   - Return true (restoration attempted)

**Handle Pitfalls (from research):**

- **HttpOnly asymmetry (Pitfall 1):** Use chrome.cookies.set (NOT document.cookie) which operates at browser level and supports HttpOnly
- **SameSite restoration (Pitfall 2):** Map sameSite correctly to chrome.cookies.SameSiteStatus enum ("unspecified", "lax", "strict", "no_restriction")
- **Secure flag enforcement (Pitfall 3):** Catch and log errors when Secure cookies fail on HTTP contexts (don't fail entire restoration)
- **URL construction:** Use https:// for Secure cookies, construct URL from domain+path for proper cookie scope

**In entrypoints/background/messaging.ts:**

4. Add RESTORE_SESSION message type to enum

5. Add message handler case:
   - Payload: { scriptId: string, domain: string, tabId: number }
   - Call restoreSession(scriptId, domain, tabId)
   - Return { success: true, restored: boolean }

**Error handling:**
- Individual cookie set failures are non-fatal (log warning, continue)
- Decryption failures return false (corrupt/invalid session)
- Missing session returns false (nothing to restore)
  </action>
  <verify>
- TypeScript compiles without errors: `npx tsc --noEmit -p tsconfig.json`
- grep -E "chrome\.cookies\.set" entrypoints/background/sessions.ts returns match
- grep -E "function restoreSession" entrypoints/background/sessions.ts returns match
- grep -E "RESTORE_SESSION" entrypoints/background/messaging.ts returns match
- grep -E "interface SessionSnapshot" entrypoints/background/sessions.ts shows localStorage field
  </verify>
  <done>
restoreSession function exists, uses chrome.cookies.set API to restore all cookies with full metadata (including HttpOnly), handles pitfalls correctly, and triggers localStorage restoration via content script message.
  </done>
</task>

<task type="auto">
  <name>Create localStorage bridge module in content script</name>
  <files>entrypoints/content/localStorageBridge.ts, entrypoints/content/index.ts</files>
  <action>
Create localStorage capture and restoration module accessible from content script context.

**Create entrypoints/content/localStorageBridge.ts:**

1. Implement **captureLocalStorage(): Record<string, string>**
   - Access window.localStorage directly (content script runs in page context)
   - Iterate localStorage keys: for (let i = 0; i < localStorage.length; i++)
   - Build object: { [key]: localStorage.getItem(key) }
   - Filter out null values (deleted keys)
   - Return serializable object (string key-value pairs only)
   - Catch errors gracefully (return empty object on SecurityError)

2. Implement **restoreLocalStorage(data: Record<string, string>): void**
   - Iterate data object keys
   - For each key-value pair: localStorage.setItem(key, value)
   - Catch individual setItem errors (log warning, continue)
   - SecurityError handling: log warning if localStorage access denied
   - QuotaExceededError handling: log warning if storage quota exceeded

3. Export both functions as named exports

**In entrypoints/content/index.ts:**

4. Import localStorage bridge:
   ```typescript
   import { captureLocalStorage, restoreLocalStorage } from './localStorageBridge';
   ```

5. Add message listener for CAPTURE_LOCALSTORAGE:
   - Call captureLocalStorage()
   - Send result back to background via chrome.runtime.sendMessage
   - Message type: LOCALSTORAGE_CAPTURED
   - Payload: { data: captured object }

6. Add message listener for RESTORE_LOCALSTORAGE:
   - Extract data from message payload
   - Call restoreLocalStorage(data)
   - No response needed (fire-and-forget restoration)

**Update captureSession in sessions.ts:**

7. Before encrypting snapshot, send message to content script to capture localStorage:
   - chrome.tabs.sendMessage(tabId, { type: 'CAPTURE_LOCALSTORAGE' })
   - Wait for LOCALSTORAGE_CAPTURED response
   - Include localStorage data in SessionSnapshot

**Implementation notes:**
- Content script has access to page's localStorage (not extension storage)
- LocalStorage is synchronous API (no promises needed)
- SecurityError can occur on certain pages (file://, data:, cross-origin iframes)
- Follow existing content script message patterns from recording/playback
  </action>
  <verify>
- TypeScript compiles without errors: `npx tsc --noEmit -p tsconfig.json`
- File exists: test -f entrypoints/content/localStorageBridge.ts
- grep -E "export.*function (captureLocalStorage|restoreLocalStorage)" entrypoints/content/localStorageBridge.ts returns both exports
- grep -E "localStorage\.(getItem|setItem)" entrypoints/content/localStorageBridge.ts returns matches
- grep -E "CAPTURE_LOCALSTORAGE|RESTORE_LOCALSTORAGE" entrypoints/content/index.ts returns matches
- grep -E "from.*localStorageBridge" entrypoints/content/index.ts confirms import
  </verify>
  <done>
LocalStorage bridge exists with capture and restoration functions, content script message handlers route CAPTURE_LOCALSTORAGE and RESTORE_LOCALSTORAGE messages, and localStorage data is included in session snapshots.
  </done>
</task>

</tasks>

<verification>
Run the following checks after all tasks complete:

1. TypeScript compilation:
   ```bash
   npx tsc --noEmit -p tsconfig.json
   ```
   Expected: Zero errors

2. File structure check:
   ```bash
   ls -lh entrypoints/content/localStorageBridge.ts
   ```
   Expected: File exists, size > 2KB

3. Cookie restoration API:
   ```bash
   grep -c "chrome.cookies.set" entrypoints/background/sessions.ts
   ```
   Expected: At least 1 match (restores cookies with metadata)

4. LocalStorage access:
   ```bash
   grep -c "localStorage\\.\\(getItem\\|setItem\\)" entrypoints/content/localStorageBridge.ts
   ```
   Expected: At least 2 matches (capture + restore)

5. Message handlers:
   ```bash
   grep -c "CAPTURE_LOCALSTORAGE\|RESTORE_LOCALSTORAGE" entrypoints/content/index.ts
   ```
   Expected: At least 4 matches (2 message types + 2 handlers)

6. SessionSnapshot structure:
   ```bash
   grep "localStorage:" entrypoints/background/sessions.ts
   ```
   Expected: localStorage field in SessionSnapshot interface

7. Export verification:
   ```bash
   grep -E "^export.*function restoreSession" entrypoints/background/sessions.ts
   ```
   Expected: restoreSession export exists
</verification>

<success_criteria>
Phase 33 Plan 02 is complete when:

1. restoreSession function exists and uses chrome.cookies.set API per SEXT-02
2. Cookie restoration includes full metadata (HttpOnly, SameSite, Secure, domain, path, expiry) per SEXT-03
3. LocalStorage bridge captures and restores page localStorage from content script context
4. Content script message handlers route CAPTURE_LOCALSTORAGE and RESTORE_LOCALSTORAGE
5. SessionSnapshot interface includes both cookies and localStorage fields
6. Error handling is graceful (individual failures don't break restoration)
7. Pitfalls from research are addressed (HttpOnly via chrome.cookies.set, SameSite mapping, Secure flag errors)
8. TypeScript compilation passes with zero errors
9. All must-haves artifacts exist and key links verified
</success_criteria>

<output>
After completion, create `.planning/phases/033-extension-session-persistence/033-02-SUMMARY.md` documenting:
- Session restoration infrastructure built
- Cookie restoration via chrome.cookies.set API
- LocalStorage bridge for content script context
- Message handlers for localStorage operations
- Pitfall handling (HttpOnly, SameSite, Secure)
- Verification results
</output>
