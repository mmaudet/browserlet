---
phase: 033-extension-session-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - entrypoints/background/index.ts
  - entrypoints/background/messaging.ts
  - entrypoints/background/sessions.ts
autonomous: true

must_haves:
  truths:
    - Extension can capture all cookies (including HttpOnly) for a given domain via chrome.cookies API
    - Captured session snapshots are encrypted using vault encryption before storage
    - Session snapshots are stored in chrome.storage.local with script+domain composite key
    - Background service worker handles CAPTURE_SESSION and GET_SESSION_STATUS message types
  artifacts:
    - path: "entrypoints/background/sessions.ts"
      provides: "SessionStorage module for cookie capture, encryption, and storage"
      min_lines: 150
      exports: ["captureSession", "getSessionStatus", "clearSession"]
    - path: "entrypoints/background/messaging.ts"
      provides: "Message handlers for session management"
      contains: "CAPTURE_SESSION"
  key_links:
    - from: "entrypoints/background/messaging.ts"
      to: "entrypoints/background/sessions.ts"
      via: "captureSession import and handler"
      pattern: "import.*captureSession.*from.*sessions"
    - from: "entrypoints/background/sessions.ts"
      to: "chrome.cookies"
      via: "chrome.cookies.getAll for HttpOnly capture"
      pattern: "chrome\\.cookies\\.getAll"
---

<objective>
Build the session capture infrastructure in the extension background service worker that captures cookies (including HttpOnly) via chrome.cookies API and stores encrypted session snapshots in chrome.storage.local.

Purpose: Provide the foundational module for session persistence that captures full cookie state (including metadata like SameSite, Secure, domain, path, expiry) and encrypts it using existing vault encryption before storage. This is the capture-side infrastructure that Phase 33 Plan 02 will wire into the script execution flow.

Output: Session capture module with background message handlers, enabling script execution to capture authenticated sessions for later restoration.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/phases/032-vault-unlock-cache/032-01-SUMMARY.md

# Extension architecture files
@entrypoints/background/index.ts
@entrypoints/background/messaging.ts
@entrypoints/background/storage.ts
@utils/passwords/storage.ts
@utils/crypto/encryption.ts
</context>

<tasks>

<task type="auto">
  <name>Create session storage module with cookie capture and encryption</name>
  <files>entrypoints/background/sessions.ts</files>
  <action>
Create the SessionStorage module in entrypoints/background/sessions.ts with the following:

**Type Definitions:**
- SessionSnapshot interface:
  - cookies: Array of cookie objects with ALL metadata (name, value, domain, path, secure, httpOnly, sameSite, expiresAt)
  - capturedAt: timestamp
  - ttl: milliseconds (default 3600000 = 1 hour)
- SessionSnapshotKey interface: { scriptId: string, domain: string }
- StoredSessionSnapshot interface: { encrypted: EncryptedData, capturedAt: number, ttl: number }

**Core Functions:**

1. **captureSession(scriptId: string, tabId: number): Promise<void>**
   - Get current tab URL via chrome.tabs.get(tabId)
   - Extract domain from URL (new URL(url).hostname)
   - Use chrome.cookies.getAll({ domain }) to capture ALL cookies (including HttpOnly)
   - Map each cookie to full metadata object (name, value, domain, path, secure, httpOnly, sameSite, expiresAt)
   - Create SessionSnapshot with cookies array, timestamp, default TTL
   - Serialize snapshot to JSON string
   - Get encryption key via getOrCreateSessionKey() from utils/crypto/encryption.ts
   - Encrypt JSON string via encryptApiKey(json, key) from utils/crypto/encryption.ts
   - Create StoredSessionSnapshot with encrypted data
   - Store in chrome.storage.local with key: `browserlet_session_${scriptId}_${domain}`
   - Handle errors gracefully with console.warn (non-fatal capture failures)

2. **getSessionStatus(scriptId: string, domain: string): Promise<{ exists: boolean, expired: boolean, capturedAt?: number }>**
   - Construct storage key from scriptId and domain
   - Read from chrome.storage.local
   - If not found: return { exists: false, expired: false }
   - If found: check TTL expiration (capturedAt + ttl < Date.now())
   - Return status object with exists, expired, capturedAt

3. **clearSession(scriptId: string, domain: string): Promise<void>**
   - Construct storage key from scriptId and domain
   - Remove from chrome.storage.local
   - Silent if key doesn't exist (idempotent)

**Implementation notes:**
- Use existing vault encryption infrastructure (getOrCreateSessionKey, encryptApiKey from utils/crypto/encryption.ts)
- Follow existing background module patterns from passwords.ts and triggers.ts
- Store under browserlet_session_ prefix for clear namespacing
- Capture ALL cookie metadata per SEXT-03 requirement (HttpOnly, SameSite, Secure, domain, path, expiry)
- Use chrome.cookies.getAll which has elevated extension privileges to capture HttpOnly cookies
- Map sameSite enum correctly (undefined â†’ "unspecified", "lax", "strict", "no_restriction")
- Convert expirationDate (optional Unix timestamp) to expiresAt field for consistency
  </action>
  <verify>
- TypeScript compiles without errors: `npx tsc --noEmit -p tsconfig.json`
- sessions.ts exports captureSession, getSessionStatus, clearSession functions
- grep -E "chrome\.cookies\.getAll" entrypoints/background/sessions.ts returns match
- grep -E "encryptApiKey" entrypoints/background/sessions.ts returns match
- grep -E "browserlet_session_" entrypoints/background/sessions.ts returns match
  </verify>
  <done>
SessionStorage module exists with all three exported functions, uses chrome.cookies API for privileged cookie access, encrypts snapshots with vault key, and stores in chrome.storage.local with proper namespacing.
  </done>
</task>

<task type="auto">
  <name>Add session management message handlers to background messaging</name>
  <files>entrypoints/background/messaging.ts, entrypoints/background/index.ts</files>
  <action>
Extend the background messaging infrastructure to handle session capture and status messages.

**In entrypoints/background/messaging.ts:**

1. Add new MessageType variants to the existing enum:
   - CAPTURE_SESSION
   - GET_SESSION_STATUS
   - CLEAR_SESSION

2. Import session functions:
   ```typescript
   import { captureSession, getSessionStatus, clearSession } from './sessions';
   ```

3. Add message handler cases in handleMessage switch statement:

   **CAPTURE_SESSION handler:**
   - Payload: { scriptId: string, tabId: number }
   - Call captureSession(scriptId, tabId)
   - On success: sendResponse({ success: true })
   - On error: sendResponse({ success: false, error: message })

   **GET_SESSION_STATUS handler:**
   - Payload: { scriptId: string, domain: string }
   - Call getSessionStatus(scriptId, domain)
   - Return status object: { success: true, data: statusObject }

   **CLEAR_SESSION handler:**
   - Payload: { scriptId: string, domain: string }
   - Call clearSession(scriptId, domain)
   - Return { success: true }

**In entrypoints/background/index.ts:**

4. Add import for session initialization:
   ```typescript
   import { cleanupExpiredSessions } from './sessions';
   ```

5. Add session cleanup in chrome.runtime.onInstalled listener after password infrastructure init:
   ```typescript
   // Cleanup expired session snapshots on startup
   cleanupExpiredSessions().catch(error => {
     console.error('[Browserlet] Failed to cleanup expired sessions:', error);
   });
   ```

6. Implement cleanupExpiredSessions() in sessions.ts:
   - Get all keys from chrome.storage.local
   - Filter keys starting with browserlet_session_
   - For each session key: check TTL expiration, delete if expired
   - Return count of deleted sessions

**Follow existing patterns:**
- Message handler structure matches existing PASSWORD_*, TRIGGER_*, LLM_* handlers
- Error handling with try/catch and appropriate error responses
- Async handlers with sendResponse callback
- Type safety with MessageType enum
  </action>
  <verify>
- TypeScript compiles without errors: `npx tsc --noEmit -p tsconfig.json`
- grep -E "CAPTURE_SESSION|GET_SESSION_STATUS|CLEAR_SESSION" entrypoints/background/messaging.ts returns all three message types
- grep -E "from.*sessions" entrypoints/background/messaging.ts confirms import
- grep -E "cleanupExpiredSessions" entrypoints/background/index.ts confirms cleanup integration
- grep -E "cleanupExpiredSessions.*export" entrypoints/background/sessions.ts confirms function exists
  </verify>
  <done>
Background service worker handles session management messages (CAPTURE_SESSION, GET_SESSION_STATUS, CLEAR_SESSION), routes them to SessionStorage module functions, and performs startup cleanup of expired session snapshots.
  </done>
</task>

</tasks>

<verification>
Run the following checks after all tasks complete:

1. TypeScript compilation:
   ```bash
   npx tsc --noEmit -p tsconfig.json
   ```
   Expected: Zero errors

2. File structure check:
   ```bash
   ls -lh entrypoints/background/sessions.ts
   ```
   Expected: File exists, size > 5KB (indicates complete implementation)

3. Export verification:
   ```bash
   grep -E "^export.*function (captureSession|getSessionStatus|clearSession)" entrypoints/background/sessions.ts
   ```
   Expected: Three export statements

4. Cookie API usage:
   ```bash
   grep -c "chrome.cookies.getAll" entrypoints/background/sessions.ts
   ```
   Expected: At least 1 match (captures HttpOnly cookies)

5. Encryption usage:
   ```bash
   grep -c "encryptApiKey" entrypoints/background/sessions.ts
   ```
   Expected: At least 1 match (encrypts session snapshots)

6. Message handler integration:
   ```bash
   grep -c "CAPTURE_SESSION\|GET_SESSION_STATUS\|CLEAR_SESSION" entrypoints/background/messaging.ts
   ```
   Expected: At least 6 matches (3 enum values + 3 case statements)

7. Storage namespace:
   ```bash
   grep -c "browserlet_session_" entrypoints/background/sessions.ts
   ```
   Expected: At least 3 matches (consistent key prefix)
</verification>

<success_criteria>
Phase 33 Plan 01 is complete when:

1. SessionStorage module exists with captureSession, getSessionStatus, clearSession functions
2. Chrome cookies API used to capture ALL cookies including HttpOnly per SEXT-01
3. Session snapshots include full cookie metadata (HttpOnly, SameSite, Secure, domain, path, expiry) per SEXT-03
4. Snapshots encrypted with vault key before storage per SEXT-04
5. Background service worker handles CAPTURE_SESSION, GET_SESSION_STATUS, CLEAR_SESSION messages
6. Startup cleanup removes expired session snapshots (TTL-based)
7. TypeScript compilation passes with zero errors
8. All must-haves artifacts exist and key links verified
</success_criteria>

<output>
After completion, create `.planning/phases/033-extension-session-persistence/033-01-SUMMARY.md` documenting:
- Session capture infrastructure built
- Cookie API integration for HttpOnly capture
- Encryption integration for secure storage
- Message handler routing
- Startup cleanup implementation
- Verification results
</output>
