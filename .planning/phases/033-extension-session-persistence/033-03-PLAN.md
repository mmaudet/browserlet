---
phase: 033-extension-session-persistence
plan: 03
type: execute
wave: 2
depends_on: [033-01, 033-02]
files_modified:
  - entrypoints/sidepanel/components/ScriptExecutor.tsx
  - entrypoints/sidepanel/components/ScriptList.tsx
  - utils/i18n/locales/en/messages.json
  - utils/i18n/locales/fr/messages.json
autonomous: false

must_haves:
  truths:
    - User can enable session persistence per script via UI toggle
    - After successful script execution, session is automatically captured
    - Before script execution with session enabled, session is restored if valid
    - User sees session status indicator (active/expired/none) in script UI
  artifacts:
    - path: "entrypoints/sidepanel/components/ScriptExecutor.tsx"
      provides: "Session restoration before playback, capture after success"
      contains: "restoreSession"
    - path: "entrypoints/sidepanel/components/ScriptList.tsx"
      provides: "Session toggle and status display per script"
      contains: "sessionPersistence"
    - path: "utils/i18n/locales/en/messages.json"
      provides: "English i18n for session UI"
      contains: "session_persistence"
  key_links:
    - from: "entrypoints/sidepanel/components/ScriptExecutor.tsx"
      to: "chrome.runtime.sendMessage"
      via: "RESTORE_SESSION and CAPTURE_SESSION messages"
      pattern: "RESTORE_SESSION|CAPTURE_SESSION"
    - from: "entrypoints/sidepanel/components/ScriptList.tsx"
      to: "chrome.runtime.sendMessage"
      via: "GET_SESSION_STATUS message"
      pattern: "GET_SESSION_STATUS"
---

<objective>
Wire session persistence into the script execution flow and script management UI, enabling users to enable session persistence per script, see session status, and automatically capture/restore sessions during execution.

Purpose: Deliver the end-user functionality that makes session persistence usable. This plan integrates the infrastructure from Plans 01-02 into the script execution lifecycle and adds UI controls for managing session persistence per script.

Output: Complete extension session persistence feature with UI controls, automatic capture/restore during execution, and session status indicators.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/033-extension-session-persistence/033-01-PLAN.md
@.planning/phases/033-extension-session-persistence/033-02-PLAN.md

# Extension UI and execution files
@entrypoints/sidepanel/components/ScriptExecutor.tsx
@entrypoints/sidepanel/components/ScriptList.tsx
@entrypoints/sidepanel/stores/scripts.ts
@utils/playback/PlaybackManager.ts
@utils/i18n/locales/en/messages.json
</context>

<tasks>

<task type="auto">
  <name>Integrate session restore and capture into script execution flow</name>
  <files>entrypoints/sidepanel/components/ScriptExecutor.tsx</files>
  <action>
Modify ScriptExecutor component to restore sessions before playback and capture after successful execution.

**In ScriptExecutor.tsx:**

1. Add session restoration before playback starts (before PlaybackManager.start):
   ```typescript
   // Check if script has session persistence enabled
   if (script.sessionPersistence?.enabled) {
     // Get current tab
     const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
     const currentTab = tabs[0];

     if (currentTab?.id && currentTab.url) {
       const domain = new URL(currentTab.url).hostname;

       // Try to restore session
       const response = await chrome.runtime.sendMessage({
         type: 'RESTORE_SESSION',
         payload: {
           scriptId: script.id,
           domain: domain,
           tabId: currentTab.id
         }
       });

       if (response.success && response.restored) {
         console.log('[ScriptExecutor] Session restored for', domain);
         // Add status message to execution output
         executionOutput.value += `Session restored for ${domain}\n`;
       }
     }
   }
   ```

2. Add session capture after successful execution (in success path after PlaybackManager completes):
   ```typescript
   // If execution succeeded and session persistence enabled
   if (result.success && script.sessionPersistence?.enabled) {
     const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
     const currentTab = tabs[0];

     if (currentTab?.id && currentTab.url) {
       const domain = new URL(currentTab.url).hostname;

       // Capture session for future use
       await chrome.runtime.sendMessage({
         type: 'CAPTURE_SESSION',
         payload: {
           scriptId: script.id,
           tabId: currentTab.id
         }
       }).catch(err => {
         console.warn('[ScriptExecutor] Failed to capture session:', err);
         // Non-fatal - don't fail execution
       });

       console.log('[ScriptExecutor] Session captured for', domain);
     }
   }
   ```

**Implementation notes:**
- Session restoration happens BEFORE PlaybackManager.start() call
- Session capture happens AFTER successful execution (result.success === true)
- Both operations are wrapped in try/catch to prevent execution failures
- Capture errors are non-fatal (logged but don't affect execution result)
- Domain extracted from current tab URL for session key
- Check script.sessionPersistence?.enabled before any session operations
  </action>
  <verify>
- TypeScript compiles without errors: `npx tsc --noEmit -p tsconfig.json`
- grep -c "RESTORE_SESSION" entrypoints/sidepanel/components/ScriptExecutor.tsx returns at least 1
- grep -c "CAPTURE_SESSION" entrypoints/sidepanel/components/ScriptExecutor.tsx returns at least 1
- grep -c "sessionPersistence?.enabled" entrypoints/sidepanel/components/ScriptExecutor.tsx returns at least 2
  </verify>
  <done>
ScriptExecutor restores sessions before playback if enabled, captures sessions after successful execution, and handles errors gracefully without breaking script execution.
  </done>
</task>

<task type="auto">
  <name>Add session persistence UI controls and status to script list</name>
  <files>entrypoints/sidepanel/components/ScriptList.tsx, entrypoints/sidepanel/stores/scripts.ts, utils/i18n/locales/en/messages.json, utils/i18n/locales/fr/messages.json</files>
  <action>
Add UI controls for enabling session persistence and displaying session status per script.

**In entrypoints/sidepanel/stores/scripts.ts:**

1. Update Script interface to include sessionPersistence:
   ```typescript
   interface Script {
     // ... existing fields ...
     sessionPersistence?: {
       enabled: boolean;
       ttl?: number;  // Optional TTL override (default 1 hour)
     };
   }
   ```

**In entrypoints/sidepanel/components/ScriptList.tsx:**

2. Add session status state per script (use signals):
   ```typescript
   const sessionStatus = signal<Map<string, { exists: boolean, expired: boolean, capturedAt?: number }>>(new Map());
   ```

3. Add function to fetch session status for script:
   ```typescript
   async function updateSessionStatus(scriptId: string) {
     const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
     if (!tabs[0]?.url) return;

     const domain = new URL(tabs[0].url).hostname;
     const response = await chrome.runtime.sendMessage({
       type: 'GET_SESSION_STATUS',
       payload: { scriptId, domain }
     });

     if (response.success) {
       sessionStatus.value.set(scriptId, response.data);
       sessionStatus.value = new Map(sessionStatus.value);  // Trigger reactivity
     }
   }
   ```

4. Add session toggle in script item rendering (after script name/description):
   ```tsx
   <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginTop: '4px' }}>
     <label style={{ fontSize: '12px', color: '#666' }}>
       <input
         type="checkbox"
         checked={script.sessionPersistence?.enabled || false}
         onChange={async (e) => {
           await updateScript(script.id, {
             ...script,
             sessionPersistence: {
               enabled: e.target.checked,
               ttl: script.sessionPersistence?.ttl
             }
           });
           if (e.target.checked) {
             updateSessionStatus(script.id);
           }
         }}
       />
       {' '}{t('session_persistence_enable')}
     </label>

     {script.sessionPersistence?.enabled && (
       <span style={{
         fontSize: '11px',
         padding: '2px 6px',
         borderRadius: '4px',
         backgroundColor: sessionStatus.value.get(script.id)?.exists
           ? (sessionStatus.value.get(script.id)?.expired ? '#ff9500' : '#4caf50')
           : '#ccc',
         color: 'white'
       }}>
         {sessionStatus.value.get(script.id)?.exists
           ? (sessionStatus.value.get(script.id)?.expired
             ? t('session_expired')
             : t('session_active'))
           : t('session_none')}
       </span>
     )}
   </div>
   ```

5. Call updateSessionStatus when script list loads (useEffect or similar):
   ```typescript
   useEffect(() => {
     scriptsState.val.forEach(script => {
       if (script.sessionPersistence?.enabled) {
         updateSessionStatus(script.id);
       }
     });
   }, [scriptsState.val]);
   ```

**In utils/i18n/locales/en/messages.json:**

6. Add English translations:
   ```json
   "session_persistence_enable": {
     "message": "Remember login (session persistence)"
   },
   "session_active": {
     "message": "Active"
   },
   "session_expired": {
     "message": "Expired"
   },
   "session_none": {
     "message": "None"
   }
   ```

**In utils/i18n/locales/fr/messages.json:**

7. Add French translations:
   ```json
   "session_persistence_enable": {
     "message": "Mémoriser la connexion (persistance de session)"
   },
   "session_active": {
     "message": "Active"
   },
   "session_expired": {
     "message": "Expirée"
   },
   "session_none": {
     "message": "Aucune"
   }
   ```

**Implementation notes:**
- Session toggle checkbox saved immediately to chrome.storage.local via updateScript
- Session status badge color-coded: green (active), orange (expired), gray (none)
- Status updates when toggle enabled or when script list loads
- Follow existing Preact patterns from ScriptList component
- Use chrome.i18n for translated strings
  </action>
  <verify>
- TypeScript compiles without errors: `npx tsc --noEmit -p tsconfig.json`
- grep -c "sessionPersistence" entrypoints/sidepanel/stores/scripts.ts returns at least 1
- grep -c "GET_SESSION_STATUS" entrypoints/sidepanel/components/ScriptList.tsx returns at least 1
- grep -c "session_persistence_enable" utils/i18n/locales/en/messages.json returns at least 1
- grep -c "session_persistence_enable" utils/i18n/locales/fr/messages.json returns at least 1
  </verify>
  <done>
Script list displays session persistence toggle per script, shows session status badge (active/expired/none), and updates status when toggle is enabled or on page load.
  </done>
</task>

<task type="checkpoint:human-verify">
  <name>Verify end-to-end session persistence functionality</name>
  <files></files>
  <action>
After implementing Tasks 1-2, verify the complete session persistence feature works end-to-end across all user workflows and edge cases.
  </action>
  <verify>
**Test Scenario 1: Enable session persistence and capture**
1. Open Chrome and navigate to https://quotes.toscrape.com/login
2. Open Browserlet side panel
3. Create a test script with login steps (type username, password, click submit)
4. Enable "Remember login (session persistence)" checkbox on the script
5. Run the script and verify successful login
6. Check that session status badge shows "Active" (green)
7. Close Chrome completely

**Test Scenario 2: Restore session on next execution**
1. Reopen Chrome and navigate to https://quotes.toscrape.com
2. Open Browserlet side panel
3. Run the SAME script (with session persistence enabled)
4. Expected: Script should NOT show login form (session restored)
5. Expected: Execution output should show "Session restored for quotes.toscrape.com"
6. Script should complete successfully without re-authentication

**Test Scenario 3: Session expiration**
1. Enable session persistence on a script
2. Run script to capture session
3. Wait 61+ minutes (or manually delete cache file from chrome.storage.local in DevTools)
4. Run script again
5. Expected: Session status badge shows "Expired" (orange)
6. Expected: Script execution prompts for login again

**Test Scenario 4: Disable session persistence**
1. Toggle OFF "Remember login" checkbox
2. Expected: Session status badge disappears
3. Run script
4. Expected: No session restoration (normal authentication flow)

**Test Scenario 5: Cross-browser validation**
1. Test same scenarios in Chrome and Firefox
2. Verify session capture/restore works in both browsers
3. Verify localStorage restoration works correctly

**DevTools verification:**
1. Open Chrome DevTools > Application > Storage > chrome.storage.local
2. Look for keys starting with `browserlet_session_`
3. Verify values are encrypted (should see ciphertext/iv, not plaintext cookies)
4. Verify HttpOnly cookies captured (check via DevTools > Application > Cookies)

**Console logs to check:**
- `[ScriptExecutor] Session restored for <domain>` (on restore)
- `[ScriptExecutor] Session captured for <domain>` (on capture)
- No errors related to chrome.cookies.set or localStorage access
  </verify>
  <done>
All 5 test scenarios pass successfully:
1. Session capture works after successful authentication
2. Session restore works on next execution (skips re-auth)
3. Session expiration is detected and handled
4. Disabling session persistence stops capture/restore
5. Cross-browser compatibility verified (Chrome and Firefox)

DevTools confirms encrypted storage (no plaintext cookies visible).
Console logs show expected session restoration and capture messages.
No errors in background service worker or content script.
  </done>
</task>

</tasks>

<verification>
Run the following checks after Task 1-2 complete:

1. TypeScript compilation:
   ```bash
   npx tsc --noEmit -p tsconfig.json
   ```
   Expected: Zero errors

2. Build verification:
   ```bash
   npm run build
   ```
   Expected: Build succeeds, extension bundle created

3. Integration points check:
   ```bash
   grep -c "RESTORE_SESSION\|CAPTURE_SESSION" entrypoints/sidepanel/components/ScriptExecutor.tsx
   ```
   Expected: At least 2 matches

4. UI integration check:
   ```bash
   grep -c "sessionPersistence" entrypoints/sidepanel/components/ScriptList.tsx
   ```
   Expected: At least 3 matches

5. I18n completeness:
   ```bash
   grep "session_" utils/i18n/locales/en/messages.json utils/i18n/locales/fr/messages.json | wc -l
   ```
   Expected: At least 8 lines (4 keys × 2 languages)

6. Storage integration:
   ```bash
   grep "sessionPersistence" entrypoints/sidepanel/stores/scripts.ts
   ```
   Expected: Interface field exists
</verification>

<success_criteria>
Phase 33 Plan 03 is complete when:

1. Script execution automatically restores sessions before playback if enabled
2. Script execution automatically captures sessions after successful execution
3. Script UI displays session persistence toggle per script
4. Script UI shows session status badge (active/expired/none) with color coding
5. Session status updates when toggle enabled or on page load
6. I18n support for session UI in both English and French
7. TypeScript compilation and build succeed
8. Manual verification passes all 5 test scenarios
9. All 4 phase success criteria from ROADMAP.md are satisfied:
   - [x] User runs script with authentication, closes browser
   - [x] User reopens browser, runs script, NOT prompted to log in
   - [x] Extension captures all cookie metadata during snapshot
   - [x] Session snapshot stored encrypted (not plaintext)
10. All must-haves artifacts exist and key links verified
</success_criteria>

<output>
After completion and human verification approval, create `.planning/phases/033-extension-session-persistence/033-03-SUMMARY.md` documenting:
- Script execution integration completed
- Script UI with session toggle and status
- I18n support added
- Verification test results (all 5 scenarios)
- Manual testing notes and observations
- Any issues found and resolutions
</output>
