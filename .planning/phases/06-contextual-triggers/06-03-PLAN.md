---
phase: 06-contextual-triggers
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - entrypoints/background/triggers/engine.ts
  - entrypoints/background/triggers/notifications.ts
  - entrypoints/background/triggers/index.ts
  - wxt.config.ts
autonomous: true

must_haves:
  truths:
    - "Trigger engine evaluates scripts against tab context"
    - "Suggest mode updates badge and stores suggested scripts"
    - "Auto-execute mode shows notification and triggers script execution"
    - "Per-site overrides are respected before triggering"
    - "Cooldown prevents notification spam for auto-execute"
  artifacts:
    - path: "entrypoints/background/triggers/engine.ts"
      provides: "Core trigger evaluation and action dispatch"
      exports: ["TriggerEngine", "handleContextMatch"]
    - path: "entrypoints/background/triggers/notifications.ts"
      provides: "Chrome notification creation and button handling"
      exports: ["notifyAutoExecution", "setupNotificationListeners"]
    - path: "entrypoints/background/triggers/index.ts"
      provides: "Module exports and initialization"
      exports: ["initializeTriggerEngine", "TriggerEngine"]
  key_links:
    - from: "entrypoints/background/triggers/engine.ts"
      to: "utils/storage/triggers.ts"
      via: "import getSiteOverride, getAllTriggers"
      pattern: "import.*from.*storage/triggers"
    - from: "entrypoints/background/triggers/notifications.ts"
      to: "chrome.notifications"
      via: "create and onButtonClicked"
      pattern: "chrome\\.notifications\\.(create|onButtonClicked)"
---

<objective>
Implement the background trigger engine for evaluating and acting on context matches.

Purpose: Coordinate trigger evaluation in the service worker, dispatching suggest or auto-execute actions based on matched triggers while respecting per-site overrides and cooldowns.

Output: Trigger engine, notification handling, and module initialization for background script.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-contextual-triggers/06-RESEARCH.md

# Prior plan context
@.planning/phases/06-contextual-triggers/06-01-SUMMARY.md

# Existing patterns
@entrypoints/background/messaging.ts
@entrypoints/background/storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add notifications permission to manifest</name>
  <files>wxt.config.ts</files>
  <action>
Add the "notifications" permission to enable chrome.notifications API:

In wxt.config.ts, update the permissions array in the manifest configuration:

```typescript
permissions: ['storage', 'sidePanel', 'tabs', 'activeTab', 'notifications'],
```

This enables chrome.notifications.create() for auto-execute mode notifications.
  </action>
  <verify>
Check wxt.config.ts contains 'notifications' in permissions array.
Run `npm run build` - should succeed without permission errors.
  </verify>
  <done>
Manifest includes notifications permission.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create notification utilities</name>
  <files>entrypoints/background/triggers/notifications.ts</files>
  <action>
Create notification utilities for auto-execute mode:

```typescript
/**
 * Chrome notification handling for auto-execute triggers
 * Creates system notifications with Stop/Disable buttons
 */

import { setSiteOverride } from '../../../utils/storage/triggers';

// Store active notifications to track script associations
const activeNotifications = new Map<string, { scriptId: string; tabId: number; url: string }>();

/**
 * Create notification for auto-executing script
 * @param scriptName - Script name to display
 * @param scriptId - Script ID for tracking
 * @param tabId - Tab where script is running
 * @param url - Tab URL for site override
 * @returns notification ID
 */
export async function notifyAutoExecution(
  scriptName: string,
  scriptId: string,
  tabId: number,
  url: string
): Promise<string> {
  const notificationId = `script_${scriptId}_${Date.now()}`;

  await chrome.notifications.create(notificationId, {
    type: 'basic',
    iconUrl: chrome.runtime.getURL('icon/128.png'),
    title: chrome.i18n.getMessage('notificationAutoExecuteTitle') || 'Script Auto-Executing',
    message: chrome.i18n.getMessage('notificationAutoExecuteMessage', [scriptName]) ||
             `Running: ${scriptName}`,
    buttons: [
      { title: chrome.i18n.getMessage('notificationStop') || 'Stop' },
      { title: chrome.i18n.getMessage('notificationDisableSite') || 'Disable for this site' }
    ],
    requireInteraction: false,
    priority: 0
  });

  // Track notification for button handling
  activeNotifications.set(notificationId, { scriptId, tabId, url });

  // Auto-clear notification after 10 seconds
  setTimeout(() => {
    chrome.notifications.clear(notificationId);
    activeNotifications.delete(notificationId);
  }, 10000);

  return notificationId;
}

/**
 * Create notification for script completion
 */
export async function notifyExecutionComplete(
  scriptName: string,
  success: boolean
): Promise<void> {
  const notificationId = `complete_${Date.now()}`;

  await chrome.notifications.create(notificationId, {
    type: 'basic',
    iconUrl: chrome.runtime.getURL('icon/128.png'),
    title: success
      ? (chrome.i18n.getMessage('notificationCompleteTitle') || 'Script Completed')
      : (chrome.i18n.getMessage('notificationFailedTitle') || 'Script Failed'),
    message: scriptName,
    requireInteraction: false,
    priority: 0
  });

  // Auto-clear after 5 seconds
  setTimeout(() => {
    chrome.notifications.clear(notificationId);
  }, 5000);
}

/**
 * Set up notification button click handlers
 * Must be called once during service worker initialization
 */
export function setupNotificationListeners(): void {
  chrome.notifications.onButtonClicked.addListener(
    async (notificationId: string, buttonIndex: number) => {
      const info = activeNotifications.get(notificationId);
      if (!info) return;

      if (buttonIndex === 0) {
        // Stop execution
        try {
          await chrome.tabs.sendMessage(info.tabId, { type: 'STOP_EXECUTION' });
        } catch {
          // Tab might be closed
        }
      } else if (buttonIndex === 1) {
        // Disable for this site
        await setSiteOverride(info.scriptId, info.url, false);
      }

      // Clear notification
      chrome.notifications.clear(notificationId);
      activeNotifications.delete(notificationId);
    }
  );

  // Clean up when notification is closed by user
  chrome.notifications.onClosed.addListener((notificationId: string) => {
    activeNotifications.delete(notificationId);
  });
}

/**
 * Clear all trigger-related notifications
 */
export function clearAllNotifications(): void {
  activeNotifications.forEach((_, notificationId) => {
    chrome.notifications.clear(notificationId);
  });
  activeNotifications.clear();
}
```

Key features per research:
- Stop button sends STOP_EXECUTION to content script
- Disable button sets site override to false
- Auto-clear after 10 seconds to avoid notification buildup
- Tracks notification -> script/tab mapping
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/background/triggers/notifications.ts` - should compile.
  </verify>
  <done>
Notification utilities exist with notifyAutoExecution, setupNotificationListeners, button handlers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create trigger engine</name>
  <files>entrypoints/background/triggers/engine.ts</files>
  <action>
Create the core trigger evaluation engine:

```typescript
/**
 * Trigger evaluation engine for the service worker
 * Coordinates context matching and action dispatch
 */

import type { TriggerConfig, ContextState } from '../../../utils/triggers/types';
import type { Script } from '../../../utils/types';
import { getAllTriggers, getSiteOverride } from '../../../utils/storage/triggers';
import { getScripts } from '../../../utils/storage/scripts';
import { notifyAutoExecution, notifyExecutionComplete } from './notifications';

// Storage key for suggested scripts per tab
const SUGGESTED_KEY_PREFIX = 'suggested_scripts_';

// Cooldown tracking: scriptId -> { domain -> lastExecutionTime }
const cooldowns = new Map<string, Map<string, number>>();

// Default cooldown: 5 minutes
const DEFAULT_COOLDOWN_MS = 5 * 60 * 1000;

/**
 * TriggerEngine coordinates trigger evaluation and action dispatch
 */
export class TriggerEngine {
  private triggers: TriggerConfig[] = [];
  private scripts: Map<string, Script> = new Map();
  private initialized: boolean = false;

  /**
   * Initialize the engine - load triggers and scripts
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    await this.refresh();
    this.initialized = true;

    // Listen for storage changes to refresh triggers
    chrome.storage.onChanged.addListener((changes, area) => {
      if (area === 'local') {
        if (changes.browserlet_triggers || changes.browserlet_scripts) {
          this.refresh();
        }
      }
    });
  }

  /**
   * Refresh triggers and scripts from storage
   */
  async refresh(): Promise<void> {
    this.triggers = await getAllTriggers();
    const scripts = await getScripts();
    this.scripts = new Map(scripts.map(s => [s.id, s]));
  }

  /**
   * Handle context match from content script
   * Called when content script detects matching context
   */
  async handleContextMatch(
    tabId: number,
    context: ContextState
  ): Promise<void> {
    if (!context.matches || !context.matchedTriggers) {
      // Context no longer matches - clear suggestions
      await this.clearSuggestions(tabId);
      return;
    }

    const tab = await chrome.tabs.get(tabId);
    if (!tab.url) return;

    // Group by mode
    const suggestTriggers: TriggerConfig[] = [];
    const autoExecuteTriggers: TriggerConfig[] = [];

    for (const trigger of context.matchedTriggers) {
      // Check site override
      const override = await getSiteOverride(trigger.scriptId, tab.url);
      if (override === false) {
        continue; // Disabled for this site
      }

      if (trigger.mode === 'suggest') {
        suggestTriggers.push(trigger);
      } else if (trigger.mode === 'auto_execute') {
        // Check cooldown
        if (!this.isOnCooldown(trigger, tab.url)) {
          autoExecuteTriggers.push(trigger);
        }
      }
    }

    // Handle suggest mode - update badge and store suggestions
    if (suggestTriggers.length > 0) {
      await this.handleSuggestMode(tabId, suggestTriggers);
    } else {
      await this.clearSuggestions(tabId);
    }

    // Handle auto-execute mode
    for (const trigger of autoExecuteTriggers) {
      await this.handleAutoExecute(tabId, trigger, tab.url);
    }
  }

  /**
   * Handle suggest mode - update badge and store
   */
  private async handleSuggestMode(
    tabId: number,
    triggers: TriggerConfig[]
  ): Promise<void> {
    const scriptIds = [...new Set(triggers.map(t => t.scriptId))];

    // Update badge
    await chrome.action.setBadgeText({
      text: String(scriptIds.length),
      tabId
    });
    await chrome.action.setBadgeBackgroundColor({
      color: '#4285f4', // Blue
      tabId
    });

    // Store suggested scripts for sidepanel
    await chrome.storage.session.set({
      [`${SUGGESTED_KEY_PREFIX}${tabId}`]: scriptIds
    });
  }

  /**
   * Clear suggestions for tab
   */
  private async clearSuggestions(tabId: number): Promise<void> {
    await chrome.action.setBadgeText({ text: '', tabId });
    await chrome.storage.session.remove(`${SUGGESTED_KEY_PREFIX}${tabId}`);
  }

  /**
   * Handle auto-execute mode
   */
  private async handleAutoExecute(
    tabId: number,
    trigger: TriggerConfig,
    url: string
  ): Promise<void> {
    const script = this.scripts.get(trigger.scriptId);
    if (!script || !script.content) {
      console.warn('[Browserlet] Script not found for auto-execute:', trigger.scriptId);
      return;
    }

    // Set cooldown
    this.setCooldown(trigger, url);

    // Show notification
    await notifyAutoExecution(script.name, script.id, tabId, url);

    // Execute script
    try {
      await chrome.tabs.sendMessage(tabId, {
        type: 'EXECUTE_SCRIPT',
        payload: { content: script.content }
      });
    } catch (error) {
      console.error('[Browserlet] Failed to send execute message:', error);
    }
  }

  /**
   * Check if trigger is on cooldown for domain
   */
  private isOnCooldown(trigger: TriggerConfig, url: string): boolean {
    const domain = new URL(url).hostname;
    const triggerCooldowns = cooldowns.get(trigger.id);
    if (!triggerCooldowns) return false;

    const lastExecution = triggerCooldowns.get(domain);
    if (!lastExecution) return false;

    const cooldownMs = trigger.cooldownMs ?? DEFAULT_COOLDOWN_MS;
    return Date.now() - lastExecution < cooldownMs;
  }

  /**
   * Set cooldown after execution
   */
  private setCooldown(trigger: TriggerConfig, url: string): void {
    const domain = new URL(url).hostname;

    if (!cooldowns.has(trigger.id)) {
      cooldowns.set(trigger.id, new Map());
    }

    cooldowns.get(trigger.id)!.set(domain, Date.now());
  }

  /**
   * Get suggested script IDs for a tab
   */
  async getSuggestedScripts(tabId: number): Promise<string[]> {
    const key = `${SUGGESTED_KEY_PREFIX}${tabId}`;
    const data = await chrome.storage.session.get(key);
    return (data[key] as string[] | undefined) ?? [];
  }

  /**
   * Get active triggers for a script
   */
  getTriggersForScript(scriptId: string): TriggerConfig[] {
    return this.triggers.filter(t => t.scriptId === scriptId && t.enabled);
  }
}

// Singleton instance
let engineInstance: TriggerEngine | null = null;

/**
 * Get or create the trigger engine singleton
 */
export function getTriggerEngine(): TriggerEngine {
  if (!engineInstance) {
    engineInstance = new TriggerEngine();
  }
  return engineInstance;
}

/**
 * Handle context match message from content script
 */
export async function handleContextMatch(
  tabId: number,
  context: ContextState
): Promise<void> {
  const engine = getTriggerEngine();
  await engine.handleContextMatch(tabId, context);
}
```

Key features:
- Singleton pattern matching existing service worker patterns
- Cooldown to prevent auto-execute spam (default 5 min)
- Site override check before any action
- Badge updates for suggest mode
- Session storage for suggested scripts per tab
- Storage change listener for hot reload
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/background/triggers/engine.ts` - should compile.
  </verify>
  <done>
TriggerEngine class exists with handleContextMatch, suggest/auto-execute handling, cooldown management.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npx tsc --noEmit` - Full project compiles
2. wxt.config.ts has "notifications" permission
3. Notification utilities create proper chrome.notifications
4. TriggerEngine handles both suggest and auto_execute modes
5. Cooldown prevents spam for auto-execute
</verification>

<success_criteria>
- [ ] wxt.config.ts includes 'notifications' permission
- [ ] entrypoints/background/triggers/notifications.ts exists with notification creation
- [ ] entrypoints/background/triggers/engine.ts exists with TriggerEngine class
- [ ] Engine respects site overrides before triggering
- [ ] Cooldown prevents auto-execute spam
- [ ] Project compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-contextual-triggers/06-03-SUMMARY.md`
</output>
