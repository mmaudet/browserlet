---
phase: 06-contextual-triggers
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - entrypoints/content/triggers/urlMatcher.ts
  - entrypoints/content/triggers/contextDetector.ts
  - entrypoints/content/triggers/observer.ts
autonomous: true

must_haves:
  truths:
    - "URL patterns are converted to regex and matched against current URL"
    - "Element presence is checked using existing semantic resolver"
    - "MutationObserver monitors DOM changes with debouncing for performance"
    - "Page Visibility API pauses observers when tab is hidden"
  artifacts:
    - path: "entrypoints/content/triggers/urlMatcher.ts"
      provides: "URL pattern matching utilities"
      exports: ["urlPatternToRegex", "matchesUrlPattern", "matchesAnyUrlPattern"]
    - path: "entrypoints/content/triggers/contextDetector.ts"
      provides: "Context detection class combining URL and element checks"
      exports: ["ContextDetector"]
    - path: "entrypoints/content/triggers/observer.ts"
      provides: "Debounced MutationObserver for trigger monitoring"
      exports: ["createDebouncedObserver", "TriggerObserver"]
  key_links:
    - from: "entrypoints/content/triggers/contextDetector.ts"
      to: "entrypoints/content/playback/semanticResolver.ts"
      via: "import resolveElement"
      pattern: "import.*resolveElement.*from.*semanticResolver"
    - from: "entrypoints/content/triggers/urlMatcher.ts"
      to: "entrypoints/content/playback/sessionDetector.ts"
      via: "reuse pattern from existing code"
      pattern: "urlPatternToRegex"
---

<objective>
Implement content script context detection for URL patterns and element presence.

Purpose: Enable continuous monitoring of page context to detect when trigger conditions are met, reusing existing semantic resolver and sessionDetector patterns for robustness.

Output: URL matcher, element-based context detector, and optimized MutationObserver for triggers.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-contextual-triggers/06-RESEARCH.md

# Prior plan context
@.planning/phases/06-contextual-triggers/06-01-SUMMARY.md

# Existing patterns to reuse
@entrypoints/content/playback/sessionDetector.ts
@entrypoints/content/playback/semanticResolver.ts
@utils/hints/dom.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URL pattern matcher</name>
  <files>entrypoints/content/triggers/urlMatcher.ts</files>
  <action>
Create URL pattern matching utilities, extracting and extending the pattern from sessionDetector.ts:

```typescript
/**
 * URL pattern matching for contextual triggers
 * Reuses the proven pattern from sessionDetector.ts
 */

/**
 * Convert wildcard URL pattern to regex
 * Handles: * -> .*, escapes special regex chars
 * @example "*/login*" -> /.*\/login.*/i
 */
export function urlPatternToRegex(pattern: string): RegExp {
  // Escape special regex chars except *, then replace * with .*
  const regexPattern = pattern
    .replace(/[.+^${}()|[\]\\]/g, '\\$&')
    .replace(/\*/g, '.*');
  return new RegExp(regexPattern, 'i'); // Case insensitive
}

/**
 * Check if URL matches a single pattern
 * @param url - Full URL to check
 * @param pattern - Wildcard pattern like "*/dashboard*"
 * @returns true if URL matches pattern
 */
export function matchesUrlPattern(url: string, pattern: string): boolean {
  try {
    const regex = urlPatternToRegex(pattern);
    return regex.test(url);
  } catch {
    console.warn('[Browserlet] Invalid URL pattern:', pattern);
    return false;
  }
}

/**
 * Check if URL matches any pattern in the list
 * @param url - Full URL to check
 * @param patterns - Array of wildcard patterns
 * @returns true if URL matches at least one pattern
 */
export function matchesAnyUrlPattern(url: string, patterns: string[]): boolean {
  if (!patterns || patterns.length === 0) {
    return true; // No patterns = matches all
  }
  return patterns.some(pattern => matchesUrlPattern(url, pattern));
}

/**
 * Extract domain from URL for site override lookups
 * @param url - Full URL
 * @returns hostname (e.g., "example.com")
 */
export function extractDomain(url: string): string {
  try {
    return new URL(url).hostname;
  } catch {
    return '';
  }
}
```

This is the same pattern already proven in sessionDetector.ts (lines 36-42) but extracted for reuse.
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/triggers/urlMatcher.ts` - should compile.
Test patterns: "*login*" matches "https://app.com/login", "*dashboard*" matches "https://app.com/dashboard/main"
  </verify>
  <done>
URL matcher exists with urlPatternToRegex, matchesUrlPattern, matchesAnyUrlPattern functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create debounced trigger observer</name>
  <files>entrypoints/content/triggers/observer.ts</files>
  <action>
Create an optimized MutationObserver wrapper for trigger monitoring:

```typescript
/**
 * Debounced MutationObserver for trigger condition monitoring
 * Optimized for performance with Page Visibility API integration
 */

export type ObserverCallback = () => void;

/**
 * Create a debounced MutationObserver
 * @param callback - Function to call after debounce period
 * @param delay - Debounce delay in milliseconds (default 500ms from research)
 * @returns MutationObserver instance
 */
export function createDebouncedObserver(
  callback: ObserverCallback,
  delay: number = 500
): MutationObserver {
  let timerId: number | null = null;

  const debouncedCallback = () => {
    if (timerId) {
      clearTimeout(timerId);
    }
    timerId = window.setTimeout(() => {
      callback();
      timerId = null;
    }, delay);
  };

  return new MutationObserver(debouncedCallback);
}

/**
 * TriggerObserver class with lifecycle management
 * Automatically pauses when tab is hidden for performance
 */
export class TriggerObserver {
  private observer: MutationObserver | null = null;
  private callback: ObserverCallback;
  private debounceMs: number;
  private isPaused: boolean = false;
  private visibilityHandler: (() => void) | null = null;

  constructor(callback: ObserverCallback, debounceMs: number = 500) {
    this.callback = callback;
    this.debounceMs = debounceMs;
  }

  /**
   * Start observing DOM changes
   * Automatically integrates with Page Visibility API
   */
  start(): void {
    if (this.observer) return; // Already observing

    this.observer = createDebouncedObserver(this.callback, this.debounceMs);

    // Only observe if page is visible
    if (!document.hidden) {
      this.observe();
    }

    // Set up visibility change listener
    this.visibilityHandler = () => {
      if (document.hidden) {
        this.pause();
      } else {
        this.resume();
      }
    };
    document.addEventListener('visibilitychange', this.visibilityHandler);

    // Initial check
    this.callback();
  }

  /**
   * Stop observing and clean up
   */
  stop(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
    }

    if (this.visibilityHandler) {
      document.removeEventListener('visibilitychange', this.visibilityHandler);
      this.visibilityHandler = null;
    }

    this.isPaused = false;
  }

  /**
   * Pause observation (called when tab hidden)
   */
  private pause(): void {
    if (this.observer && !this.isPaused) {
      this.observer.disconnect();
      this.isPaused = true;
    }
  }

  /**
   * Resume observation (called when tab visible)
   */
  private resume(): void {
    if (this.observer && this.isPaused) {
      this.observe();
      this.isPaused = false;
      // Re-check after resume
      this.callback();
    }
  }

  /**
   * Internal: connect observer to DOM
   */
  private observe(): void {
    if (!this.observer) return;

    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      // Only observe attributes that affect visibility/presence
      attributeFilter: ['class', 'style', 'hidden', 'aria-hidden', 'disabled']
    });
  }
}
```

Key features per research:
- 500ms debounce to avoid excessive checks
- Filtered attributes to reduce callback frequency
- Page Visibility API to pause when tab hidden
- Clean lifecycle management with start/stop
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/triggers/observer.ts` - should compile.
  </verify>
  <done>
Observer utilities exist with createDebouncedObserver function and TriggerObserver class with visibility integration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create context detector</name>
  <files>entrypoints/content/triggers/contextDetector.ts</files>
  <action>
Create the main context detection class combining URL and element checks:

```typescript
/**
 * Context detector for trigger condition evaluation
 * Combines URL pattern matching with element presence detection
 */

import type { TriggerCondition, TriggerConfig, ContextState } from '../../../utils/triggers/types';
import { resolveElement } from '../playback/semanticResolver';
import { isElementVisible } from '../../../utils/hints/dom';
import { matchesUrlPattern } from './urlMatcher';
import { TriggerObserver } from './observer';

export type ContextChangeCallback = (state: ContextState) => void;

/**
 * ContextDetector monitors page state for trigger conditions
 * Notifies listeners when context matches or stops matching
 */
export class ContextDetector {
  private triggers: TriggerConfig[] = [];
  private observer: TriggerObserver | null = null;
  private listeners: Set<ContextChangeCallback> = new Set();
  private lastState: ContextState | null = null;
  private isMonitoring: boolean = false;

  constructor(triggers: TriggerConfig[] = []) {
    this.triggers = triggers;
  }

  /**
   * Update the triggers to monitor
   */
  setTriggers(triggers: TriggerConfig[]): void {
    this.triggers = triggers.filter(t => t.enabled);

    // Re-evaluate if already monitoring
    if (this.isMonitoring) {
      this.evaluateContext();
    }
  }

  /**
   * Start monitoring page context
   */
  startMonitoring(): void {
    if (this.isMonitoring) return;
    this.isMonitoring = true;

    // Create observer for element-based conditions
    const hasElementConditions = this.triggers.some(t =>
      t.conditions.some(c => c.element_present || c.element_absent)
    );

    if (hasElementConditions) {
      this.observer = new TriggerObserver(() => this.evaluateContext());
      this.observer.start();
    } else {
      // URL-only triggers - just evaluate once
      this.evaluateContext();
    }
  }

  /**
   * Stop monitoring
   */
  stopMonitoring(): void {
    if (!this.isMonitoring) return;
    this.isMonitoring = false;

    if (this.observer) {
      this.observer.stop();
      this.observer = null;
    }
  }

  /**
   * Register context change callback
   */
  onContextChange(callback: ContextChangeCallback): void {
    this.listeners.add(callback);
  }

  /**
   * Remove context change callback
   */
  offContextChange(callback: ContextChangeCallback): void {
    this.listeners.delete(callback);
  }

  /**
   * Evaluate all trigger conditions against current context
   */
  private evaluateContext(): void {
    const currentUrl = window.location.href;
    const matchedTriggers: TriggerConfig[] = [];

    for (const trigger of this.triggers) {
      if (this.checkTrigger(trigger, currentUrl)) {
        matchedTriggers.push(trigger);
      }
    }

    const matches = matchedTriggers.length > 0;
    const state: ContextState = {
      matches,
      reason: matches ? 'conditions_met' : 'no_match',
      matchedTriggers: matches ? matchedTriggers : undefined,
      url: currentUrl
    };

    // Only notify if state changed
    if (!this.statesEqual(state, this.lastState)) {
      this.lastState = state;
      this.notifyListeners(state);
    }
  }

  /**
   * Check if a single trigger's conditions are met
   */
  private checkTrigger(trigger: TriggerConfig, currentUrl: string): boolean {
    // All conditions must match (AND logic)
    return trigger.conditions.every(condition =>
      this.checkCondition(condition, currentUrl)
    );
  }

  /**
   * Check a single condition
   */
  private checkCondition(condition: TriggerCondition, currentUrl: string): boolean {
    // Check URL pattern (if specified)
    if (condition.url_pattern) {
      if (!matchesUrlPattern(currentUrl, condition.url_pattern)) {
        return false;
      }
    }

    // Check element presence (if specified)
    if (condition.element_present) {
      const result = resolveElement(condition.element_present.hints);
      if (!result.element || !isElementVisible(result.element)) {
        return false;
      }
    }

    // Check element absence (if specified)
    if (condition.element_absent) {
      const result = resolveElement(condition.element_absent.hints);
      if (result.element && isElementVisible(result.element)) {
        return false; // Element found but should be absent
      }
    }

    return true; // All specified conditions met
  }

  /**
   * Compare two context states for equality
   */
  private statesEqual(a: ContextState, b: ContextState | null): boolean {
    if (!b) return false;
    if (a.matches !== b.matches) return false;
    if (a.url !== b.url) return false;

    // Compare matched triggers by ID
    const aIds = a.matchedTriggers?.map(t => t.id).sort() ?? [];
    const bIds = b.matchedTriggers?.map(t => t.id).sort() ?? [];
    return aIds.join(',') === bIds.join(',');
  }

  /**
   * Notify all listeners of context change
   */
  private notifyListeners(state: ContextState): void {
    this.listeners.forEach(callback => {
      try {
        callback(state);
      } catch (error) {
        console.error('[Browserlet] Context listener error:', error);
      }
    });
  }

  /**
   * Force re-evaluation (useful after trigger update)
   */
  forceEvaluate(): void {
    this.lastState = null; // Reset to force notification
    this.evaluateContext();
  }

  /**
   * Get current context state without triggering callbacks
   */
  getCurrentState(): ContextState | null {
    return this.lastState;
  }
}
```

Key features:
- Reuses existing semanticResolver for element detection
- Reuses isElementVisible from existing utils
- AND logic for multiple conditions per trigger
- State change detection to avoid redundant callbacks
- Clean separation between URL-only and element-based triggers
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/triggers/contextDetector.ts` - should compile without errors.
  </verify>
  <done>
ContextDetector class exists with setTriggers, startMonitoring, stopMonitoring, onContextChange methods.
Uses existing semanticResolver and isElementVisible. Debounced observation with visibility pausing.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npx tsc --noEmit` - Full project compiles without errors
2. URL matcher correctly converts wildcards to regex
3. TriggerObserver properly pauses on visibility change
4. ContextDetector integrates URL and element checks
5. Existing semanticResolver and isElementVisible are imported and used
</verification>

<success_criteria>
- [ ] entrypoints/content/triggers/urlMatcher.ts exists with pattern matching functions
- [ ] entrypoints/content/triggers/observer.ts exists with TriggerObserver class
- [ ] entrypoints/content/triggers/contextDetector.ts exists with ContextDetector class
- [ ] ContextDetector uses existing semanticResolver for element detection
- [ ] Observer pauses when tab is hidden via Page Visibility API
- [ ] Project compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-contextual-triggers/06-02-SUMMARY.md`
</output>
