---
phase: 06-contextual-triggers
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - entrypoints/content/triggers/index.ts
  - entrypoints/content/index.ts
  - entrypoints/background/triggers/index.ts
  - entrypoints/background/index.ts
  - entrypoints/background/messaging.ts
autonomous: true

must_haves:
  truths:
    - "Content script initializes ContextDetector and sends CONTEXT_MATCH messages"
    - "Background receives CONTEXT_MATCH and delegates to TriggerEngine"
    - "Triggers are loaded from storage on content script initialization"
    - "Context changes trigger real-time evaluation"
  artifacts:
    - path: "entrypoints/content/triggers/index.ts"
      provides: "Content script trigger module with initialization"
      exports: ["initializeTriggers", "updateTriggers"]
    - path: "entrypoints/background/triggers/index.ts"
      provides: "Background trigger module exports and initialization"
      exports: ["initializeTriggerEngine", "TriggerEngine"]
  key_links:
    - from: "entrypoints/content/index.ts"
      to: "entrypoints/content/triggers/index.ts"
      via: "import and initialize"
      pattern: "import.*initializeTriggers.*from.*triggers"
    - from: "entrypoints/background/messaging.ts"
      to: "entrypoints/background/triggers/engine.ts"
      via: "CONTEXT_MATCH handler"
      pattern: "case 'CONTEXT_MATCH'"
---

<objective>
Wire the trigger system: connect content script context detection to background engine.

Purpose: Complete the message flow from content script context changes to background trigger evaluation and action dispatch.

Output: Trigger initialization in content/background, message handlers for CONTEXT_MATCH.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-contextual-triggers/06-RESEARCH.md

# Prior plan summaries
@.planning/phases/06-contextual-triggers/06-01-SUMMARY.md
@.planning/phases/06-contextual-triggers/06-02-SUMMARY.md
@.planning/phases/06-contextual-triggers/06-03-SUMMARY.md

# Existing wiring patterns
@entrypoints/content/index.ts
@entrypoints/background/index.ts
@entrypoints/background/messaging.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create content script trigger module</name>
  <files>entrypoints/content/triggers/index.ts</files>
  <action>
Create the content script trigger initialization module:

```typescript
/**
 * Content script trigger initialization
 * Sets up ContextDetector and message communication with background
 */

import type { TriggerConfig, ContextState } from '../../../utils/triggers/types';
import { ContextDetector } from './contextDetector';

let detector: ContextDetector | null = null;
let isInitialized = false;

/**
 * Initialize trigger system in content script
 * Requests triggers from background and starts monitoring
 */
export async function initializeTriggers(): Promise<void> {
  if (isInitialized) return;
  isInitialized = true;

  // Create detector
  detector = new ContextDetector();

  // Set up context change handler - send to background
  detector.onContextChange(async (state: ContextState) => {
    try {
      await chrome.runtime.sendMessage({
        type: 'CONTEXT_MATCH',
        payload: state
      });
    } catch (error) {
      // Background might not be ready, ignore
    }
  });

  // Request triggers from background
  try {
    const response = await chrome.runtime.sendMessage({
      type: 'GET_TRIGGERS'
    });

    if (response.success && response.data) {
      const triggers = response.data as TriggerConfig[];
      detector.setTriggers(triggers);
      detector.startMonitoring();
      console.log('[Browserlet] Trigger monitoring started with', triggers.length, 'triggers');
    }
  } catch (error) {
    console.warn('[Browserlet] Failed to load triggers:', error);
  }
}

/**
 * Update triggers (called when triggers change)
 */
export function updateTriggers(triggers: TriggerConfig[]): void {
  if (detector) {
    detector.setTriggers(triggers);
    detector.forceEvaluate();
  }
}

/**
 * Stop trigger monitoring (for cleanup)
 */
export function stopTriggers(): void {
  if (detector) {
    detector.stopMonitoring();
    detector = null;
  }
  isInitialized = false;
}

/**
 * Handle messages from background about trigger updates
 */
export function handleTriggerMessage(message: { type: string; payload?: unknown }): void {
  switch (message.type) {
    case 'TRIGGERS_UPDATED': {
      const triggers = message.payload as TriggerConfig[];
      updateTriggers(triggers);
      break;
    }
    case 'STOP_TRIGGERS':
      stopTriggers();
      break;
  }
}
```

Key design:
- Lazy initialization to avoid startup overhead
- Requests triggers from background (single source of truth)
- Sends CONTEXT_MATCH messages on state change
- Handles TRIGGERS_UPDATED for hot reload
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/triggers/index.ts` - should compile.
  </verify>
  <done>
Content trigger module exists with initializeTriggers, updateTriggers, handleTriggerMessage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create background trigger module and update messaging</name>
  <files>
    entrypoints/background/triggers/index.ts
    entrypoints/background/messaging.ts
  </files>
  <action>
First, create the background trigger module index:

```typescript
// entrypoints/background/triggers/index.ts
/**
 * Background trigger module exports and initialization
 */

import { getTriggerEngine, TriggerEngine } from './engine';
import { setupNotificationListeners } from './notifications';

export { TriggerEngine, getTriggerEngine };

let initialized = false;

/**
 * Initialize the trigger engine in service worker
 * Must be called once during service worker startup
 */
export async function initializeTriggerEngine(): Promise<void> {
  if (initialized) return;
  initialized = true;

  // Set up notification button handlers
  setupNotificationListeners();

  // Initialize engine (loads triggers from storage)
  const engine = getTriggerEngine();
  await engine.initialize();

  console.log('[Browserlet] Trigger engine initialized');
}

/**
 * Broadcast trigger updates to all content scripts
 */
export async function broadcastTriggerUpdate(): Promise<void> {
  const engine = getTriggerEngine();
  await engine.refresh();

  // Get all enabled triggers
  const triggers = (await import('../../../utils/storage/triggers')).getAllTriggers();

  // Broadcast to all tabs
  const tabs = await chrome.tabs.query({});
  for (const tab of tabs) {
    if (tab.id) {
      try {
        await chrome.tabs.sendMessage(tab.id, {
          type: 'TRIGGERS_UPDATED',
          payload: await triggers
        });
      } catch {
        // Tab might not have content script
      }
    }
  }
}
```

Then update messaging.ts to add new message handlers. Add these cases to the switch statement in processMessage:

```typescript
// Add these imports at top of messaging.ts
import { getTriggerEngine, initializeTriggerEngine, broadcastTriggerUpdate } from './triggers';
import type { ContextState } from '../../utils/triggers/types';
import { getAllTriggers, saveTrigger, deleteTrigger, setSiteOverride } from '../../utils/storage/triggers';

// Add these cases in the switch statement:

case 'CONTEXT_MATCH': {
  const context = message.payload as ContextState;
  const tabId = _sender.tab?.id;
  if (tabId) {
    await getTriggerEngine().handleContextMatch(tabId, context);
  }
  return { success: true };
}

case 'GET_TRIGGERS': {
  const triggers = await getAllTriggers();
  return { success: true, data: triggers };
}

case 'SAVE_TRIGGER': {
  const trigger = message.payload as TriggerConfig;
  await saveTrigger(trigger);
  await broadcastTriggerUpdate();
  return { success: true };
}

case 'DELETE_TRIGGER': {
  const triggerId = message.payload as string;
  await deleteTrigger(triggerId);
  await broadcastTriggerUpdate();
  return { success: true };
}

case 'GET_SUGGESTED_SCRIPTS': {
  const tabId = _sender.tab?.id;
  if (tabId) {
    const scriptIds = await getTriggerEngine().getSuggestedScripts(tabId);
    return { success: true, data: scriptIds };
  }
  return { success: true, data: [] };
}

case 'SET_SITE_OVERRIDE': {
  const { scriptId, url, enabled } = message.payload as {
    scriptId: string;
    url: string;
    enabled: boolean;
  };
  await setSiteOverride(scriptId, url, enabled);
  return { success: true };
}
```

Also add the import for TriggerConfig type.
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/background/triggers/index.ts entrypoints/background/messaging.ts` - should compile.
  </verify>
  <done>
Background trigger module exists with initializeTriggerEngine.
Messaging handles CONTEXT_MATCH, GET_TRIGGERS, SAVE_TRIGGER, DELETE_TRIGGER, GET_SUGGESTED_SCRIPTS, SET_SITE_OVERRIDE.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire triggers into entry points</name>
  <files>
    entrypoints/content/index.ts
    entrypoints/background/index.ts
  </files>
  <action>
Update content/index.ts to initialize triggers. Add after the recording manager setup:

```typescript
// Add import at top
import { initializeTriggers, handleTriggerMessage } from './triggers';

// In main(), after verifyConnection() call:
// Initialize trigger monitoring (async, don't block)
initializeTriggers().catch(error => {
  console.warn('[Browserlet] Trigger initialization failed:', error);
});

// In handleServiceWorkerMessage switch, add cases for trigger messages:
case 'TRIGGERS_UPDATED':
  handleTriggerMessage(message);
  return { success: true };

case 'STOP_TRIGGERS':
  handleTriggerMessage(message);
  return { success: true };
```

Update background/index.ts to initialize trigger engine:

```typescript
// Add import at top
import { initializeTriggerEngine } from './triggers';

// After existing initialization code (e.g., after handleMessage listener setup):
// Initialize trigger engine
initializeTriggerEngine().catch(error => {
  console.error('[Browserlet] Failed to initialize trigger engine:', error);
});
```

The trigger system should now be fully wired:
1. Content script initializes ContextDetector on load
2. ContextDetector monitors page and sends CONTEXT_MATCH
3. Background TriggerEngine evaluates and dispatches actions
4. Trigger updates are broadcast to all content scripts
  </action>
  <verify>
Run `npm run build` - should build without errors.
Check that content script and background both import trigger modules.
  </verify>
  <done>
Content script initializes triggers after recording manager.
Background script initializes trigger engine.
Message flow: content CONTEXT_MATCH -> background engine -> actions.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npm run build` - Full project builds
2. Content script imports and calls initializeTriggers
3. Background script imports and calls initializeTriggerEngine
4. CONTEXT_MATCH messages are routed to trigger engine
5. Trigger CRUD messages are handled (GET_TRIGGERS, SAVE_TRIGGER, DELETE_TRIGGER)
</verification>

<success_criteria>
- [ ] entrypoints/content/triggers/index.ts exists with initializeTriggers
- [ ] entrypoints/background/triggers/index.ts exists with initializeTriggerEngine
- [ ] Content script calls initializeTriggers in main()
- [ ] Background script calls initializeTriggerEngine on startup
- [ ] Messaging handles CONTEXT_MATCH, GET_TRIGGERS, SAVE_TRIGGER, DELETE_TRIGGER
- [ ] Project builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-contextual-triggers/06-04-SUMMARY.md`
</output>
