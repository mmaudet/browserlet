---
phase: 06-contextual-triggers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - utils/triggers/types.ts
  - utils/storage/triggers.ts
  - entrypoints/sidepanel/stores/triggers.ts
autonomous: true

must_haves:
  truths:
    - "Trigger configuration type defines URL patterns, element conditions, and mode (suggest/auto_execute)"
    - "Scripts can have triggers attached via storage API"
    - "Per-site overrides stored with domain-keyed pattern"
    - "Trigger state is reactive in sidepanel via VanJS store"
  artifacts:
    - path: "utils/triggers/types.ts"
      provides: "TriggerCondition, TriggerConfig, SiteOverride types"
      exports: ["TriggerCondition", "TriggerConfig", "TriggerMode", "SiteOverride", "ContextState"]
    - path: "utils/storage/triggers.ts"
      provides: "CRUD operations for trigger configs and site overrides"
      exports: ["saveTrigger", "getTriggers", "deleteTrigger", "getSiteOverride", "setSiteOverride"]
    - path: "entrypoints/sidepanel/stores/triggers.ts"
      provides: "VanJS reactive store for trigger state in sidepanel"
      exports: ["triggersState", "suggestedScriptsState", "loadTriggers"]
  key_links:
    - from: "utils/storage/triggers.ts"
      to: "chrome.storage.local"
      via: "get/set operations"
      pattern: "chrome\\.storage\\.local\\.(get|set)"
    - from: "entrypoints/sidepanel/stores/triggers.ts"
      to: "utils/storage/triggers.ts"
      via: "import and call"
      pattern: "import.*from.*storage/triggers"
---

<objective>
Define trigger types and implement storage layer for trigger configurations.

Purpose: Establish the data model and persistence for contextual triggers, enabling scripts to have URL and element-based trigger conditions with suggest or auto-execute modes.

Output: Type definitions, storage utilities, and reactive store for trigger management.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-contextual-triggers/06-RESEARCH.md

# Existing patterns to follow
@utils/storage/scripts.ts
@entrypoints/sidepanel/stores/scripts.ts
@entrypoints/content/playback/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create trigger type definitions</name>
  <files>utils/triggers/types.ts</files>
  <action>
Create the trigger types file with the following types:

```typescript
import type { SemanticHint } from '../../entrypoints/content/playback/types';

// Trigger mode: suggest shows in sidepanel, auto_execute runs immediately
export type TriggerMode = 'suggest' | 'auto_execute';

// Condition for element presence detection
export interface ElementCondition {
  hints: SemanticHint[];  // Reuse existing SemanticHint type
  required: boolean;      // All required conditions must match
}

// Trigger condition combining URL and element checks
export interface TriggerCondition {
  url_pattern?: string;           // Wildcard pattern like "*/login*"
  element_present?: ElementCondition;  // Element must be visible
  element_absent?: ElementCondition;   // Element must NOT be visible
}

// Full trigger configuration attached to a script
export interface TriggerConfig {
  id: string;                     // crypto.randomUUID()
  scriptId: string;               // Reference to parent script
  name: string;                   // User-friendly name
  conditions: TriggerCondition[]; // All conditions must match (AND logic)
  mode: TriggerMode;              // suggest or auto_execute
  enabled: boolean;               // Global enable/disable
  cooldownMs?: number;            // Prevent spam for auto_execute (default 300000 = 5 min)
  createdAt: number;              // timestamp
  updatedAt: number;              // timestamp
}

// Per-site override for trigger enable/disable
export interface SiteOverride {
  domain: string;
  enabled: boolean;
  timestamp: number;
}

// Context state result from detection
export interface ContextState {
  matches: boolean;
  reason: string;
  matchedTriggers?: TriggerConfig[];
  url?: string;
  tabId?: number;
}
```

Follow the existing pattern in `entrypoints/content/playback/types.ts` for imports and exports.
  </action>
  <verify>
Run `npx tsc --noEmit utils/triggers/types.ts` - should compile without errors.
  </verify>
  <done>
Type definitions exist, import SemanticHint from existing types, all types exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement trigger storage utilities</name>
  <files>utils/storage/triggers.ts</files>
  <action>
Create storage utilities for triggers following the pattern in `utils/storage/scripts.ts`:

```typescript
import type { TriggerConfig, SiteOverride } from '../triggers/types';

const TRIGGERS_KEY = 'browserlet_triggers';
const OVERRIDE_PREFIX = 'trigger_override_';

// Get all triggers for a script
export async function getTriggers(scriptId: string): Promise<TriggerConfig[]> {
  const data = await chrome.storage.local.get(TRIGGERS_KEY);
  const all = (data[TRIGGERS_KEY] as TriggerConfig[] | undefined) ?? [];
  return all.filter(t => t.scriptId === scriptId);
}

// Get all triggers (for engine)
export async function getAllTriggers(): Promise<TriggerConfig[]> {
  const data = await chrome.storage.local.get(TRIGGERS_KEY);
  return (data[TRIGGERS_KEY] as TriggerConfig[] | undefined) ?? [];
}

// Save trigger (create or update)
export async function saveTrigger(trigger: TriggerConfig): Promise<void> {
  const data = await chrome.storage.local.get(TRIGGERS_KEY);
  const triggers = (data[TRIGGERS_KEY] as TriggerConfig[] | undefined) ?? [];

  const index = triggers.findIndex(t => t.id === trigger.id);
  if (index >= 0) {
    triggers[index] = { ...trigger, updatedAt: Date.now() };
  } else {
    triggers.push({ ...trigger, createdAt: Date.now(), updatedAt: Date.now() });
  }

  await chrome.storage.local.set({ [TRIGGERS_KEY]: triggers });
}

// Delete trigger
export async function deleteTrigger(triggerId: string): Promise<void> {
  const data = await chrome.storage.local.get(TRIGGERS_KEY);
  const triggers = (data[TRIGGERS_KEY] as TriggerConfig[] | undefined) ?? [];
  const filtered = triggers.filter(t => t.id !== triggerId);
  await chrome.storage.local.set({ [TRIGGERS_KEY]: filtered });
}

// Delete all triggers for a script
export async function deleteTriggersForScript(scriptId: string): Promise<void> {
  const data = await chrome.storage.local.get(TRIGGERS_KEY);
  const triggers = (data[TRIGGERS_KEY] as TriggerConfig[] | undefined) ?? [];
  const filtered = triggers.filter(t => t.scriptId !== scriptId);
  await chrome.storage.local.set({ [TRIGGERS_KEY]: filtered });
}

// Get per-site override
export async function getSiteOverride(
  scriptId: string,
  url: string
): Promise<boolean | null> {
  const domain = new URL(url).hostname;
  const key = `${OVERRIDE_PREFIX}${scriptId}_${domain}`;
  const result = await chrome.storage.local.get(key);
  const override = result[key] as SiteOverride | undefined;
  return override ? override.enabled : null; // null = use trigger default
}

// Set per-site override
export async function setSiteOverride(
  scriptId: string,
  url: string,
  enabled: boolean
): Promise<void> {
  const domain = new URL(url).hostname;
  const key = `${OVERRIDE_PREFIX}${scriptId}_${domain}`;
  await chrome.storage.local.set({
    [key]: {
      domain,
      enabled,
      timestamp: Date.now()
    } as SiteOverride
  });
}

// Clear per-site override (revert to trigger default)
export async function clearSiteOverride(
  scriptId: string,
  url: string
): Promise<void> {
  const domain = new URL(url).hostname;
  const key = `${OVERRIDE_PREFIX}${scriptId}_${domain}`;
  await chrome.storage.local.remove(key);
}
```

Ensure proper error handling and type safety.
  </action>
  <verify>
Run `npx tsc --noEmit utils/storage/triggers.ts` - should compile without errors.
  </verify>
  <done>
Storage utilities exist with getTriggers, saveTrigger, deleteTrigger, getSiteOverride, setSiteOverride functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create VanJS reactive trigger store</name>
  <files>entrypoints/sidepanel/stores/triggers.ts</files>
  <action>
Create the VanJS reactive store for triggers following the pattern in `stores/scripts.ts`:

```typescript
import van from 'vanjs-core';
import type { TriggerConfig, ContextState } from '../../../utils/triggers/types';
import { getAllTriggers, getTriggers } from '../../../utils/storage/triggers';

// Reactive state for all triggers
export const triggersState = van.state<TriggerConfig[]>([]);

// Reactive state for currently suggested scripts (matched by context)
export const suggestedScriptIds = van.state<string[]>([]);

// Reactive state for current context
export const currentContext = van.state<ContextState | null>(null);

// Loading state
export const isLoadingTriggers = van.state(false);

// Derived: triggers for a specific script
export function getTriggersForScript(scriptId: string): TriggerConfig[] {
  return triggersState.val.filter(t => t.scriptId === scriptId);
}

// Derived: active (enabled) triggers only
export const activeTriggers = van.derive(() =>
  triggersState.val.filter(t => t.enabled)
);

// Load all triggers from storage
export async function loadTriggers(): Promise<void> {
  isLoadingTriggers.val = true;
  try {
    triggersState.val = await getAllTriggers();
  } finally {
    isLoadingTriggers.val = false;
  }
}

// Load triggers for specific script
export async function loadTriggersForScript(scriptId: string): Promise<void> {
  isLoadingTriggers.val = true;
  try {
    const scriptTriggers = await getTriggers(scriptId);
    // Merge into state
    const others = triggersState.val.filter(t => t.scriptId !== scriptId);
    triggersState.val = [...others, ...scriptTriggers];
  } finally {
    isLoadingTriggers.val = false;
  }
}

// Update suggested scripts from context match
export function setSuggestedScripts(scriptIds: string[]): void {
  suggestedScriptIds.val = scriptIds;
}

// Clear suggestions
export function clearSuggestions(): void {
  suggestedScriptIds.val = [];
}

// Update current context
export function setCurrentContext(context: ContextState | null): void {
  currentContext.val = context;
}

// Listen for storage changes (sync across contexts)
chrome.storage.onChanged.addListener((changes, area) => {
  if (area === 'local' && changes.browserlet_triggers) {
    triggersState.val = (changes.browserlet_triggers.newValue as TriggerConfig[] | undefined) ?? [];
  }
});
```

Follow VanJS patterns from existing stores (van.state, van.derive, storage listener).
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/sidepanel/stores/triggers.ts` - should compile without errors.
  </verify>
  <done>
VanJS store exists with triggersState, suggestedScriptIds, loadTriggers, storage change listener.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npx tsc --noEmit` - Full project compiles without errors
2. Types are properly exported and can be imported in other files
3. Storage utilities follow existing patterns (scripts.ts)
4. VanJS store follows existing patterns (scripts.ts)
</verification>

<success_criteria>
- [ ] utils/triggers/types.ts exists with TriggerCondition, TriggerConfig, TriggerMode, SiteOverride types
- [ ] utils/storage/triggers.ts exists with CRUD operations for triggers and overrides
- [ ] entrypoints/sidepanel/stores/triggers.ts exists with reactive state and storage sync
- [ ] Project compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-contextual-triggers/06-01-SUMMARY.md`
</output>
