---
phase: 05-llm-integration
plan: 04
type: execute
wave: 3
depends_on: ["05-01", "05-03"]
files_modified:
  - entrypoints/background/messaging.ts
  - entrypoints/sidepanel/stores/llmConfig.ts
  - entrypoints/sidepanel/components/LLMSettings.ts
autonomous: true

must_haves:
  truths:
    - "Side panel can send GENERATE_BSL message and receive BSL response"
    - "LLM config is persisted in chrome.storage.local with encrypted API key"
    - "Settings UI allows configuring Claude or Ollama provider"
    - "API key input is password-masked in UI"
  artifacts:
    - path: "entrypoints/background/messaging.ts"
      provides: "LLM message handlers"
      contains: "GENERATE_BSL"
    - path: "entrypoints/sidepanel/stores/llmConfig.ts"
      provides: "LLM configuration state management"
      exports: ["llmConfigStore", "saveLLMConfig", "loadLLMConfig"]
    - path: "entrypoints/sidepanel/components/LLMSettings.ts"
      provides: "Settings UI for LLM configuration"
      exports: ["LLMSettings"]
  key_links:
    - from: "entrypoints/background/messaging.ts"
      to: "entrypoints/background/llm/index.ts"
      via: "getLLMService for BSL generation"
      pattern: "getLLMService"
    - from: "entrypoints/sidepanel/stores/llmConfig.ts"
      to: "utils/crypto/encryption.ts"
      via: "encrypt/decrypt API key"
      pattern: "encryptApiKey|decryptApiKey"
---

<objective>
Add LLM message handlers to service worker, create config store with encrypted key storage, and build settings UI.

Purpose: Wire the LLM service to the messaging system so sidepanel can request BSL generation. Create persistent configuration that survives browser restarts (except API key which re-prompts for security).
Output: Working message handlers, config store, and settings component.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-llm-integration/05-RESEARCH.md

# Files to modify/reference
@entrypoints/background/messaging.ts
@entrypoints/background/llm/index.ts
@utils/crypto/encryption.ts
@entrypoints/sidepanel/stores/scripts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LLM message handlers to service worker</name>
  <files>entrypoints/background/messaging.ts</files>
  <action>
Add new message types to the messaging handler for LLM operations.

Import at top:
- getLLMService from './llm'
- CapturedAction from content/recording/types
- LLMConfig from './llm/providers/types'

Add Message type imports as needed in utils/types.ts if not already there.

Add new cases to processMessage switch:

case 'GENERATE_BSL': {
  const { actions } = message.payload as { actions: CapturedAction[] };
  const llmService = getLLMService();
  try {
    const result = await llmService.generateBSL(actions);
    return { success: true, data: result }; // { bsl: string, usedLLM: boolean }
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}

case 'CONFIGURE_LLM': {
  const config = message.payload as LLMConfig;
  const llmService = getLLMService();
  try {
    await llmService.initialize(config);
    return { success: true };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}

case 'GET_LLM_STATUS': {
  const llmService = getLLMService();
  const status = llmService.getStatus();
  return { success: true, data: status };
}

Also update utils/types.ts to add the new message types to the Message union if needed.
  </action>
  <verify>npm run build succeeds with new message handlers</verify>
  <done>messaging.ts handles GENERATE_BSL, CONFIGURE_LLM, and GET_LLM_STATUS messages</done>
</task>

<task type="auto">
  <name>Task 2: Create LLM config store with encrypted key storage</name>
  <files>entrypoints/sidepanel/stores/llmConfig.ts</files>
  <action>
Create config store for LLM settings using VanJS reactive pattern (following scripts.ts pattern).

Import:
- van from 'vanjs-core'
- encryptApiKey, decryptApiKey, EncryptedData from '../../../utils/crypto/encryption'

Storage key: 'browserlet_llm_config'

Define stored config type (what goes in chrome.storage):
```typescript
interface StoredLLMConfig {
  provider: 'claude' | 'ollama';
  claudeModel?: string;
  ollamaHost?: string;
  ollamaModel?: string;
  encryptedApiKey?: EncryptedData; // API key encrypted
}
```

Create reactive state:
```typescript
export const llmConfigStore = {
  provider: van.state<'claude' | 'ollama'>('claude'),
  claudeApiKey: van.state<string>(''), // Decrypted, in memory only
  claudeModel: van.state<string>('claude-sonnet-4-5-20250929'),
  ollamaHost: van.state<string>('http://localhost:11434'),
  ollamaModel: van.state<string>('llama3.1'),
  isConfigured: van.state<boolean>(false),
  needsApiKey: van.state<boolean>(false) // True if encrypted key exists but can't decrypt
};
```

Export async loadLLMConfig(): Promise<void>
- Load from chrome.storage.local
- If provider is 'claude' and encryptedApiKey exists:
  - Try to decrypt with decryptApiKey()
  - On success: set claudeApiKey.val, isConfigured.val = true
  - On failure (new session key): set needsApiKey.val = true, isConfigured.val = false
- Set other config values to store states

Export async saveLLMConfig(): Promise<void>
- Build StoredLLMConfig from current state
- If provider is 'claude' and claudeApiKey has value:
  - Encrypt with encryptApiKey()
  - Store encryptedApiKey (not the plaintext!)
- Save to chrome.storage.local
- Send CONFIGURE_LLM message to service worker to initialize LLMService

Export function getLLMConfigForServiceWorker(): LLMConfig
- Return LLMConfig object with decrypted API key (for sending to service worker)
  </action>
  <verify>npm run build succeeds (store compiles without errors)</verify>
  <done>llmConfig.ts exports llmConfigStore, loadLLMConfig, saveLLMConfig, getLLMConfigForServiceWorker</done>
</task>

<task type="auto">
  <name>Task 3: Create LLM Settings UI component</name>
  <files>entrypoints/sidepanel/components/LLMSettings.ts</files>
  <action>
Create VanJS component for LLM settings (following existing component patterns).

Import:
- van from 'vanjs-core'
- llmConfigStore, saveLLMConfig, loadLLMConfig from '../stores/llmConfig'
- i18n helper if exists, or use chrome.i18n.getMessage

Create LLMSettings component that returns a settings panel.

Structure:
1. Provider selection (radio buttons or select):
   - Claude API
   - Ollama (Local)

2. Claude-specific settings (shown when provider === 'claude'):
   - API Key input (type="password")
   - Model select dropdown:
     - claude-sonnet-4-5-20250929 (default, balanced)
     - claude-haiku-4-5-20250929 (faster, cheaper)
     - claude-opus-4-5-20250929 (most capable)
   - Show "API key required" warning if needsApiKey.val is true

3. Ollama-specific settings (shown when provider === 'ollama'):
   - Host input (default: http://localhost:11434)
   - Model input (default: llama3.1)
   - "Test Connection" button to check isAvailable

4. Save button:
   - Calls saveLLMConfig()
   - Shows success/error feedback

5. Status display:
   - Show current provider
   - Show if configured
   - Show "Re-enter API key after browser restart" note for Claude

Use Tailwind classes for styling (matching existing component styles).

Bind inputs to store state values using van.state reactivity.

Export LLMSettings component function.
  </action>
  <verify>npm run build succeeds (component compiles)</verify>
  <done>LLMSettings.ts exports component with provider selection, credential inputs, and save functionality</done>
</task>

</tasks>

<verification>
1. npm run build completes without errors
2. Service worker handles all three new message types
3. Config store correctly encrypts API key before storage
4. Settings component renders with all required fields
</verification>

<success_criteria>
- GENERATE_BSL message returns BSL string with usedLLM flag
- API key is never stored in plaintext
- Settings UI shows different options based on provider selection
- Save persists config and initializes LLM service
</success_criteria>

<output>
After completion, create `.planning/phases/05-llm-integration/05-04-SUMMARY.md`
</output>
