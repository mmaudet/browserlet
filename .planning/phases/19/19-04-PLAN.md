---
phase: 19-enriched-resolver
plan: 04
type: execute
wave: 2
depends_on: ["19-01", "19-02", "19-03"]
files_modified:
  - entrypoints/content/playback/cascadeResolver.ts
  - entrypoints/content/playback/index.ts
autonomous: true
must_haves:
  truths:
    - "CascadeResolver resolves 80%+ of elements without any LLM call"
    - "CascadeResolver returns the same ResolverResult interface as current semanticResolver"
    - "Stage 1 uses confidence >= 0.85 threshold with at least 1 high-weight hint matched"
    - "Stage 2 applies structural boosts and resolves at confidence >= 0.70"
    - "PlaybackManager uses cascadeResolver instead of semanticResolver"
    - "Element resolution completes in under 100ms for 100 candidates"
    - "Existing scripts continue to work unchanged after the switch"
  artifacts:
    - path: "entrypoints/content/playback/cascadeResolver.ts"
      provides: "Two-stage cascade resolver (deterministic + enriched)"
      exports: ["resolveElementCascade", "waitForElementCascade", "CascadeResolverResult"]
    - path: "entrypoints/content/playback/index.ts"
      provides: "Updated PlaybackManager imports using cascadeResolver"
  key_links:
    - from: "entrypoints/content/playback/cascadeResolver.ts"
      to: "entrypoints/content/playback/semanticResolver.ts"
      via: "imports resolveElement, HINT_WEIGHTS, isElementInteractable"
      pattern: "import.*resolveElement.*from.*semanticResolver"
    - from: "entrypoints/content/playback/cascadeResolver.ts"
      to: "entrypoints/content/playback/domContextExtractor.ts"
      via: "imports extractDOMContext"
      pattern: "import.*extractDOMContext.*from.*domContextExtractor"
    - from: "entrypoints/content/playback/cascadeResolver.ts"
      to: "entrypoints/content/playback/structuralScorer.ts"
      via: "imports computeStructuralBoost"
      pattern: "import.*computeStructuralBoost.*from.*structuralScorer"
    - from: "entrypoints/content/playback/cascadeResolver.ts"
      to: "entrypoints/content/playback/hintStabilityTracker.ts"
      via: "imports HintStabilityTracker"
      pattern: "import.*HintStabilityTracker.*from.*hintStabilityTracker"
    - from: "entrypoints/content/playback/index.ts"
      to: "entrypoints/content/playback/cascadeResolver.ts"
      via: "imports waitForElementCascade replacing waitForElement"
      pattern: "import.*waitForElementCascade.*from.*cascadeResolver"
---

<objective>
Create the CascadeResolver that orchestrates Stage 1 (deterministic) and Stage 2 (enriched structural) resolution, then wire it into PlaybackManager replacing the direct semanticResolver import.

Purpose: This is the integration plan that brings together DOMContextExtractor (19-01), StructuralScorer (19-02), and HintStabilityTracker (19-03) into a unified cascade resolver. It also modifies PlaybackManager to use the new resolver, completing the Phase 19 goal of 80%+ resolution without LLM calls.

Output: `entrypoints/content/playback/cascadeResolver.ts` (new file) + modified `entrypoints/content/playback/index.ts` (import swap).
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@entrypoints/content/playback/semanticResolver.ts
@entrypoints/content/playback/index.ts
@entrypoints/content/playback/types.ts
@entrypoints/content/recording/types.ts
@.planning/phases/19/19-01-SUMMARY.md
@.planning/phases/19/19-02-SUMMARY.md
@.planning/phases/19/19-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CascadeResolver with Stage 1 and Stage 2 logic</name>
  <files>entrypoints/content/playback/cascadeResolver.ts</files>
  <action>
Create `entrypoints/content/playback/cascadeResolver.ts` with the following:

**Extended result interface:**
```typescript
export interface CascadeResolverResult extends ResolverResult {
  /** Which cascade stage resolved the element (1 = deterministic, 2 = enriched, 6 = fallback CSS) */
  stage: number;
  /** Structural boost details (only for Stage 2) */
  structuralBoost?: StructuralBoost;
  /** Stability boost applied (only if stability data exists) */
  stabilityBoost?: number;
  /** Performance: resolution time in milliseconds */
  resolutionTimeMs: number;
}
```

This extends ResolverResult (RSLV-09), so anywhere that expects ResolverResult can accept CascadeResolverResult.

**Constants:**
```typescript
const STAGE_1_CONFIDENCE = 0.85;  // Raised from 0.70 per 18-ANALYSIS.md
const STAGE_2_CONFIDENCE = 0.70;  // After structural boosts
const HIGH_WEIGHT_THRESHOLD = 0.9; // Minimum weight for "high-weight hint" requirement
```

**Function: resolveElementCascade(hints: SemanticHint[]): Promise<CascadeResolverResult> (exported)**

This is the main resolution function. It implements Stage 1 and Stage 2, leaving Stage 3-5 as extension points for Phase 20.

**Stage 1: Deterministic hint matching (reuse existing semanticResolver)**
1. Call the existing `resolveElement(hints)` from `semanticResolver.ts` -- this returns `ResolverResult`
2. Check if result meets Stage 1 criteria:
   - `result.confidence >= STAGE_1_CONFIDENCE` (0.85)
   - At least one matched hint has weight >= `HIGH_WEIGHT_THRESHOLD` (0.9) -- check against `HINT_WEIGHTS`
   - `result.element` is not null
3. If criteria met: apply stability boost (see below), return result with `stage: 1`
4. If not met: proceed to Stage 2

**Stability boost (applied to Stage 1 and Stage 2):**
- Create `HintStabilityTracker` instance (it caches per hostname)
- Call `await tracker.load()` once per resolution
- Call `tracker.getStabilityBoost(hints)` to get the boost value (0 or +0.2)
- Add this boost to the confidence (capped at 1.0)
- This means a hint set with 0.75 base confidence + 0.2 stability boost = 0.95 -- passes Stage 1

**Stage 2: Enriched structural matching**
1. If Stage 1 did not resolve, get all candidates by running the resolver's internal logic.
   - Re-purpose the existing scoring by calling `resolveElement(hints)` -- but we need ALL candidates, not just the best. Since `resolveElement` only returns the best match, we need to implement a variant.
   - **Approach:** Create a local helper `scoreAllCandidates(hints: SemanticHint[])` that replicates the candidate gathering and scoring from `semanticResolver.ts` but returns ALL candidates with their scores (not just the best). This avoids modifying the existing semanticResolver.ts file.
   - The helper should: (a) call `getInitialCandidates` logic (inline, since it's not exported), (b) score each candidate using `matchHint` logic (inline), (c) return array of `{ element, confidence, matchedHints, failedHints }`.

   **Important design note:** Rather than fully duplicating getInitialCandidates/matchHint, create a simpler version: use the Stage 1 result as the starting point. If Stage 1 found an element but below threshold, or found multiple near-ties, extract enriched context for that element. If Stage 1 found nothing, fall through to Stage 6 (CSS fallback) or return failure.

   **Simplified Stage 2 approach:**
   - Take the Stage 1 result (even if below threshold) -- it has the best candidate
   - Also scan for ALL visible elements matching at least one high-weight hint (role, type, name, id) to find competing candidates
   - For the best candidate AND any competitors within 0.20 confidence of it:
     a. Call `extractDOMContext(candidate)` for each
     b. Call `computeStructuralBoost(context, hints)` for each
     c. Add `structuralBoost.total` to the raw confidence
     d. Add `stabilityBoost` if applicable
     e. Cap at 1.0
   - Pick the candidate with the highest adjusted confidence
   - If best adjusted confidence >= `STAGE_2_CONFIDENCE` (0.70): return with `stage: 2`
   - If not: return failure result with `stage: 2` (element: null)

**Stage 6: CSS fallback (not implemented here -- handled in PlaybackManager already)**
- The existing PlaybackManager already checks `fallback_selector` when resolution fails. CascadeResolver does NOT need to handle this. Leave a comment: `// Stage 6 (CSS fallback) handled by PlaybackManager`
- Stages 3-5 (micro-prompts) will be wired in Phase 20. Leave a comment: `// Stages 3-5 (micro-prompts) to be wired in Phase 20`

**Function: waitForElementCascade(hints: SemanticHint[], timeoutMs: number = 10000): Promise<CascadeResolverResult> (exported)**
- Mirrors the existing `waitForElement()` signature but uses `resolveElementCascade` internally
- Immediate attempt: call `resolveElementCascade(hints)`
- If resolved (element not null) and `isElementInteractable(element)`: return
- Otherwise: set up MutationObserver (same pattern as existing `waitForElement`) and retry `resolveElementCascade` on DOM changes
- Timeout: same behavior as existing -- reject with error after timeoutMs
- Performance: track total resolution time in `resolutionTimeMs`

**Performance (RSLV-13):**
- Stage 1 is essentially the same as current resolver -- already fast
- Stage 2 adds extractDOMContext per candidate (bounded: max ~10 competitors) + computeStructuralBoost per candidate
- extractDOMContext is O(depth) per element, computeStructuralBoost is O(hints) per element
- For 100 candidates: Stage 1 scores all 100 (existing speed). Stage 2 only runs on top ~5-10 competitors (filtered by 0.20 gap from best). Total: well under 100ms.
- Add `performance.now()` timing around the resolution to populate `resolutionTimeMs`

**Record stability data after resolution:**
- After successful resolution (any stage): call `tracker.recordSuccess(hints, result.matchedHints)`
- After failed resolution: call `tracker.recordFailure(hints)`
- Do this asynchronously (fire-and-forget) to avoid blocking the resolution

**Imports:**
```typescript
import type { SemanticHint, HintType } from '../recording/types';
import type { ResolverResult } from './types';
import { resolveElement, isElementInteractable, HINT_WEIGHTS } from './semanticResolver';
import { extractDOMContext } from './domContextExtractor';
import { computeStructuralBoost } from './structuralScorer';
import type { StructuralBoost } from './structuralScorer';
import { HintStabilityTracker } from './hintStabilityTracker';
import { getElementRole, isElementVisible } from '../../../utils/hints/dom';
import { normalizeText } from '../../../utils/hints/text';
```
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- must compile with zero errors. Verify exports: `grep -n "export" entrypoints/content/playback/cascadeResolver.ts` shows `resolveElementCascade`, `waitForElementCascade`, and `CascadeResolverResult`.
  </verify>
  <done>
`cascadeResolver.ts` exists with `resolveElementCascade` (Stage 1 + Stage 2) and `waitForElementCascade` functions. Stage 1 uses 0.85 threshold + high-weight hint requirement. Stage 2 applies structural boosts from DOMContextExtractor + StructuralScorer. Stability boost from HintStabilityTracker applied. Returns CascadeResolverResult extending ResolverResult (RSLV-09). Performance tracked via resolutionTimeMs. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire CascadeResolver into PlaybackManager</name>
  <files>entrypoints/content/playback/index.ts</files>
  <action>
Modify `entrypoints/content/playback/index.ts` to use the cascade resolver:

**Step 1: Update import (line 32)**
Change:
```typescript
import { waitForElement, resolveElement } from './semanticResolver';
```
To:
```typescript
import { waitForElementCascade, resolveElementCascade } from './cascadeResolver';
```

**Step 2: Update usage in executeStep method (~line 457)**
Change:
```typescript
const result = await waitForElement(hints, timeout);
```
To:
```typescript
const result = await waitForElementCascade(hints, timeout);
```

**Step 3: Update re-exports (line 572)**
Change:
```typescript
export { waitForElement, resolveElement, isElementInteractable, HINT_WEIGHTS } from './semanticResolver';
```
To:
```typescript
export { waitForElement, resolveElement, isElementInteractable, HINT_WEIGHTS } from './semanticResolver';
export { waitForElementCascade, resolveElementCascade } from './cascadeResolver';
export type { CascadeResolverResult } from './cascadeResolver';
```
Keep the semanticResolver re-exports for backward compatibility -- other parts of the codebase may import them. Only the PlaybackManager's internal usage switches to the cascade version.

**Step 4: Add resolution logging in executeStep**
After the element is resolved, add a debug log:
```typescript
if ('stage' in result) {
  console.log('[Browserlet] Cascade resolution: stage', result.stage, 'confidence:', result.confidence, 'time:', result.resolutionTimeMs + 'ms');
}
```
This provides visibility into which cascade stage resolved each element during playback.

**What NOT to change:**
- Do NOT modify the SessionDetector or ActionExecutor
- Do NOT modify any existing semanticResolver.ts exports
- Do NOT change the waitForElement timeout behavior
- Do NOT change any error handling in PlaybackManager
- The CascadeResolverResult extends ResolverResult, so all existing code that reads `result.element`, `result.confidence`, `result.matchedHints`, `result.failedHints` continues to work without changes
  </action>
  <verify>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -n "cascadeResolver\|waitForElementCascade" entrypoints/content/playback/index.ts` shows the new imports and usage
3. `grep -n "waitForElement.*semanticResolver" entrypoints/content/playback/index.ts` confirms old import is NOT used for internal execution (though re-export is kept)
4. `npm run build` (or `npm run dev`) succeeds -- full build with no errors
  </verify>
  <done>
PlaybackManager in `index.ts` imports and uses `waitForElementCascade` from `cascadeResolver.ts` for element resolution. Old `semanticResolver` exports preserved for backward compatibility. Cascade stage and timing logged during playback. `CascadeResolverResult` type exported from the playback module. Full build succeeds with zero TypeScript errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify backward compatibility and build</name>
  <files></files>
  <action>
Run a comprehensive verification to confirm Phase 19 is complete and backward compatible:

1. **TypeScript compilation:** `npx tsc --noEmit` -- zero errors across the entire project
2. **Build verification:** `npm run build` -- extension builds successfully for Chrome
3. **Firefox build:** `npm run build:firefox` (if available) or `npm run dev:firefox` -- verify Firefox build succeeds
4. **Import graph check:** Verify no circular imports were introduced:
   - `cascadeResolver.ts` imports from `semanticResolver.ts`, `domContextExtractor.ts`, `structuralScorer.ts`, `hintStabilityTracker.ts`
   - `index.ts` imports from `cascadeResolver.ts`
   - None of these files import from `index.ts` (would create circular dependency)
5. **Existing export check:** All existing exports from `entrypoints/content/playback/index.ts` still present:
   - `waitForElement`, `resolveElement`, `isElementInteractable`, `HINT_WEIGHTS` (from semanticResolver)
   - All action executor, session detector, humanizer, variable substitution exports unchanged
6. **No regressions check:** `grep -rn "from.*playback" entrypoints/ utils/` -- verify all import paths still resolve
7. **Performance sanity:** The cascade resolver adds at most 2 extra DOM traversals per candidate in Stage 2. For a page with 100 candidates and 10 Stage 2 competitors, that's ~20 bounded DOM walks. Each walk is O(depth) where depth is typically 10-15 levels. This is well under 100ms on any modern browser.

If any check fails, fix the issue before marking complete.
  </action>
  <verify>
All 6 verification checks pass:
1. `npx tsc --noEmit` exits with code 0
2. `npm run build` exits with code 0
3. Firefox build succeeds (or note if Firefox build script is not available)
4. No circular imports (verify with grep or manual inspection)
5. All existing exports preserved in index.ts
6. All import paths resolve
  </verify>
  <done>
Full project compiles and builds with zero errors. All 4 new files created (domContextExtractor.ts, structuralScorer.ts, hintStabilityTracker.ts, cascadeResolver.ts). PlaybackManager wired to use cascade resolver. All existing exports preserved for backward compatibility. No circular imports. Phase 19 complete.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm run build` succeeds
- CascadeResolver implements Stage 1 (confidence >= 0.85 + high-weight hint) and Stage 2 (structural boost + confidence >= 0.70)
- CascadeResolverResult extends ResolverResult (RSLV-09) -- any code expecting ResolverResult works
- PlaybackManager uses `waitForElementCascade` for all element resolution
- Old `waitForElement` and `resolveElement` still exported for backward compatibility
- Stability data recorded after each resolution (success/failure)
- Resolution time tracked in milliseconds (RSLV-13)
- Console logs show cascade stage, confidence, and timing during playback
</verification>

<success_criteria>
- CascadeResolver resolves elements through Stage 1 (deterministic) -> Stage 2 (enriched) cascade (RSLV-08)
- Returns same ResolverResult interface, extended with stage/boost/timing info (RSLV-09)
- Stage 1 threshold is 0.85 (not 0.70) with high-weight hint requirement
- Stage 2 threshold is 0.70 after structural boosts
- Stability boost of +0.2 applied for historically reliable hints (RSLV-12)
- PlaybackManager fully wired to cascade resolver
- Resolution under 100ms for 100 candidates (RSLV-13)
- Full project builds with zero TypeScript errors
- Existing scripts work unchanged (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/19/19-04-SUMMARY.md`
</output>
