---
phase: 19-enriched-resolver
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - entrypoints/content/playback/structuralScorer.ts
autonomous: true
must_haves:
  truths:
    - "StructuralScorer boosts confidence by +0.15 when element's fieldset legend matches expected context"
    - "StructuralScorer boosts confidence by +0.15 when element has a matching associated label"
    - "StructuralScorer boosts confidence by +0.10 for near_label proximity match, weighted by distance"
    - "Structural boosts are additive and applied to raw score before normalization"
  artifacts:
    - path: "entrypoints/content/playback/structuralScorer.ts"
      provides: "Structural confidence boosting for enriched resolution"
      exports: ["computeStructuralBoost", "StructuralBoost", "STRUCTURAL_BOOST_VALUES"]
  key_links:
    - from: "entrypoints/content/playback/structuralScorer.ts"
      to: "entrypoints/content/playback/domContextExtractor.ts"
      via: "imports DOMContext type"
      pattern: "import.*DOMContext.*from.*domContextExtractor"
    - from: "entrypoints/content/playback/structuralScorer.ts"
      to: "entrypoints/content/recording/types.ts"
      via: "imports SemanticHint type"
      pattern: "import.*SemanticHint.*from.*recording/types"
---

<objective>
Create the StructuralScorer module that computes confidence boosts based on enriched DOM context matching against the original hints.

Purpose: When the base hint-matching score is not high enough for Stage 1 (< 0.85), or when multiple candidates score similarly, StructuralScorer adds confidence boosts based on structural DOM context. A +0.15 fieldset boost can differentiate two identical "Email" inputs in different form sections. This is Stage 2 of the cascade resolver.

Output: `entrypoints/content/playback/structuralScorer.ts` -- a pure function module that takes DOMContext + hints and returns a numeric boost value.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@entrypoints/content/playback/semanticResolver.ts
@entrypoints/content/playback/types.ts
@entrypoints/content/recording/types.ts
@utils/hints/text.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StructuralScorer with boost computation logic</name>
  <files>entrypoints/content/playback/structuralScorer.ts</files>
  <action>
Create `entrypoints/content/playback/structuralScorer.ts` with the following:

**Note on imports:** This file imports the `DOMContext` type from `domContextExtractor.ts` (Plan 19-01). Since Plans 19-01 and 19-02 are Wave 1 (parallel), the import may not resolve during development of this plan alone. To handle this, define the `DOMContext` type inline as a local interface that mirrors the shape from Plan 19-01. Add a comment: `// Type mirrors DOMContext from domContextExtractor.ts -- will be replaced with import in Plan 19-04`. Alternatively, if Plan 19-01 is already complete when this executes, import directly.

**Strategy:** Check if `entrypoints/content/playback/domContextExtractor.ts` already exists. If yes, import `DOMContext` from it. If no, define the type locally with a TODO comment.

**Constants (exported):**
```typescript
export const STRUCTURAL_BOOST_VALUES = {
  FIELDSET_LEGEND: 0.15,   // RSLV-05: fieldset legend match
  ASSOCIATED_LABEL: 0.15,  // RSLV-06: label[for] or aria-labelledby match
  NEAR_LABEL: 0.10,        // RSLV-07: near_label proximity match (max, before distance weighting)
  LANDMARK: 0.10,          // landmark region match
  SECTION_HEADING: 0.08,   // section heading match
} as const;
```

**StructuralBoost interface (exported):**
```typescript
export interface StructuralBoost {
  /** Total additive boost to apply to raw score */
  total: number;
  /** Breakdown of which boosts were applied and why */
  details: Array<{
    type: 'fieldset' | 'label' | 'near_label' | 'landmark' | 'heading';
    boost: number;
    reason: string;
  }>;
}
```

**computeStructuralBoost(context: DOMContext, hints: SemanticHint[]): StructuralBoost function (exported):**

This is the main function. It evaluates each structural signal against the hints and accumulates boosts.

**Boost 1: Fieldset legend (RSLV-05, +0.15)**
- If `context.fieldset_legend` is not null:
  - Check if any hint has a value that is contained within the fieldset legend text (using `normalizeText` comparison)
  - Specifically check `near_label` and `text_contains` hint types, as well as any hint whose value appears in the legend
  - If match found: add +0.15 boost with reason `"fieldset legend '{legend}' matches hint"`
  - This handles the billing/shipping email case: the hint might not reference the fieldset directly, but when comparing two candidates, the one whose structural context better matches the action intent gets the boost

**Boost 2: Associated label (RSLV-06, +0.15)**
- If `context.associated_label` is not null:
  - Check if any `near_label`, `aria_label`, or `text_contains` hint value matches the associated label text
  - Use `normalizeText()` for comparison, check `includes()` in both directions (label contains hint value OR hint value contains label)
  - If match found: add +0.15 boost with reason `"associated label '{label}' matches hint"`

**Boost 3: Near label proximity (RSLV-07, +0.10 max, weighted by distance)**
- If `context.near_label` is not null:
  - Check if any `near_label`, `text_contains`, or `placeholder_contains` hint value matches the near_label text
  - Weight by distance: `boost = 0.10 * (1 - (distance - 1) / 3)` -- distance 1 gets full 0.10, distance 2 gets 0.067, distance 3 gets 0.033
  - If match found: add the distance-weighted boost with reason `"near label '{text}' at distance {distance} matches hint"`

**Boost 4: Landmark region (+0.10)**
- If `context.landmark` is not null:
  - Check if any `role` hint value corresponds to a landmark (e.g., hint has role=link and element is inside nav -- this is complementary, not a direct match)
  - More importantly: when comparing multiple candidates, the landmark provides a disambiguation signal. But since this function scores a single candidate, check if any hint references the landmark explicitly or if the landmark name appears in any hint value
  - If match found: add +0.10 boost
  - Note: This boost is primarily useful when the CascadeResolver compares multiple candidates' structural boosts

**Boost 5: Section heading (+0.08)**
- If `context.section_heading` is not null:
  - Check if any hint value matches the section heading text (using normalized includes)
  - If match found: add +0.08 boost

**Cap:** Total structural boost is capped at 0.35 to prevent structural signals from dominating over hint-based scoring. This keeps structural boosts as tiebreakers, not primary signals.

**Imports:**
```typescript
import type { SemanticHint } from '../recording/types';
import { normalizeText } from '../../../utils/hints/text';
// Import DOMContext if available, otherwise define locally
```

**Helper: hintValuesToStrings(hints: SemanticHint[]): string[]**
- Extract all string hint values (skip data_attribute objects) into a flat normalized array
- Used by all boost checks for matching
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- must compile with zero errors. Verify exports: `grep -n "export" entrypoints/content/playback/structuralScorer.ts` shows `computeStructuralBoost`, `StructuralBoost`, and `STRUCTURAL_BOOST_VALUES`.
  </verify>
  <done>
File exists at `entrypoints/content/playback/structuralScorer.ts`. Exports `computeStructuralBoost` function, `StructuralBoost` interface, and `STRUCTURAL_BOOST_VALUES` constants. Implements all 3 RSLV boost requirements (05-07): fieldset +0.15, label +0.15, near_label +0.10 weighted by distance. Total boost capped at 0.35. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `STRUCTURAL_BOOST_VALUES.FIELDSET_LEGEND === 0.15` (RSLV-05)
- `STRUCTURAL_BOOST_VALUES.ASSOCIATED_LABEL === 0.15` (RSLV-06)
- `STRUCTURAL_BOOST_VALUES.NEAR_LABEL === 0.10` (RSLV-07)
- `computeStructuralBoost` returns `{ total: number, details: Array }` structure
- Total boost is capped at 0.35
- No `chrome.*` or `browser.*` calls (pure computation)
</verification>

<success_criteria>
- Fieldset legend match adds exactly +0.15 to boost (RSLV-05)
- Associated label match adds exactly +0.15 to boost (RSLV-06)
- Near label proximity match adds up to +0.10, weighted inversely by distance (RSLV-07)
- Boost details array provides human-readable reasons for each applied boost
- Function is pure: (DOMContext, SemanticHint[]) -> StructuralBoost with no side effects
- Total boost capped at 0.35 to prevent structural signals from dominating
</success_criteria>

<output>
After completion, create `.planning/phases/19/19-02-SUMMARY.md`
</output>
