---
phase: 19-enriched-resolver
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - entrypoints/content/playback/domContextExtractor.ts
autonomous: true
must_haves:
  truths:
    - "DOMContextExtractor extracts fieldset legend text for elements inside fieldsets"
    - "DOMContextExtractor resolves associated labels via for= attribute and aria-labelledby"
    - "DOMContextExtractor finds near_label by walking DOM tree up to depth 3"
    - "DOMContextExtractor extracts text from previous and next 3 siblings"
  artifacts:
    - path: "entrypoints/content/playback/domContextExtractor.ts"
      provides: "DOM context extraction for enriched resolution"
      exports: ["extractDOMContext", "DOMContext"]
  key_links:
    - from: "entrypoints/content/playback/domContextExtractor.ts"
      to: "utils/hints/dom.ts"
      via: "import findAssociatedLabel, getElementRole"
      pattern: "import.*findAssociatedLabel.*from.*utils/hints/dom"
    - from: "entrypoints/content/playback/domContextExtractor.ts"
      to: "utils/hints/text.ts"
      via: "import normalizeText"
      pattern: "import.*normalizeText.*from.*utils/hints/text"
---

<objective>
Create the DOMContextExtractor module that extracts enriched structural DOM context for any candidate element during playback resolution.

Purpose: The current resolver only matches against the 10 hint types recorded at capture time. When multiple elements share identical hints (e.g., two "Email" inputs in billing vs shipping fieldsets), the resolver cannot distinguish them. DOMContextExtractor provides the additional structural signals (fieldset, labels, proximity, siblings) that StructuralScorer (Plan 19-02) uses to break these ties.

Output: `entrypoints/content/playback/domContextExtractor.ts` -- a pure function module with no side effects or storage access.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@entrypoints/content/playback/semanticResolver.ts
@entrypoints/content/playback/types.ts
@utils/hints/dom.ts
@utils/hints/text.ts
@entrypoints/content/recording/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DOMContext interface and extractDOMContext function</name>
  <files>entrypoints/content/playback/domContextExtractor.ts</files>
  <action>
Create `entrypoints/content/playback/domContextExtractor.ts` with the following:

**DOMContext interface:**
```typescript
export interface DOMContext {
  /** Fieldset legend text if element is inside a fieldset (RSLV-01) */
  fieldset_legend: string | null;
  /** Associated label text via for= or aria-labelledby (RSLV-02) */
  associated_label: string | null;
  /** Near label text found by DOM tree proximity walk, with distance (RSLV-03) */
  near_label: { text: string; distance: number } | null;
  /** Text content of previous and next 3 siblings (RSLV-04) */
  sibling_texts: { before: string[]; after: string[] };
  /** Nearest ARIA landmark region (nav, main, aside, header, footer, form) */
  landmark: string | null;
  /** Nearest section heading text (h1-h6) */
  section_heading: string | null;
}
```

**extractDOMContext(element: Element): DOMContext function:**

This is the main exported function. It calls the 6 sub-extractors below and returns a populated DOMContext object.

**Sub-extractor 1: extractFieldsetLegend(element: Element): string | null (RSLV-01)**
- Call `element.closest('fieldset')` to find nearest ancestor fieldset
- If found, query `fieldset.querySelector(':scope > legend')` for direct-child legend only (not nested fieldset legends)
- Return `normalizeText(legend.textContent)` or null
- Performance: single DOM traversal up, single querySelector down -- O(depth)

**Sub-extractor 2: extractAssociatedLabel(element: Element): string | null (RSLV-02)**
- First check `aria-labelledby`: `element.getAttribute('aria-labelledby')` -- if present, split by space, map each ID to `document.getElementById(id)`, concatenate their textContent
- Then check `label[for=]`: if element has an `id`, query `document.querySelector('label[for="' + element.id + '"]')`
- Then check parent label: `element.closest('label')`
- Return normalized text of the first method that succeeds, or null
- NOTE: This is distinct from `findAssociatedLabel()` in dom.ts because it specifically handles `aria-labelledby` (which the existing utility does NOT handle) and returns text instead of the element. Import `findAssociatedLabel` as a fallback for methods 2-3: if aria-labelledby is not present, call `findAssociatedLabel(element)` and return its textContent.

**Sub-extractor 3: extractNearLabel(element: Element, maxDepth: number = 3): { text: string; distance: number } | null (RSLV-03)**
- Walk up the DOM tree from element.parentElement, up to `maxDepth` levels
- At each level, look for text nodes and label-like elements (label, legend, dt, strong, span with short text <50 chars) that are NOT the element itself or its descendants
- Track the distance (1 = parent level, 2 = grandparent, 3 = great-grandparent)
- Return the closest match with its distance, or null
- Weight by distance: distance 1 is most relevant, distance 3 least (the scorer in Plan 19-02 uses this)
- Skip elements that are themselves form controls (input, select, textarea, button) -- we want label-like text only

**Sub-extractor 4: extractSiblingTexts(element: Element): { before: string[]; after: string[] } (RSLV-04)**
- Get the parent element's children array
- Find the index of the target element
- Collect textContent from up to 3 previous siblings and 3 next siblings
- Filter: skip siblings that are themselves form controls (input, select, textarea, button) -- we want descriptive text only
- Normalize each text with `normalizeText()`, filter out empty strings
- Return `{ before: string[], after: string[] }` (each array has 0-3 entries)

**Sub-extractor 5: extractLandmark(element: Element): string | null**
- Call `element.closest('nav, main, aside, header, footer, [role="navigation"], [role="main"], [role="complementary"], [role="banner"], [role="contentinfo"], [role="form"], form')`
- If found, return the ARIA role (explicit `role` attribute, or implicit from tag name using the mapping: nav=navigation, main=main, aside=complementary, header=banner, footer=contentinfo, form=form)
- Return null if no landmark ancestor found

**Sub-extractor 6: extractSectionHeading(element: Element): string | null**
- Walk up from element through ancestors (max 5 levels)
- At each level, look backwards through previousElementSiblings for h1-h6 elements
- Also check if the parent/ancestor itself contains a direct child heading
- Return the normalized textContent of the nearest heading found, or null
- Stop at landmark boundaries (don't cross into a different landmark region)

**Imports:**
```typescript
import { findAssociatedLabel } from '../../../utils/hints/dom';
import { normalizeText } from '../../../utils/hints/text';
```

**Performance constraint (RSLV-13):** Each sub-extractor must complete in O(depth) time, not O(n) where n = total DOM nodes. All traversals are bounded: closest() is O(depth), sibling walks are bounded to 3, parent walks are bounded to maxDepth. No querySelectorAll on document -- only scoped queries on found ancestors.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- must compile with zero errors. Verify the file exports `DOMContext` interface and `extractDOMContext` function by checking the output of: `grep -n "export" entrypoints/content/playback/domContextExtractor.ts`
  </verify>
  <done>
File exists at `entrypoints/content/playback/domContextExtractor.ts`. Exports `DOMContext` interface and `extractDOMContext` function. Handles all 4 RSLV requirements (01-04): fieldset legend extraction, associated label via for=/aria-labelledby, near_label with distance tracking, sibling text extraction. Also extracts landmark and section_heading for structural scoring. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `grep -rn "extractDOMContext\|DOMContext" entrypoints/content/playback/` shows the exports
- File imports from `utils/hints/dom.ts` and `utils/hints/text.ts` (reuses existing utilities)
- No `chrome.*` or `browser.*` calls in this file (pure DOM traversal, no storage)
- File has no side effects -- all functions are pure (input element, output context)
</verification>

<success_criteria>
- DOMContext interface captures all 6 structural signals: fieldset_legend, associated_label, near_label (with distance), sibling_texts, landmark, section_heading
- extractDOMContext() is a synchronous function (DOM traversal only, no async)
- aria-labelledby resolution works (splits by space, concatenates referenced element texts)
- Near label extraction tracks distance for weighted scoring
- Sibling text extraction skips form controls, only captures descriptive text
- All DOM traversals are bounded (no unbounded querySelectorAll on document)
</success_criteria>

<output>
After completion, create `.planning/phases/19/19-01-SUMMARY.md`
</output>
