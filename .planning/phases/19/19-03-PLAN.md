---
phase: 19-enriched-resolver
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - entrypoints/content/playback/hintStabilityTracker.ts
autonomous: true
must_haves:
  truths:
    - "HintStabilityTracker stores per-site hint success/failure counts in storage"
    - "Storage uses aggregated counters (not individual events) to bound growth"
    - "Hints with >90% success rate receive a +0.2 confidence boost"
    - "Storage key is per-hostname, bounded to prevent unbounded growth"
  artifacts:
    - path: "entrypoints/content/playback/hintStabilityTracker.ts"
      provides: "Per-site hint stability tracking and confidence boosting"
      exports: ["HintStabilityTracker", "HintStabilityData"]
  key_links:
    - from: "entrypoints/content/playback/hintStabilityTracker.ts"
      to: "utils/storage/browserCompat.ts"
      via: "import storage for chrome.storage.local access"
      pattern: "import.*storage.*from.*browserCompat"
    - from: "entrypoints/content/playback/hintStabilityTracker.ts"
      to: "entrypoints/content/recording/types.ts"
      via: "imports SemanticHint type"
      pattern: "import.*SemanticHint.*from.*recording/types"
---

<objective>
Create the HintStabilityTracker module that tracks per-site hint success/failure rates and provides confidence boosts for historically reliable hints.

Purpose: When an element is resolved successfully on a site, the hints that matched become more trustworthy for future visits. Conversely, hints that frequently fail on a site should be deprioritized. This creates a learning loop where the resolver improves with usage, without any LLM involvement.

Output: `entrypoints/content/playback/hintStabilityTracker.ts` -- a class that reads/writes aggregated counters to chrome.storage.local via the browserCompat polyfill.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@entrypoints/content/playback/types.ts
@entrypoints/content/recording/types.ts
@utils/storage/browserCompat.ts
@utils/storage/scripts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HintStabilityTracker with storage and boost logic</name>
  <files>entrypoints/content/playback/hintStabilityTracker.ts</files>
  <action>
Create `entrypoints/content/playback/hintStabilityTracker.ts` with the following:

**Storage format and types:**

```typescript
/** Aggregated counter for a single hint key on a specific site (RSLV-11) */
interface HintCounter {
  successes: number;
  failures: number;
}

/** Per-site stability data stored in chrome.storage.local */
export interface HintStabilityData {
  /** Map of hint key -> aggregated counter */
  hints: Record<string, HintCounter>;
  /** Last update timestamp (for potential future cleanup) */
  lastUpdated: number;
  /** Schema version for future migrations */
  version: 1;
}
```

**Hint key format:** `{hintType}:{normalizedValue}` -- e.g., `"name:email"`, `"role:textbox"`, `"text_contains:submit order"`. For `data_attribute` type: `"data_attribute:{name}={value}"`. Normalize values with `normalizeText()` to prevent duplicates from case/whitespace differences.

**Storage key:** `browserlet_hint_stability_{hostname}` where hostname is extracted from `window.location.hostname`. This scopes stability data per-site as specified in the architecture context.

**Class: HintStabilityTracker (exported)**

```typescript
export class HintStabilityTracker {
  private hostname: string;
  private storageKey: string;
  private cache: HintStabilityData | null = null;

  constructor(hostname?: string) {
    this.hostname = hostname ?? window.location.hostname;
    this.storageKey = `browserlet_hint_stability_${this.hostname}`;
  }
```

**Method: async load(): Promise<HintStabilityData>**
- Read from storage via `storage.local.get(this.storageKey)`
- If not found, return default: `{ hints: {}, lastUpdated: Date.now(), version: 1 }`
- Cache the result in `this.cache` for repeated reads within same session
- Return cached data on subsequent calls (avoids repeated storage reads during a single playback session)

**Method: async recordSuccess(hints: SemanticHint[], matchedHintKeys: string[]): Promise<void> (RSLV-10)**
- For each matched hint key: increment `successes` counter
- For each unmatched hint: increment `failures` counter
- Hint keys are derived from the SemanticHint array using the key format above
- `matchedHintKeys` is the array of `"{type}:{value}"` strings that matched (from ResolverResult.matchedHints)
- Write back to storage after updates
- Update `this.cache`

**Method: async recordFailure(hints: SemanticHint[]): Promise<void> (RSLV-10)**
- Increment `failures` for ALL hint keys in the array (entire resolution failed)
- Write back to storage
- Update `this.cache`

**Method: getStabilityBoost(hints: SemanticHint[]): number (RSLV-12)**
- Requires `this.cache` to be populated (call `load()` first)
- If cache is null, return 0 (no data yet)
- For each hint, look up its counter in cache
- Calculate success rate: `successes / (successes + failures)`
- If ANY hint has success rate > 0.9 AND total attempts >= 5 (minimum sample size): return +0.2
- If ALL hints have success rate > 0.9 AND total attempts >= 5: return +0.2 (same -- we don't stack the boost)
- The +0.2 boost is a flat value, not per-hint (to prevent inflation from many stable hints)
- Return 0 if no hint meets the threshold

**Method: getHintSuccessRate(hintKey: string): number | null**
- Return success rate for a specific hint key, or null if no data
- Used for debugging/logging

**Bounded growth (RSLV-11):**

**Method: private async pruneIfNeeded(data: HintStabilityData): Promise<HintStabilityData>**
- Maximum 200 hint keys per site -- if exceeded, remove the least-used entries (lowest total = successes + failures)
- This bounds storage to ~200 * ~50 bytes per key = ~10KB per site, manageable
- Called before every write operation
- Also apply decay: if `lastUpdated` is more than 30 days ago, halve all counters (integer division) to prevent stale data from dominating. Reset `lastUpdated` to now.

**Helper: hintToKey(hint: SemanticHint): string**
- Convert a SemanticHint to its storage key string
- For string values: `normalizeText(hint.type + ':' + hint.value)`
- For data_attribute (object value): `'data_attribute:' + normalizeText(hint.value.name + '=' + hint.value.value)`

**Imports:**
```typescript
import { storage } from '../../../utils/storage/browserCompat';
import type { SemanticHint } from '../recording/types';
import { normalizeText } from '../../../utils/hints/text';
```

**Firefox note:** Uses `storage` from `browserCompat.ts` which resolves to `browser.storage` on Firefox and `chrome.storage` on Chrome. No direct `chrome.*` calls.
  </action>
  <verify>
Run `npx tsc --noEmit` from project root -- must compile with zero errors. Verify exports: `grep -n "export" entrypoints/content/playback/hintStabilityTracker.ts` shows `HintStabilityTracker` class and `HintStabilityData` interface.
  </verify>
  <done>
File exists at `entrypoints/content/playback/hintStabilityTracker.ts`. Exports `HintStabilityTracker` class and `HintStabilityData` interface. Implements all 3 RSLV requirements (10-12): per-site storage via `browserlet_hint_stability_{hostname}` key, aggregated counters (not individual events), +0.2 boost for >90% success rate hints. Storage bounded to 200 keys per site with 30-day decay. Uses browserCompat polyfill for Firefox compatibility. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Storage key follows pattern `browserlet_hint_stability_{hostname}` (consistent with codebase conventions)
- Uses `import { storage } from '../../../utils/storage/browserCompat'` (not direct `chrome.*`)
- Aggregated counters, not individual events (RSLV-11)
- Bounded to 200 keys per site (RSLV-11)
- Boost of +0.2 only when success rate > 90% AND >= 5 attempts (RSLV-12)
- Counter decay after 30 days prevents stale data
</verification>

<success_criteria>
- Per-site hint success/failure counts persist in chrome.storage.local (RSLV-10)
- Storage uses aggregated counters, not individual events (RSLV-11)
- Hints with >90% success rate and >= 5 attempts get +0.2 confidence boost (RSLV-12)
- Storage is bounded: max 200 keys per site, 30-day counter decay
- Class is instantiated with hostname and caches data for session lifetime
- Firefox compatible via browserCompat polyfill
</success_criteria>

<output>
After completion, create `.planning/phases/19/19-03-SUMMARY.md`
</output>
