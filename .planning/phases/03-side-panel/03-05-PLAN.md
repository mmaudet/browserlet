---
phase: 03-side-panel
plan: 05
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - entrypoints/sidepanel/components/ImportExport.ts
  - utils/yaml/parser.ts
autonomous: true

must_haves:
  truths:
    - "User can export a script as a YAML file"
    - "User can import a script from a YAML file"
    - "Invalid YAML files are rejected with error message"
  artifacts:
    - path: "entrypoints/sidepanel/components/ImportExport.ts"
      provides: "Import/export UI components"
      exports: ["ExportButton", "ImportButton"]
    - path: "utils/yaml/parser.ts"
      provides: "YAML parsing and validation"
      exports: ["parseScript", "dumpScript"]
  key_links:
    - from: "utils/yaml/parser.ts"
      to: "js-yaml"
      via: "yaml.load/dump"
      pattern: "yaml\\.(load|dump)"
    - from: "entrypoints/sidepanel/components/ImportExport.ts"
      to: "file-saver"
      via: "saveAs"
      pattern: "saveAs"
---

<objective>
Create import/export functionality for BSL scripts as YAML files.

Purpose: Enable users to share scripts and backup their work by exporting as YAML files and importing them back.
Output: Export button (downloads YAML), Import button (accepts YAML file), YAML parser with validation.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-side-panel/03-RESEARCH.md
@.planning/phases/03-side-panel/03-02-SUMMARY.md
@utils/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create YAML parser utilities</name>
  <files>utils/yaml/parser.ts</files>
  <action>
Create utils/yaml/parser.ts:

```typescript
import yaml from 'js-yaml';
import type { Script } from '../types';

export interface ParseResult {
  success: true;
  data: Partial<Script>;
} | {
  success: false;
  error: string;
};

// Parse YAML string to script-like object
export function parseScript(yamlContent: string): ParseResult {
  try {
    const parsed = yaml.load(yamlContent);

    if (typeof parsed !== 'object' || parsed === null) {
      return { success: false, error: 'Invalid YAML: expected an object' };
    }

    const obj = parsed as Record<string, unknown>;

    // Validate required fields
    if (!obj.name || typeof obj.name !== 'string') {
      return { success: false, error: 'Invalid BSL script: missing or invalid "name" field' };
    }

    if (!obj.steps || !Array.isArray(obj.steps)) {
      return { success: false, error: 'Invalid BSL script: missing or invalid "steps" array' };
    }

    // Construct partial Script (ID will be assigned on save)
    const script: Partial<Script> = {
      name: obj.name,
      content: yamlContent, // Store original YAML
      version: typeof obj.version === 'string' ? obj.version : '1.0.0',
      description: typeof obj.description === 'string' ? obj.description : undefined,
      target_app: typeof obj.target_app === 'string' ? obj.target_app : undefined,
      author: typeof obj.author === 'string' ? obj.author : undefined,
      tags: Array.isArray(obj.tags) ? obj.tags.filter((t): t is string => typeof t === 'string') : undefined,
    };

    return { success: true, data: script };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown parsing error';
    return { success: false, error: `YAML parsing failed: ${message}` };
  }
}

// Dump script to YAML string
export function dumpScript(script: Script): string {
  // If script has raw YAML content, return it directly
  if (script.content) {
    return script.content;
  }

  // Otherwise, construct YAML from metadata
  // This is a fallback; normally content is stored
  const obj: Record<string, unknown> = {
    name: script.name,
    version: script.version,
    steps: [] // Empty steps - content should normally exist
  };

  if (script.description) obj.description = script.description;
  if (script.target_app) obj.target_app = script.target_app;
  if (script.author) obj.author = script.author;
  if (script.tags && script.tags.length > 0) obj.tags = script.tags;

  return yaml.dump(obj, {
    indent: 2,
    lineWidth: -1, // No line wrapping
    noRefs: true   // No YAML anchors
  });
}

// Validate that parsed content has valid BSL structure
export function validateBSL(content: string): { valid: boolean; errors: string[] } {
  const result = parseScript(content);
  if (!result.success) {
    return { valid: false, errors: [result.error] };
  }

  // Additional validation can be added here for step structure
  // For now, basic validation is sufficient
  return { valid: true, errors: [] };
}
```
  </action>
  <verify>
1. parseScript('name: Test\nsteps: []') returns success
2. parseScript('invalid yaml ::') returns error
3. parseScript('foo: bar') returns error about missing name
4. dumpScript produces valid YAML
  </verify>
  <done>YAML parser with validation for BSL scripts.</done>
</task>

<task type="auto">
  <name>Task 2: Create Import/Export components</name>
  <files>entrypoints/sidepanel/components/ImportExport.ts</files>
  <action>
Create entrypoints/sidepanel/components/ImportExport.ts:

```typescript
import van from 'vanjs-core';
import { saveAs } from 'file-saver';
import type { Script } from '../../../utils/types';
import { parseScript, dumpScript } from '../../../utils/yaml/parser';
import { saveScript } from '../../../utils/storage/scripts';
import { loadScripts } from '../stores/scripts';

const { button, input, div, span } = van.tags;

interface ExportButtonProps {
  script: Script;
  className?: string;
}

export function ExportButton({ script, className }: ExportButtonProps) {
  const handleExport = () => {
    try {
      const yamlContent = dumpScript(script);
      const blob = new Blob([yamlContent], { type: 'text/yaml;charset=utf-8' });
      const filename = `${script.name.replace(/[^a-z0-9]/gi, '_')}.yaml`;
      saveAs(blob, filename);
    } catch (error) {
      console.error('Export failed:', error);
      alert(chrome.i18n.getMessage('exportFailed') || 'Failed to export script');
    }
  };

  return button({
    class: className || 'btn btn-secondary',
    onclick: handleExport,
    title: chrome.i18n.getMessage('exportScript') || 'Export as YAML'
  }, chrome.i18n.getMessage('export') || 'Export');
}

interface ImportButtonProps {
  onImport?: (script: Script) => void;
  className?: string;
}

export function ImportButton({ onImport, className }: ImportButtonProps) {
  const isImporting = van.state(false);
  const error = van.state<string | null>(null);

  const handleFileSelect = async (e: Event) => {
    const input = e.target as HTMLInputElement;
    const file = input.files?.[0];
    if (!file) return;

    isImporting.val = true;
    error.val = null;

    try {
      const content = await readFileAsText(file);
      const result = parseScript(content);

      if (!result.success) {
        error.val = result.error;
        return;
      }

      // Save imported script
      const savedScript = await saveScript({
        ...result.data,
        name: result.data.name!,
        version: result.data.version || '1.0.0',
        content: content
      });

      // Reload scripts list
      await loadScripts();

      // Notify parent
      onImport?.(savedScript);

      // Reset input
      input.value = '';
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Unknown error';
      error.val = `Import failed: ${message}`;
    } finally {
      isImporting.val = false;
    }
  };

  // Hidden file input + visible button
  const fileInput = input({
    type: 'file',
    accept: '.yaml,.yml',
    style: 'display: none;',
    onchange: handleFileSelect
  });

  return div({ style: 'display: inline-block;' },
    fileInput,
    button({
      class: className || 'btn btn-secondary',
      onclick: () => (fileInput as HTMLInputElement).click(),
      disabled: () => isImporting.val,
      title: chrome.i18n.getMessage('importScript') || 'Import YAML file'
    },
      () => isImporting.val
        ? chrome.i18n.getMessage('importing') || 'Importing...'
        : chrome.i18n.getMessage('import') || 'Import'
    ),
    () => error.val
      ? div({ style: 'color: #f44336; font-size: 12px; margin-top: 4px; max-width: 200px;' }, error.val)
      : null
  );
}

// Helper to read file as text with UTF-8
function readFileAsText(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsText(file, 'UTF-8');
  });
}
```
  </action>
  <verify>
1. ExportButton generates and downloads a .yaml file
2. ImportButton accepts .yaml file and saves to storage
3. Invalid YAML shows error message
4. After import, script appears in list
  </verify>
  <done>
- ExportButton downloads script as YAML file (STOR-02)
- ImportButton accepts and validates YAML file (STOR-03)
- Error handling for invalid files
  </done>
</task>

</tasks>

<verification>
1. Export a script - file downloads with .yaml extension
2. Import a valid YAML - script appears in list
3. Import invalid YAML - error message displayed
4. UTF-8 characters preserved in import/export cycle
</verification>

<success_criteria>
- Scripts can be exported as YAML files (STOR-02)
- Scripts can be imported from YAML files (STOR-03)
- Invalid files rejected with clear error message
</success_criteria>

<output>
After completion, create `.planning/phases/03-side-panel/03-05-SUMMARY.md`
</output>
