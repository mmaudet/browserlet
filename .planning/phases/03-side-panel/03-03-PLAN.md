---
phase: 03-side-panel
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - entrypoints/sidepanel/components/ScriptEditor.ts
  - entrypoints/sidepanel/monaco-setup.ts
autonomous: true

must_haves:
  truths:
    - "Monaco Editor loads with YAML syntax highlighting"
    - "Editor content can be get/set programmatically"
    - "Changes are auto-saved after debounce"
  artifacts:
    - path: "entrypoints/sidepanel/components/ScriptEditor.ts"
      provides: "Monaco editor wrapper component"
      exports: ["ScriptEditor", "getEditorContent", "setEditorContent"]
    - path: "entrypoints/sidepanel/monaco-setup.ts"
      provides: "Monaco configuration"
      contains: "configureMonacoYaml"
  key_links:
    - from: "entrypoints/sidepanel/components/ScriptEditor.ts"
      to: "monaco-editor"
      via: "editor.create"
      pattern: "monaco\\.editor\\.create"
---

<objective>
Create Monaco Editor component with YAML syntax highlighting for BSL script editing.

Purpose: Provide a professional code editor experience for editing BSL scripts with syntax highlighting and auto-save.
Output: ScriptEditor component wrapping Monaco with YAML support.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-side-panel/03-RESEARCH.md
@.planning/phases/03-side-panel/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Monaco setup and configuration</name>
  <files>entrypoints/sidepanel/monaco-setup.ts</files>
  <action>
Create entrypoints/sidepanel/monaco-setup.ts:

```typescript
import * as monaco from 'monaco-editor';
import { configureMonacoYaml } from 'monaco-yaml';

// Import YAML language contribution
import 'monaco-editor/esm/vs/basic-languages/yaml/yaml.contribution';

let configured = false;

// Configure Monaco YAML support (call once at app startup)
export function setupMonaco(): void {
  if (configured) return;

  configureMonacoYaml(monaco, {
    validate: true,
    format: true,
    hover: true,
    completion: true,
    schemas: [{
      uri: 'bsl://schema',
      fileMatch: ['*'],
      schema: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'Script name' },
          description: { type: 'string', description: 'Script description' },
          version: { type: 'string', description: 'Script version' },
          target_app: { type: 'string', description: 'Target application' },
          steps: {
            type: 'array',
            description: 'List of automation steps',
            items: {
              type: 'object',
              properties: {
                action: {
                  type: 'string',
                  enum: ['click', 'type', 'select', 'extract', 'wait_for', 'navigate', 'scroll', 'hover']
                },
                target: { type: 'object' },
                value: { type: 'string' }
              }
            }
          }
        },
        required: ['name', 'steps']
      }
    }]
  });

  configured = true;
}

export { monaco };
```

Note: The BSL schema is basic for now. It will be expanded in Phase 4 when we define the full BSL spec.
  </action>
  <verify>Import and call setupMonaco() - no runtime errors.</verify>
  <done>Monaco YAML configuration ready with basic BSL schema.</done>
</task>

<task type="auto">
  <name>Task 2: Create ScriptEditor component</name>
  <files>entrypoints/sidepanel/components/ScriptEditor.ts</files>
  <action>
Create entrypoints/sidepanel/components/ScriptEditor.ts:

```typescript
import van from 'vanjs-core';
import { monaco, setupMonaco } from '../monaco-setup';
import type { Script } from '../../../utils/types';
import { saveScript } from '../../../utils/storage/scripts';

const { div, button, span } = van.tags;

// Debounce helper
function debounce<T extends (...args: unknown[]) => void>(fn: T, ms: number): T {
  let timeout: ReturnType<typeof setTimeout>;
  return ((...args: unknown[]) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), ms);
  }) as T;
}

interface ScriptEditorProps {
  script: Script;
  onSave?: (script: Script) => void;
  onClose?: () => void;
}

// Module-level editor reference (Monaco instance is not serializable, keep in closure)
let editorInstance: monaco.editor.IStandaloneCodeEditor | null = null;

export function getEditorContent(): string {
  return editorInstance?.getValue() || '';
}

export function setEditorContent(content: string): void {
  editorInstance?.setValue(content);
}

export function ScriptEditor({ script, onSave, onClose }: ScriptEditorProps) {
  setupMonaco();

  const isSaving = van.state(false);
  const lastSaved = van.state<number>(script.updatedAt);

  // Create container and mount editor after DOM insertion
  const container = div({
    class: 'script-editor-container',
    style: 'display: flex; flex-direction: column; height: 100%;'
  },
    // Header
    div({ class: 'editor-header', style: 'display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #f5f5f5; border-bottom: 1px solid #ddd;' },
      span({ style: 'font-weight: 500;' }, script.name),
      div({ style: 'display: flex; gap: 8px; align-items: center;' },
        () => isSaving.val
          ? span({ style: 'font-size: 12px; color: #666;' }, chrome.i18n.getMessage('saving') || 'Saving...')
          : span({ style: 'font-size: 12px; color: #999;' },
              chrome.i18n.getMessage('lastSaved') || 'Saved'
            ),
        onClose && button({
          class: 'btn btn-secondary',
          style: 'padding: 4px 12px; font-size: 12px;',
          onclick: onClose
        }, chrome.i18n.getMessage('close') || 'Close')
      )
    ),
    // Editor container
    div({
      id: 'monaco-editor-container',
      style: 'flex: 1; min-height: 300px;'
    })
  );

  // Mount editor after container is in DOM
  requestAnimationFrame(() => {
    const editorContainer = document.getElementById('monaco-editor-container');
    if (!editorContainer) return;

    // Dispose previous instance if exists
    editorInstance?.dispose();

    editorInstance = monaco.editor.create(editorContainer, {
      value: script.content,
      language: 'yaml',
      theme: 'vs-light',
      minimap: { enabled: false },
      automaticLayout: true,
      fontSize: 13,
      lineNumbers: 'on',
      scrollBeyondLastLine: false,
      wordWrap: 'on',
      tabSize: 2,
      insertSpaces: true
    });

    // Auto-save on change (debounced)
    const autoSave = debounce(async () => {
      isSaving.val = true;
      try {
        const content = editorInstance?.getValue() || '';
        const updated = await saveScript({
          ...script,
          content,
          id: script.id
        });
        lastSaved.val = updated.updatedAt;
        onSave?.(updated);
      } catch (error) {
        console.error('Failed to save script:', error);
      } finally {
        isSaving.val = false;
      }
    }, 1000);

    editorInstance.onDidChangeModelContent(() => {
      autoSave();
    });
  });

  return container;
}

// Cleanup function to dispose editor
export function disposeEditor(): void {
  editorInstance?.dispose();
  editorInstance = null;
}
```

**CSS to add to sidepanel HTML later:**
- .btn-secondary { background: #e0e0e0; border: none; border-radius: 4px; cursor: pointer; }
  </action>
  <verify>
1. Import ScriptEditor and render with a mock script
2. Editor should display with YAML syntax highlighting
3. Changes should trigger auto-save after 1 second
  </verify>
  <done>
- ScriptEditor component created with Monaco YAML editor
- Auto-save on content change (debounced 1s)
- getEditorContent/setEditorContent exposed for external access
  </done>
</task>

</tasks>

<verification>
1. Monaco editor loads without console errors
2. YAML syntax highlighting works (keywords colored)
3. Typing triggers auto-save after 1 second debounce
4. Editor can be disposed and recreated without memory leaks
</verification>

<success_criteria>
- Monaco Editor integrated with YAML syntax highlighting (UI-03)
- Editor content accessible via exported functions
- Auto-save prevents data loss on panel close
</success_criteria>

<output>
After completion, create `.planning/phases/03-side-panel/03-03-SUMMARY.md`
</output>
