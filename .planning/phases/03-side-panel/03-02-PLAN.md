---
phase: 03-side-panel
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - utils/storage/scripts.ts
  - utils/storage/history.ts
  - utils/types.ts
autonomous: true

must_haves:
  truths:
    - "Scripts can be saved to chrome.storage.local"
    - "Scripts can be retrieved with search/filter"
    - "Execution history is capped at 50 entries per script"
  artifacts:
    - path: "utils/storage/scripts.ts"
      provides: "Script CRUD operations"
      exports: ["saveScript", "getScripts", "deleteScript", "searchScripts"]
    - path: "utils/storage/history.ts"
      provides: "Execution history storage"
      exports: ["addExecutionRecord", "getExecutionHistory"]
    - path: "utils/types.ts"
      provides: "Script and ExecutionRecord types"
      contains: "interface Script"
  key_links:
    - from: "utils/storage/scripts.ts"
      to: "chrome.storage.local"
      via: "get/set operations"
      pattern: "chrome\\.storage\\.local\\.(get|set)"
---

<objective>
Create Script type definitions and storage utilities for script persistence and execution history.

Purpose: Establish the data layer for script management before building UI components that consume it.
Output: Script interface, CRUD operations, and execution history with 50-entry cap.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-side-panel/03-RESEARCH.md
@utils/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Script and ExecutionRecord types</name>
  <files>utils/types.ts</files>
  <action>
Add to existing utils/types.ts:

```typescript
// Script metadata (STOR-04)
export interface Script {
  id: string;                    // UUID
  name: string;                  // Required, display name
  description?: string;          // Optional description
  version: string;               // Semantic version
  target_app?: string;           // Target application name
  author?: string;               // Author name
  tags?: string[];               // Searchable tags
  content: string;               // YAML content (BSL script)
  createdAt: number;             // Timestamp
  updatedAt: number;             // Timestamp
}

// Execution history (STOR-05)
export interface ExecutionRecord {
  id: string;                    // UUID
  scriptId: string;              // Reference to script
  scriptName: string;            // Denormalized for history
  startedAt: number;             // Start timestamp
  completedAt?: number;          // End timestamp (undefined if running)
  status: 'running' | 'completed' | 'failed' | 'stopped';
  currentStep?: number;          // Current step index (for progress)
  totalSteps?: number;           // Total steps in script
  results?: unknown;             // Extracted data
  error?: string;                // Error message if failed
}
```

Use `crypto.randomUUID()` for ID generation in storage functions.
  </action>
  <verify>Run `npx tsc --noEmit` to verify types compile.</verify>
  <done>Script and ExecutionRecord interfaces defined with all STOR-04 metadata fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create script storage operations</name>
  <files>utils/storage/scripts.ts</files>
  <action>
Create utils/storage/scripts.ts with:

```typescript
import type { Script } from '../types';

const SCRIPTS_KEY = 'browserlet_scripts';

// Get all scripts
export async function getScripts(): Promise<Script[]> {
  const result = await chrome.storage.local.get(SCRIPTS_KEY);
  return result[SCRIPTS_KEY] || [];
}

// Get single script by ID
export async function getScript(id: string): Promise<Script | undefined> {
  const scripts = await getScripts();
  return scripts.find(s => s.id === id);
}

// Save script (create or update)
export async function saveScript(script: Omit<Script, 'id' | 'createdAt' | 'updatedAt'> & { id?: string }): Promise<Script> {
  const scripts = await getScripts();
  const now = Date.now();

  if (script.id) {
    // Update existing
    const index = scripts.findIndex(s => s.id === script.id);
    if (index >= 0) {
      const updated: Script = {
        ...scripts[index],
        ...script,
        id: script.id,
        updatedAt: now
      };
      scripts[index] = updated;
      await chrome.storage.local.set({ [SCRIPTS_KEY]: scripts });
      return updated;
    }
  }

  // Create new
  const newScript: Script = {
    ...script,
    id: crypto.randomUUID(),
    createdAt: now,
    updatedAt: now
  } as Script;

  await chrome.storage.local.set({ [SCRIPTS_KEY]: [...scripts, newScript] });
  return newScript;
}

// Delete script
export async function deleteScript(id: string): Promise<void> {
  const scripts = await getScripts();
  const filtered = scripts.filter(s => s.id !== id);
  await chrome.storage.local.set({ [SCRIPTS_KEY]: filtered });
}

// Search scripts (UI-02: by name, app, tag)
export async function searchScripts(query: string): Promise<Script[]> {
  const scripts = await getScripts();
  if (!query.trim()) return scripts;

  const q = query.toLowerCase();
  return scripts.filter(s =>
    s.name.toLowerCase().includes(q) ||
    s.description?.toLowerCase().includes(q) ||
    s.target_app?.toLowerCase().includes(q) ||
    s.tags?.some(t => t.toLowerCase().includes(q))
  );
}
```
  </action>
  <verify>
Create a simple test: save a script, retrieve it, search for it, delete it.
Run `npx tsc --noEmit` to verify no type errors.
  </verify>
  <done>Script CRUD operations implemented with search/filter by name, app, and tags.</done>
</task>

<task type="auto">
  <name>Task 3: Create execution history storage</name>
  <files>utils/storage/history.ts</files>
  <action>
Create utils/storage/history.ts with:

```typescript
import type { ExecutionRecord } from '../types';

const HISTORY_PREFIX = 'browserlet_history_';
const MAX_HISTORY_PER_SCRIPT = 50;

// Get history key for a script
function historyKey(scriptId: string): string {
  return `${HISTORY_PREFIX}${scriptId}`;
}

// Get execution history for a script (most recent first)
export async function getExecutionHistory(scriptId: string): Promise<ExecutionRecord[]> {
  const key = historyKey(scriptId);
  const result = await chrome.storage.local.get(key);
  return result[key] || [];
}

// Add execution record (caps at 50 per script)
export async function addExecutionRecord(record: Omit<ExecutionRecord, 'id'>): Promise<ExecutionRecord> {
  const key = historyKey(record.scriptId);
  const history = await getExecutionHistory(record.scriptId);

  const newRecord: ExecutionRecord = {
    ...record,
    id: crypto.randomUUID()
  };

  // Prepend new record, cap at MAX_HISTORY
  const updated = [newRecord, ...history].slice(0, MAX_HISTORY_PER_SCRIPT);
  await chrome.storage.local.set({ [key]: updated });

  return newRecord;
}

// Update execution record (for status changes during execution)
export async function updateExecutionRecord(
  scriptId: string,
  recordId: string,
  updates: Partial<ExecutionRecord>
): Promise<void> {
  const key = historyKey(scriptId);
  const history = await getExecutionHistory(scriptId);

  const index = history.findIndex(r => r.id === recordId);
  if (index >= 0) {
    history[index] = { ...history[index], ...updates };
    await chrome.storage.local.set({ [key]: history });
  }
}

// Clear history for a script
export async function clearExecutionHistory(scriptId: string): Promise<void> {
  const key = historyKey(scriptId);
  await chrome.storage.local.remove(key);
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors.
Test: add 51 records, verify only 50 are kept.
  </verify>
  <done>Execution history storage with 50-entry cap per script.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Script CRUD operations work in isolation
3. History is properly capped at 50 entries
4. Search filters by name, target_app, and tags
</verification>

<success_criteria>
- Script interface includes all STOR-04 metadata fields
- Scripts can be saved, retrieved, updated, and deleted
- Scripts can be searched by name, app, and tags (UI-02)
- Execution history capped at 50 per script (STOR-05)
</success_criteria>

<output>
After completion, create `.planning/phases/03-side-panel/03-02-SUMMARY.md`
</output>
