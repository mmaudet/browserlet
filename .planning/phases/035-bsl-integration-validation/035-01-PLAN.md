---
phase: 035-bsl-integration-validation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/core/src/types/bsl.ts
  - packages/core/src/types/index.ts
  - packages/core/src/parser/stepParser.ts
  - tests/utils/yaml/stepParser.test.ts
  - utils/yaml/parser.ts
autonomous: true

must_haves:
  truths:
    - "BSL script with session_persistence block parses without error"
    - "BSL script without session_persistence field still parses without error (backward compatibility)"
    - "Invalid session_persistence declarations produce clear validation errors"
    - "Imported BSL script in extension preserves session_persistence as Script.sessionPersistence"
  artifacts:
    - path: "packages/core/src/types/bsl.ts"
      provides: "SessionPersistenceConfig interface and sessionPersistence field on ParsedScript"
      contains: "SessionPersistenceConfig"
    - path: "packages/core/src/parser/stepParser.ts"
      provides: "parseSessionPersistence validation function"
      contains: "parseSessionPersistence"
    - path: "tests/utils/yaml/stepParser.test.ts"
      provides: "Test coverage for session_persistence parsing"
      contains: "session_persistence"
  key_links:
    - from: "packages/core/src/parser/stepParser.ts"
      to: "packages/core/src/types/bsl.ts"
      via: "import SessionPersistenceConfig"
      pattern: "SessionPersistenceConfig"
    - from: "utils/yaml/parser.ts"
      to: "Script.sessionPersistence"
      via: "extracting session_persistence from YAML during import"
      pattern: "sessionPersistence"
---

<objective>
Add session_persistence as a first-class BSL metadata field: define the TypeScript interface, implement parser validation following the existing parseSessionCheck pattern, add comprehensive tests, and bridge the field to extension Script type during import.

Purpose: BSL-01 (declare session_persistence) and BSL-02 (parser validates and exposes to execution engine). Also bridges parsed metadata to extension Script type on import so existing execution.ts session logic works automatically.

Output: SessionPersistenceConfig type, parseSessionPersistence function, parser tests, extension import bridge
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/035-bsl-integration-validation/035-RESEARCH.md

@packages/core/src/types/bsl.ts
@packages/core/src/parser/stepParser.ts
@packages/core/src/types/index.ts
@tests/utils/yaml/stepParser.test.ts
@utils/yaml/parser.ts
@utils/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SessionPersistenceConfig type and parser validation</name>
  <files>
    packages/core/src/types/bsl.ts
    packages/core/src/types/index.ts
    packages/core/src/parser/stepParser.ts
  </files>
  <action>
    1. In `packages/core/src/types/bsl.ts`:
       - Add `SessionPersistenceConfig` interface after `SessionCheckConfig` (around line 66):
         ```typescript
         export interface SessionPersistenceConfig {
           enabled: boolean;
           max_age?: string;      // e.g., "72h", "30d"
           snapshot_id?: string;  // Custom session identifier
         }
         ```
       - Add `sessionPersistence?: SessionPersistenceConfig` to `ParsedScript` interface (after `session_check?` field)
       - Add JSDoc comment documenting the BSL YAML mapping: `session_persistence` (snake_case YAML) maps to `sessionPersistence` (camelCase TS)

    2. In `packages/core/src/types/index.ts`:
       - Add `SessionPersistenceConfig` to the export list from `'./bsl.js'`

    3. In `packages/core/src/parser/stepParser.ts`:
       - Import `SessionPersistenceConfig` from types
       - Add `parseSessionPersistence(rawConfig: unknown): SessionPersistenceConfig | undefined` function after `parseSessionCheck` (after line 205). Follow EXACT same pattern as parseSessionCheck:
         - Return undefined if rawConfig is null/undefined/not-object
         - Validate `enabled` field: must be boolean, throw descriptive Error if not
         - Validate `max_age` if present: must be non-empty string, throw descriptive Error if not. Syntactic validation only (no ms library call - parser is shared code, semantic validation happens in execution engines)
         - Validate `snapshot_id` if present: must be non-empty string, throw descriptive Error if not
         - Return validated SessionPersistenceConfig
       - In `parseSteps()` function, after the session_check extraction (after line 316), add:
         ```typescript
         const sessionPersistence = parseSessionPersistence(rawScript.session_persistence);
         if (sessionPersistence) {
           script.sessionPersistence = sessionPersistence;
         }
         ```
  </action>
  <verify>
    Run `npx vitest run tests/utils/yaml/stepParser.test.ts` and confirm existing tests still pass (backward compatibility).
    Run `npx tsc --noEmit -p packages/core/tsconfig.json` to verify types compile.
  </verify>
  <done>
    SessionPersistenceConfig type exists and is exported. parseSessionPersistence function validates BSL session_persistence blocks. ParsedScript has optional sessionPersistence field. All existing parser tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add parser tests for session_persistence and bridge to extension import</name>
  <files>
    tests/utils/yaml/stepParser.test.ts
    utils/yaml/parser.ts
  </files>
  <action>
    1. In `tests/utils/yaml/stepParser.test.ts`, add a new `describe('session_persistence parsing')` block after the existing session_check test (around line 108). Tests to write (RED first, then GREEN):

       **Valid cases:**
       - "should parse session_persistence with all fields" — BSL with `session_persistence: {enabled: true, max_age: "72h", snapshot_id: "myapp"}` → expect `result.sessionPersistence` to deep equal `{enabled: true, max_age: "72h", snapshot_id: "myapp"}`
       - "should parse session_persistence with enabled only" — BSL with `session_persistence: {enabled: true}` → expect `result.sessionPersistence` to equal `{enabled: true}`
       - "should parse session_persistence with enabled false" — BSL with `session_persistence: {enabled: false}` → expect `result.sessionPersistence` to equal `{enabled: false}`
       - "should return undefined sessionPersistence when field absent" — BSL without session_persistence → expect `result.sessionPersistence` to be undefined

       **Error cases:**
       - "should throw error for non-boolean enabled" — `session_persistence: {enabled: "yes"}` → expect throw matching `session_persistence.enabled must be a boolean`
       - "should throw error for non-string max_age" — `session_persistence: {enabled: true, max_age: 72}` → expect throw matching `session_persistence.max_age must be a string`
       - "should throw error for empty snapshot_id" — `session_persistence: {enabled: true, snapshot_id: ""}` → expect throw matching `session_persistence.snapshot_id must be a non-empty string`

    2. In `utils/yaml/parser.ts` (extension import parser), update `parseScript()` to extract `session_persistence`:
       - After the tags extraction (line 40), add:
         ```typescript
         // Extract session_persistence if present (maps to Script.sessionPersistence)
         if (obj.session_persistence && typeof obj.session_persistence === 'object') {
           const sp = obj.session_persistence as Record<string, unknown>;
           if (typeof sp.enabled === 'boolean') {
             script.sessionPersistence = {
               enabled: sp.enabled,
               ...(typeof sp.ttl === 'number' ? { ttl: sp.ttl } : {}),
             };
           }
         }
         ```
       - Note: Extension Script.sessionPersistence uses `{ enabled: boolean; ttl?: number }` (line 109-112 of utils/types.ts), which is different from ParsedScript.sessionPersistence which uses `{ enabled: boolean; max_age?: string; snapshot_id?: string }`. The extension stores its own format. For import, map enabled directly; ttl is not set from BSL (it uses its own default). The key behavior is: importing a BSL with `session_persistence: {enabled: true}` should set Script.sessionPersistence.enabled = true so execution.ts auto-capture/restore works.
  </action>
  <verify>
    Run `npx vitest run tests/utils/yaml/stepParser.test.ts` — all 7 new tests pass plus existing tests unchanged.
    Run `npx vitest run` — full test suite passes (no regressions).
  </verify>
  <done>
    7 new tests cover session_persistence parsing (4 valid, 3 error). Extension import parser extracts session_persistence from BSL YAML into Script.sessionPersistence. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run tests/utils/yaml/stepParser.test.ts` — all tests pass including new session_persistence tests
2. `npx tsc --noEmit -p packages/core/tsconfig.json` — core types compile without errors
3. `npx vitest run` — full test suite passes (no regressions from parser changes)
4. Verify backward compatibility: existing BSL examples in packages/cli/examples/ parse without error
</verification>

<success_criteria>
- SessionPersistenceConfig type defined and exported from @browserlet/core
- parseSessionPersistence validates enabled (boolean, required), max_age (string, optional), snapshot_id (string, optional)
- ParsedScript.sessionPersistence populated when session_persistence present in BSL YAML
- Extension import (utils/yaml/parser.ts) maps session_persistence to Script.sessionPersistence
- 7+ new tests for session_persistence parsing
- All existing tests pass (backward compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/035-bsl-integration-validation/035-01-SUMMARY.md`
</output>
