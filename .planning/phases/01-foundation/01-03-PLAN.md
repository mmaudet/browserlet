---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - vitest.config.ts
  - tests/background/storage.test.ts
  - tests/background/messaging.test.ts
  - tests/content/context-check.test.ts
autonomous: false

must_haves:
  truths:
    - "Unit tests pass for storage operations"
    - "Unit tests pass for message routing"
    - "Unit tests pass for context validation"
    - "Extension passes manual E2E verification"
  artifacts:
    - path: "vitest.config.ts"
      provides: "Vitest configuration for WXT"
      contains: "defineConfig"
    - path: "tests/background/storage.test.ts"
      provides: "Storage operation tests"
      contains: "getState"
    - path: "tests/background/messaging.test.ts"
      provides: "Message routing tests"
      contains: "handleMessage"
    - path: "tests/content/context-check.test.ts"
      provides: "Context validation tests"
      contains: "isContextValid"
  key_links:
    - from: "tests/background/storage.test.ts"
      to: "entrypoints/background/storage.ts"
      via: "import storage functions"
      pattern: "import.*storage"
    - from: "tests/background/messaging.test.ts"
      to: "entrypoints/background/messaging.ts"
      via: "import handleMessage"
      pattern: "import.*handleMessage"
---

<objective>
Add unit tests for storage, messaging, and context validation, then perform manual E2E verification of all Phase 1 success criteria.

Purpose: Validate that the foundation infrastructure works correctly before building Phase 2 on top of it. Tests ensure regressions are caught early. Manual verification confirms real-world behavior.

Output: Passing test suite and verified extension matching all Phase 1 success criteria.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Vitest and Add Unit Tests</name>
  <files>
    vitest.config.ts
    tests/background/storage.test.ts
    tests/background/messaging.test.ts
    tests/content/context-check.test.ts
    package.json
  </files>
  <action>
Set up Vitest with WXT's fake-browser for Chrome API mocking:

1. **Install test dependencies:**
```bash
npm install -D vitest @vitest/ui
```

2. **Create vitest.config.ts** in project root:
```typescript
import { defineConfig } from 'vitest/config';
import { WxtVitest } from 'wxt/testing';

export default defineConfig({
  test: {
    // Use WXT's test plugin for fake-browser
    ...WxtVitest(),
    // Test file patterns
    include: ['tests/**/*.test.ts'],
    // Environment
    environment: 'node',
    // Coverage (optional)
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html'],
      include: ['entrypoints/**/*.ts', 'utils/**/*.ts'],
    },
  },
});
```

3. **Add test script to package.json:**
```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  }
}
```

4. **tests/background/storage.test.ts** - Storage tests:
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { fakeBrowser } from 'wxt/testing';

// Import after fake-browser is set up
import { getState, setState, initializeState } from '../../entrypoints/background/storage';

describe('Storage Operations', () => {
  beforeEach(() => {
    // Reset fake browser state before each test
    fakeBrowser.reset();
  });

  describe('initializeState', () => {
    it('should initialize default state when storage is empty', async () => {
      await initializeState();

      const result = await chrome.storage.local.get('appState');
      expect(result.appState).toBeDefined();
      expect(result.appState.version).toBe('0.1.0');
      expect(result.appState.firstInstall).toBeGreaterThan(0);
    });

    it('should not overwrite existing state', async () => {
      const existingState = {
        version: '0.0.9',
        firstInstall: 12345,
        lastActivity: 0,
      };
      await chrome.storage.local.set({ appState: existingState });

      await initializeState();

      const result = await chrome.storage.local.get('appState');
      expect(result.appState.version).toBe('0.0.9');
      expect(result.appState.firstInstall).toBe(12345);
    });
  });

  describe('getState', () => {
    it('should return default state when storage is empty', async () => {
      const state = await getState();

      expect(state.version).toBe('0.1.0');
      expect(state.firstInstall).toBe(0);
    });

    it('should return stored state', async () => {
      const storedState = {
        version: '1.0.0',
        firstInstall: 99999,
        lastActivity: 88888,
      };
      await chrome.storage.local.set({ appState: storedState });

      const state = await getState();

      expect(state).toEqual(storedState);
    });
  });

  describe('setState', () => {
    it('should merge partial state with existing state', async () => {
      await initializeState();
      const beforeUpdate = await getState();

      const updated = await setState({ version: '2.0.0' });

      expect(updated.version).toBe('2.0.0');
      expect(updated.firstInstall).toBe(beforeUpdate.firstInstall);
      expect(updated.lastActivity).toBeGreaterThan(0);
    });

    it('should update lastActivity timestamp', async () => {
      const before = Date.now();
      await setState({ version: '1.0.0' });
      const after = Date.now();

      const state = await getState();

      expect(state.lastActivity).toBeGreaterThanOrEqual(before);
      expect(state.lastActivity).toBeLessThanOrEqual(after);
    });

    it('should persist state to storage', async () => {
      await setState({ version: '3.0.0' });

      // Directly check storage (simulating service worker restart)
      const result = await chrome.storage.local.get('appState');
      expect(result.appState.version).toBe('3.0.0');
    });
  });
});
```

5. **tests/background/messaging.test.ts** - Messaging tests:
```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { fakeBrowser } from 'wxt/testing';

import { handleMessage } from '../../entrypoints/background/messaging';

describe('Message Routing', () => {
  beforeEach(() => {
    fakeBrowser.reset();
  });

  const createMockSender = (): chrome.runtime.MessageSender => ({
    id: 'test-extension-id',
    url: 'https://example.com',
    tab: { id: 1, index: 0, pinned: false, highlighted: false, windowId: 1, active: true, incognito: false, selected: false, discarded: false, autoDiscardable: true, groupId: -1 },
  });

  describe('PING message', () => {
    it('should respond with success and timestamp', async () => {
      const sendResponse = vi.fn();
      const before = Date.now();

      handleMessage({ type: 'PING' }, createMockSender(), sendResponse);

      // Wait for async processing
      await new Promise(resolve => setTimeout(resolve, 10));

      expect(sendResponse).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true,
          data: expect.objectContaining({
            status: 'ok',
            timestamp: expect.any(Number),
          }),
        })
      );

      const response = sendResponse.mock.calls[0][0];
      expect(response.data.timestamp).toBeGreaterThanOrEqual(before);
    });
  });

  describe('GET_STATE message', () => {
    it('should return current app state', async () => {
      // Set up initial state
      await chrome.storage.local.set({
        appState: { version: '1.0.0', firstInstall: 12345, lastActivity: 0 }
      });

      const sendResponse = vi.fn();
      handleMessage({ type: 'GET_STATE' }, createMockSender(), sendResponse);

      await new Promise(resolve => setTimeout(resolve, 10));

      expect(sendResponse).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true,
          data: expect.objectContaining({
            version: '1.0.0',
            firstInstall: 12345,
          }),
        })
      );
    });
  });

  describe('SET_STATE message', () => {
    it('should update state and return updated value', async () => {
      const sendResponse = vi.fn();

      handleMessage(
        { type: 'SET_STATE', payload: { version: '2.0.0' } },
        createMockSender(),
        sendResponse
      );

      await new Promise(resolve => setTimeout(resolve, 10));

      expect(sendResponse).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true,
          data: expect.objectContaining({
            version: '2.0.0',
          }),
        })
      );
    });
  });

  describe('Unknown message type', () => {
    it('should return error for unknown message type', async () => {
      const sendResponse = vi.fn();

      handleMessage({ type: 'UNKNOWN_TYPE' as any }, createMockSender(), sendResponse);

      await new Promise(resolve => setTimeout(resolve, 10));

      expect(sendResponse).toHaveBeenCalledWith(
        expect.objectContaining({
          success: false,
          error: expect.stringContaining('Unknown message type'),
        })
      );
    });
  });

  describe('handleMessage return value', () => {
    it('should return true to keep message channel open', () => {
      const result = handleMessage({ type: 'PING' }, createMockSender(), vi.fn());
      expect(result).toBe(true);
    });
  });
});
```

6. **tests/content/context-check.test.ts** - Context validation tests:
```typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';

// Note: These tests use manual mocking since context-check.ts
// accesses chrome.runtime directly, not through fake-browser's proxy

describe('Context Validation', () => {
  let originalChrome: typeof chrome;

  beforeEach(() => {
    // Store original chrome object
    originalChrome = globalThis.chrome;
  });

  afterEach(() => {
    // Restore original chrome object
    globalThis.chrome = originalChrome;
    // Clean up any DOM modifications
    document.getElementById('browserlet-update-banner')?.remove();
  });

  describe('isContextValid', () => {
    it('should return true when chrome.runtime.id is defined', async () => {
      // Mock chrome.runtime with valid id
      globalThis.chrome = {
        runtime: { id: 'test-extension-id' },
      } as typeof chrome;

      const { isContextValid } = await import('../../utils/context-check');
      expect(isContextValid()).toBe(true);
    });

    it('should return false when chrome.runtime.id is undefined', async () => {
      // Mock chrome.runtime with undefined id (context invalidated)
      globalThis.chrome = {
        runtime: { id: undefined },
      } as typeof chrome;

      // Re-import to get fresh module
      vi.resetModules();
      const { isContextValid } = await import('../../utils/context-check');
      expect(isContextValid()).toBe(false);
    });

    it('should return false when chrome.runtime is undefined', async () => {
      // Mock chrome without runtime
      globalThis.chrome = {} as typeof chrome;

      vi.resetModules();
      const { isContextValid } = await import('../../utils/context-check');
      expect(isContextValid()).toBe(false);
    });
  });

  describe('showUpdateBanner', () => {
    beforeEach(() => {
      // Set up minimal DOM
      document.body.innerHTML = '';
    });

    it('should create banner element in DOM', async () => {
      const { showUpdateBanner } = await import('../../utils/context-check');

      showUpdateBanner();

      const banner = document.getElementById('browserlet-update-banner');
      expect(banner).not.toBeNull();
      expect(banner?.textContent).toContain('Browserlet');
      expect(banner?.textContent).toContain('refresh');
    });

    it('should not create duplicate banners', async () => {
      const { showUpdateBanner } = await import('../../utils/context-check');

      showUpdateBanner();
      showUpdateBanner();
      showUpdateBanner();

      const banners = document.querySelectorAll('#browserlet-update-banner');
      expect(banners.length).toBe(1);
    });

    it('should have refresh button that reloads page', async () => {
      const { showUpdateBanner } = await import('../../utils/context-check');
      const reloadMock = vi.fn();
      Object.defineProperty(window, 'location', {
        value: { reload: reloadMock },
        writable: true,
      });

      showUpdateBanner();

      const refreshBtn = document.getElementById('browserlet-refresh-btn');
      expect(refreshBtn).not.toBeNull();
      refreshBtn?.click();
      expect(reloadMock).toHaveBeenCalled();
    });

    it('should have dismiss button that removes banner', async () => {
      const { showUpdateBanner } = await import('../../utils/context-check');

      showUpdateBanner();
      expect(document.getElementById('browserlet-update-banner')).not.toBeNull();

      const dismissBtn = document.getElementById('browserlet-dismiss-btn');
      dismissBtn?.click();

      expect(document.getElementById('browserlet-update-banner')).toBeNull();
    });
  });
});
```

7. **Run tests:**
```bash
npm test
```
  </action>
  <verify>
1. `npm test` runs without configuration errors
2. All tests pass (should see green checkmarks)
3. No TypeScript errors in test files
4. `npm run test:ui` opens Vitest UI showing test results (optional, for visual verification)
  </verify>
  <done>
Vitest configured with WXT's fake-browser. Unit tests cover storage operations (init, get, set), message routing (PING, GET_STATE, SET_STATE, unknown), and context validation (isContextValid, showUpdateBanner). All tests pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Manual E2E Verification</name>
  <what-built>
Complete Phase 1 foundation infrastructure:
- WXT-based Chrome extension
- Service worker with message routing and state persistence
- Content script with context invalidation detection
- Side panel with real-time state display
- Unit test suite
  </what-built>
  <how-to-verify>
Please verify each of the Phase 1 success criteria:

**1. Extension loads in Chrome and appears in extensions list**
   - Open chrome://extensions
   - Enable Developer mode (toggle in top-right)
   - Click "Load unpacked" and select `.output/chrome-mv3` directory
   - Verify "Browserlet" appears in the list with no errors
   - [ ] PASS / FAIL

**2. Service worker receives and routes messages between components**
   - Click "service worker" link on Browserlet extension card
   - In service worker console, verify "[Browserlet] Service worker started" message
   - Run: `chrome.runtime.sendMessage({type: 'PING'}, console.log)`
   - Verify response: `{success: true, data: {status: 'ok', timestamp: ...}}`
   - [ ] PASS / FAIL

**3. Extension state persists across browser restarts**
   - In service worker console: `chrome.storage.local.get('appState', console.log)`
   - Note the `firstInstall` timestamp
   - Close and reopen Chrome completely
   - Go to chrome://extensions, click service worker
   - Run same command - `firstInstall` should be unchanged
   - [ ] PASS / FAIL

**4. Context invalidation is detected and communicated to user**
   - Open any webpage (e.g., https://example.com)
   - Open page DevTools, verify content script loaded message
   - Go to chrome://extensions
   - Click "reload" button on Browserlet
   - Return to the webpage tab
   - Trigger a Browserlet action (or wait for automatic retry)
   - Orange banner should appear: "Browserlet was updated. Please refresh this page."
   - [ ] PASS / FAIL

**5. All communication patterns work**
   - Open a webpage, click Browserlet icon to open side panel
   - Side panel should show "Connected" and app state JSON
   - In webpage DevTools console: verify content script loaded
   - In side panel, click "Ping Service Worker" - timestamp updates
   - In service worker console: `chrome.storage.local.set({appState: {...await chrome.storage.local.get('appState').then(r=>r.appState), testField: 'hello'}})`
   - Side panel should automatically update to show `testField`
   - [ ] PASS / FAIL

**Overall Result:**
All 5 criteria passing = Phase 1 complete
Any failures = describe issues
  </how-to-verify>
  <resume-signal>
Type "approved" if all 5 criteria pass.
If any fail, describe which ones and what went wrong.
  </resume-signal>
</task>

</tasks>

<verification>
After both tasks complete:

**Unit Tests:**
```bash
npm test
# All tests should pass
```

**Manual Verification:**
All 5 Phase 1 success criteria verified by human.
</verification>

<success_criteria>
- Vitest configured and running with WXT's fake-browser
- All unit tests pass (storage, messaging, context-check)
- Human verifies: Extension loads in Chrome
- Human verifies: Service worker routes messages
- Human verifies: State persists across restarts
- Human verifies: Context invalidation shows banner
- Human verifies: All communication patterns work
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
