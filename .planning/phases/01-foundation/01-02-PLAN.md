---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - entrypoints/content/index.ts
  - entrypoints/content/messaging.ts
  - entrypoints/sidepanel/index.html
  - entrypoints/sidepanel/main.ts
  - utils/context-check.ts
autonomous: true

must_haves:
  truths:
    - "Content script injects on all URLs"
    - "Content script can send messages to service worker"
    - "Content script detects context invalidation and shows banner"
    - "Side panel opens from extension action"
    - "Side panel receives storage change notifications"
  artifacts:
    - path: "entrypoints/content/index.ts"
      provides: "Content script entry point"
      contains: "defineContentScript"
    - path: "entrypoints/content/messaging.ts"
      provides: "Safe messaging with retry logic"
      exports: ["sendMessageSafe"]
    - path: "entrypoints/sidepanel/index.html"
      provides: "Side panel HTML entry"
      contains: "sidepanel"
    - path: "entrypoints/sidepanel/main.ts"
      provides: "Side panel logic"
      contains: "chrome.storage.onChanged"
    - path: "utils/context-check.ts"
      provides: "Context invalidation detection"
      exports: ["isContextValid", "showUpdateBanner"]
  key_links:
    - from: "entrypoints/content/messaging.ts"
      to: "utils/context-check.ts"
      via: "import isContextValid"
      pattern: "import.*isContextValid.*context-check"
    - from: "entrypoints/content/messaging.ts"
      to: "chrome.runtime.sendMessage"
      via: "sendMessageSafe wrapper"
      pattern: "chrome\\.runtime\\.sendMessage"
    - from: "entrypoints/sidepanel/main.ts"
      to: "chrome.storage.onChanged"
      via: "storage listener"
      pattern: "chrome\\.storage\\.onChanged\\.addListener"
---

<objective>
Implement content script with context invalidation handling and side panel stub that receives state updates via chrome.storage.onChanged.

Purpose: Complete the messaging triangle (service worker <-> content script <-> side panel). Content script handles context invalidation gracefully - critical for extension updates during recording sessions. Side panel provides the UI surface for Phase 3.

Output: Content script that safely communicates with service worker, side panel that displays state.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Content Script with Context Invalidation Handling</name>
  <files>
    entrypoints/content/index.ts
    entrypoints/content/messaging.ts
    utils/context-check.ts
  </files>
  <action>
Create content script with robust context invalidation detection and retry logic:

1. **utils/context-check.ts** - Context validation utilities:
```typescript
/**
 * Check if extension context is still valid.
 * Returns false when extension has been updated/reloaded while content script is running.
 */
export function isContextValid(): boolean {
  try {
    // chrome.runtime.id is undefined when context is invalidated
    return !!chrome.runtime?.id;
  } catch {
    return false;
  }
}

/**
 * Display a non-intrusive banner prompting user to refresh the page.
 */
export function showUpdateBanner(): void {
  // Prevent duplicate banners
  if (document.getElementById('browserlet-update-banner')) return;

  const banner = document.createElement('div');
  banner.id = 'browserlet-update-banner';
  banner.innerHTML = `
    <div style="display: flex; align-items: center; justify-content: center; gap: 12px;">
      <span>Browserlet was updated. Please refresh this page to continue.</span>
      <button id="browserlet-refresh-btn" style="
        background: white;
        color: #f57c00;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
      ">Refresh Now</button>
      <button id="browserlet-dismiss-btn" style="
        background: transparent;
        color: white;
        border: 1px solid white;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
      ">Dismiss</button>
    </div>
  `;
  banner.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, #f57c00, #ff9800);
    color: white;
    padding: 12px 16px;
    z-index: 2147483647;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 14px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  `;

  document.body.prepend(banner);

  document.getElementById('browserlet-refresh-btn')?.addEventListener('click', () => {
    location.reload();
  });

  document.getElementById('browserlet-dismiss-btn')?.addEventListener('click', () => {
    banner.remove();
  });
}
```

2. **entrypoints/content/messaging.ts** - Safe messaging with retry:
```typescript
import type { Message, MessageResponse } from '../../utils/types';
import { isContextValid, showUpdateBanner } from '../../utils/context-check';

const MAX_RETRIES = 3;
const RETRY_DELAY_BASE_MS = 100;

/**
 * Send message to service worker with automatic retry and context invalidation handling.
 *
 * @throws Error if context is permanently invalidated (extension updated)
 */
export async function sendMessageSafe<T = unknown>(
  message: Message,
  retries = MAX_RETRIES
): Promise<MessageResponse<T>> {
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      // Check context before attempting to send
      if (!isContextValid()) {
        throw new Error('Extension context invalidated');
      }

      const response = await chrome.runtime.sendMessage(message);
      return response as MessageResponse<T>;

    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : String(error);

      const isContextError =
        errorMessage.includes('Extension context invalidated') ||
        errorMessage.includes('Receiving end does not exist') ||
        errorMessage.includes('Could not establish connection');

      if (isContextError) {
        if (attempt === retries - 1) {
          // Final retry failed - notify user
          showUpdateBanner();
          throw new Error('Extension context invalidated. Please refresh the page.');
        }

        // Exponential backoff before retry
        const delay = RETRY_DELAY_BASE_MS * Math.pow(2, attempt);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      // Non-context error - don't retry
      throw error;
    }
  }

  // Should not reach here, but TypeScript needs this
  throw new Error('Max retries exceeded');
}
```

3. **entrypoints/content/index.ts** - Content script entry:
```typescript
import { sendMessageSafe } from './messaging';
import { isContextValid } from '../../utils/context-check';

export default defineContentScript({
  matches: ['<all_urls>'],

  main() {
    console.log('[Browserlet] Content script loaded on:', window.location.href);

    // Verify communication with service worker on load
    verifyConnection();

    // Listen for messages from service worker
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      handleServiceWorkerMessage(message)
        .then(sendResponse)
        .catch(error => sendResponse({ success: false, error: error.message }));
      return true;
    });
  }
});

async function verifyConnection(): Promise<void> {
  try {
    const response = await sendMessageSafe({ type: 'PING' });
    if (response.success) {
      console.log('[Browserlet] Service worker connection verified');
    } else {
      console.warn('[Browserlet] Service worker responded with error:', response.error);
    }
  } catch (error) {
    console.error('[Browserlet] Failed to connect to service worker:', error);
  }
}

async function handleServiceWorkerMessage(message: any): Promise<any> {
  switch (message.type) {
    case 'PING':
      return { success: true, data: { status: 'ok', url: window.location.href } };

    case 'STORAGE_CHANGED':
      // Storage change notification from service worker
      console.log('[Browserlet] Storage changed:', message.payload);
      return { success: true };

    default:
      return { success: false, error: `Unknown message type: ${message.type}` };
  }
}
```

IMPORTANT patterns from research:
- Always check `chrome.runtime?.id` before sending messages
- Use exponential backoff for retries (100ms, 200ms, 400ms)
- Show user-friendly banner on permanent context invalidation
- Banner should be non-intrusive with dismiss option
  </action>
  <verify>
1. `npm run build` completes without TypeScript errors
2. Load extension in Chrome, open any webpage
3. Open page DevTools console, should see "[Browserlet] Content script loaded on: ..."
4. Should see "[Browserlet] Service worker connection verified"
5. Simulate context invalidation by reloading extension in chrome://extensions
6. Try to interact - banner should appear
  </verify>
  <done>
Content script injects on all URLs, verifies service worker connection on load, handles context invalidation with retry logic and user-friendly banner.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Side Panel Stub</name>
  <files>
    entrypoints/sidepanel/index.html
    entrypoints/sidepanel/main.ts
    wxt.config.ts
  </files>
  <action>
Create minimal side panel that displays state and receives storage updates:

1. **Update wxt.config.ts** to ensure side panel is properly configured:
```typescript
import { defineConfig } from 'wxt';

export default defineConfig({
  manifest: {
    name: 'Browserlet',
    description: 'Semantic web automation for legacy applications',
    permissions: ['storage', 'sidePanel'],
    side_panel: {
      default_path: 'sidepanel.html'
    },
    action: {
      default_title: 'Open Browserlet'
    }
  }
});
```

2. **entrypoints/sidepanel/index.html** - Side panel HTML:
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Browserlet</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      line-height: 1.5;
      color: #333;
      padding: 16px;
      background: #fafafa;
    }
    h1 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #1a1a1a;
    }
    .status {
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
    }
    .status-label {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    .status-value {
      font-size: 14px;
      font-weight: 500;
    }
    .status-ok {
      color: #2e7d32;
    }
    .status-error {
      color: #c62828;
    }
    .state-display {
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 12px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .actions {
      margin-top: 16px;
      display: flex;
      gap: 8px;
    }
    button {
      background: #1976d2;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    button:hover {
      background: #1565c0;
    }
    button:disabled {
      background: #bdbdbd;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <h1>Browserlet</h1>

  <div class="status">
    <div class="status-label">Service Worker</div>
    <div id="sw-status" class="status-value">Checking...</div>
  </div>

  <div class="status">
    <div class="status-label">App State</div>
    <div id="state-display" class="state-display">Loading...</div>
  </div>

  <div class="actions">
    <button id="refresh-state">Refresh State</button>
    <button id="ping-sw">Ping Service Worker</button>
  </div>

  <script type="module" src="./main.ts"></script>
</body>
</html>
```

3. **entrypoints/sidepanel/main.ts** - Side panel logic:
```typescript
import type { Message, MessageResponse, AppState, PingResponse } from '../../utils/types';

// DOM elements
const swStatus = document.getElementById('sw-status')!;
const stateDisplay = document.getElementById('state-display')!;
const refreshBtn = document.getElementById('refresh-state')!;
const pingBtn = document.getElementById('ping-sw')!;

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  init();
});

async function init(): Promise<void> {
  // Check service worker connection
  await pingServiceWorker();

  // Load initial state
  await loadState();

  // Listen for storage changes
  chrome.storage.onChanged.addListener(handleStorageChange);

  // Set up button handlers
  refreshBtn.addEventListener('click', loadState);
  pingBtn.addEventListener('click', pingServiceWorker);
}

async function pingServiceWorker(): Promise<void> {
  try {
    const response = await sendMessage<PingResponse>({ type: 'PING' });

    if (response.success && response.data) {
      swStatus.textContent = `Connected (${new Date(response.data.timestamp).toLocaleTimeString()})`;
      swStatus.className = 'status-value status-ok';
    } else {
      swStatus.textContent = `Error: ${response.error || 'Unknown error'}`;
      swStatus.className = 'status-value status-error';
    }
  } catch (error) {
    swStatus.textContent = `Disconnected: ${error instanceof Error ? error.message : 'Unknown error'}`;
    swStatus.className = 'status-value status-error';
  }
}

async function loadState(): Promise<void> {
  try {
    const response = await sendMessage<AppState>({ type: 'GET_STATE' });

    if (response.success && response.data) {
      stateDisplay.textContent = JSON.stringify(response.data, null, 2);
    } else {
      stateDisplay.textContent = `Error: ${response.error || 'Unknown error'}`;
    }
  } catch (error) {
    stateDisplay.textContent = `Error: ${error instanceof Error ? error.message : 'Unknown error'}`;
  }
}

function handleStorageChange(
  changes: { [key: string]: chrome.storage.StorageChange },
  namespace: string
): void {
  if (namespace !== 'local') return;

  console.log('[Browserlet Side Panel] Storage changed:', changes);

  // Refresh state display when appState changes
  if (changes.appState) {
    stateDisplay.textContent = JSON.stringify(changes.appState.newValue, null, 2);
  }
}

async function sendMessage<T>(message: Message): Promise<MessageResponse<T>> {
  return chrome.runtime.sendMessage(message);
}
```

4. **Update background/index.ts** to open side panel on action click:
Add this to the existing background/index.ts inside defineBackground():
```typescript
  // Open side panel when extension action is clicked
  chrome.action.onClicked.addListener(async (tab) => {
    if (tab.id) {
      await chrome.sidePanel.open({ tabId: tab.id });
    }
  });
```

IMPORTANT: The side panel uses chrome.storage.onChanged to receive updates automatically when storage changes, without explicit messaging from service worker.
  </action>
  <verify>
1. `npm run build` completes without TypeScript errors
2. Load extension in Chrome
3. Click extension icon in toolbar
4. Side panel should open on the right side
5. Side panel shows "Connected" status and app state JSON
6. Click "Ping Service Worker" - timestamp should update
7. Click "Refresh State" - state should refresh
  </verify>
  <done>
Side panel opens from extension action, displays service worker connection status and app state, automatically updates when storage changes via chrome.storage.onChanged listener.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Full communication test:**
   - Open any webpage (e.g., https://example.com)
   - Click Browserlet extension icon to open side panel
   - Side panel should show "Connected" and app state
   - Open webpage DevTools console - should see content script loaded message

2. **Storage synchronization test:**
   - In service worker console (chrome://extensions -> service worker):
     ```javascript
     chrome.storage.local.set({appState: {version: '0.1.0', firstInstall: Date.now(), lastActivity: Date.now(), testField: 'hello'}})
     ```
   - Side panel should automatically update to show the new state
   - Webpage console should log "Storage changed: ..."

3. **Context invalidation test:**
   - Open a webpage with content script loaded
   - Go to chrome://extensions
   - Click "reload" on Browserlet extension
   - Go back to webpage, trigger any Browserlet action
   - Update banner should appear at top of page

4. **Message routing test:**
   - From side panel, click "Ping Service Worker"
   - Status should update with new timestamp
   - This verifies: Side Panel -> Service Worker communication
</verification>

<success_criteria>
- Content script loads on all URLs without errors
- Content script verifies service worker connection on load
- Context invalidation shows user-friendly banner
- Side panel opens when clicking extension icon
- Side panel displays service worker connection status
- Side panel displays app state from chrome.storage
- Side panel updates automatically when storage changes
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
