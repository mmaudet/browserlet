---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - wxt.config.ts
  - tsconfig.json
  - entrypoints/background/index.ts
  - entrypoints/background/messaging.ts
  - entrypoints/background/storage.ts
  - utils/types.ts
autonomous: true

must_haves:
  truths:
    - "WXT project initializes without errors"
    - "Service worker starts when extension loads"
    - "Service worker responds to PING messages"
    - "State persists to chrome.storage.local"
  artifacts:
    - path: "package.json"
      provides: "Project dependencies and scripts"
      contains: "wxt"
    - path: "wxt.config.ts"
      provides: "WXT configuration"
      contains: "defineConfig"
    - path: "entrypoints/background/index.ts"
      provides: "Service worker entry point"
      contains: "defineBackground"
    - path: "entrypoints/background/messaging.ts"
      provides: "Message routing logic"
      exports: ["handleMessage"]
    - path: "entrypoints/background/storage.ts"
      provides: "Storage wrapper functions"
      exports: ["getState", "setState"]
    - path: "utils/types.ts"
      provides: "Shared type definitions"
      exports: ["Message", "AppState"]
  key_links:
    - from: "entrypoints/background/index.ts"
      to: "entrypoints/background/messaging.ts"
      via: "import handleMessage"
      pattern: "import.*handleMessage.*messaging"
    - from: "entrypoints/background/messaging.ts"
      to: "entrypoints/background/storage.ts"
      via: "getState/setState calls"
      pattern: "(getState|setState)\\("
    - from: "entrypoints/background/index.ts"
      to: "chrome.runtime.onMessage"
      via: "top-level listener registration"
      pattern: "chrome\\.runtime\\.onMessage\\.addListener"
---

<objective>
Initialize WXT-based Chrome extension project and implement the service worker as a stateless message router with chrome.storage.local as the source of truth.

Purpose: Establish the foundational infrastructure that all other Phase 1 components depend on. The service worker is the hub that routes messages between content scripts and side panel, while chrome.storage provides persistence that survives service worker termination.

Output: Working WXT project with service worker that handles messages and persists state.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize WXT Project</name>
  <files>
    package.json
    wxt.config.ts
    tsconfig.json
    .gitignore
  </files>
  <action>
Create a new WXT project using `npm create wxt@latest` with the following options:
- Project name: browserlet (use current directory)
- Package manager: npm
- Template: vanilla-ts (NOT preact-ts - UI framework deferred to Phase 3)
- Install dependencies: Yes

After initialization:
1. Verify wxt.config.ts exists and contains `defineConfig`
2. Update wxt.config.ts to set manifest name to "Browserlet" and description
3. Add to manifest in wxt.config.ts:
   - `permissions: ['storage', 'sidePanel']`
   - `side_panel: { default_path: 'sidepanel.html' }`
4. Ensure tsconfig.json includes strict mode
5. Update .gitignore to include `.output/`, `node_modules/`, `.wxt/`

IMPORTANT: Run `npm create wxt@latest .` (note the dot for current directory). If it asks to overwrite files, allow it - the .planning directory will not be affected.
  </action>
  <verify>
`npm run dev` starts without errors (Ctrl+C to stop after confirming).
`ls entrypoints/` shows the default entrypoints created by WXT.
  </verify>
  <done>
WXT project initialized with Browserlet configuration, TypeScript strict mode, and required permissions declared.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Service Worker with Message Router</name>
  <files>
    entrypoints/background/index.ts
    entrypoints/background/messaging.ts
    entrypoints/background/storage.ts
    utils/types.ts
  </files>
  <action>
Create the service worker infrastructure following the patterns from 01-RESEARCH.md:

1. **utils/types.ts** - Shared type definitions:
```typescript
// Message types for service worker communication
export type MessageType =
  | 'PING'
  | 'GET_STATE'
  | 'SET_STATE'
  | 'STORAGE_CHANGED';

export interface Message {
  type: MessageType;
  payload?: unknown;
}

export interface PingResponse {
  status: 'ok';
  timestamp: number;
}

export interface AppState {
  version: string;
  firstInstall: number;
  lastActivity: number;
}

export interface MessageResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
}
```

2. **entrypoints/background/storage.ts** - Storage wrapper:
```typescript
import type { AppState } from '../../utils/types';

const DEFAULT_STATE: AppState = {
  version: '0.1.0',
  firstInstall: 0,
  lastActivity: 0,
};

export async function getState(): Promise<AppState> {
  const result = await chrome.storage.local.get('appState');
  return result.appState ?? DEFAULT_STATE;
}

export async function setState(partial: Partial<AppState>): Promise<AppState> {
  const current = await getState();
  const updated = { ...current, ...partial, lastActivity: Date.now() };
  await chrome.storage.local.set({ appState: updated });
  return updated;
}

export async function initializeState(): Promise<void> {
  const existing = await chrome.storage.local.get('appState');
  if (!existing.appState) {
    await chrome.storage.local.set({
      appState: { ...DEFAULT_STATE, firstInstall: Date.now() }
    });
  }
}
```

3. **entrypoints/background/messaging.ts** - Message routing:
```typescript
import type { Message, MessageResponse, PingResponse } from '../../utils/types';
import { getState, setState } from './storage';

export function handleMessage(
  message: Message,
  sender: chrome.runtime.MessageSender,
  sendResponse: (response: MessageResponse) => void
): boolean {
  processMessage(message, sender)
    .then(sendResponse)
    .catch(error => sendResponse({ success: false, error: error.message }));

  return true; // Keep channel open for async response
}

async function processMessage(
  message: Message,
  sender: chrome.runtime.MessageSender
): Promise<MessageResponse> {
  switch (message.type) {
    case 'PING':
      return {
        success: true,
        data: { status: 'ok', timestamp: Date.now() } as PingResponse
      };

    case 'GET_STATE':
      const state = await getState();
      return { success: true, data: state };

    case 'SET_STATE':
      const updated = await setState(message.payload as Partial<typeof state>);
      return { success: true, data: updated };

    default:
      return { success: false, error: `Unknown message type: ${message.type}` };
  }
}
```

4. **entrypoints/background/index.ts** - Service worker entry (CRITICAL: top-level listener registration):
```typescript
import { handleMessage } from './messaging';
import { initializeState } from './storage';

export default defineBackground(() => {
  console.log('[Browserlet] Service worker started');

  // CRITICAL: Register listeners at TOP LEVEL, synchronously
  // This ensures listeners are ready when service worker restarts
  chrome.runtime.onMessage.addListener(handleMessage);

  // Listen for storage changes and broadcast to extension pages
  chrome.storage.onChanged.addListener((changes, namespace) => {
    if (namespace !== 'local') return;

    // Broadcast to all extension pages (side panel, popup if any)
    chrome.runtime.sendMessage({
      type: 'STORAGE_CHANGED',
      payload: changes
    }).catch(() => {
      // Extension pages may not be open - ignore errors
    });
  });

  // Handle extension install/update
  chrome.runtime.onInstalled.addListener(async (details) => {
    if (details.reason === 'install') {
      await initializeState();
      console.log('[Browserlet] Extension installed, state initialized');
    }
    if (details.reason === 'update') {
      console.log('[Browserlet] Extension updated from', details.previousVersion);
    }
  });
});
```

IMPORTANT patterns from research:
- Event listeners MUST be registered synchronously at top level (inside defineBackground but before any async code)
- Never store state in global variables - always use chrome.storage.local
- Always return `true` from message listener to keep channel open for async responses
  </action>
  <verify>
1. `npm run build` completes without TypeScript errors
2. Check `.output/chrome-mv3/background.js` exists
3. Load extension in Chrome (chrome://extensions, Developer mode, Load unpacked from `.output/chrome-mv3`)
4. Open service worker console (click "service worker" link in extension card)
5. Console shows "[Browserlet] Service worker started"
  </verify>
  <done>
Service worker implements stateless message routing with PING/GET_STATE/SET_STATE handlers. All event listeners registered synchronously at top level. State persisted to chrome.storage.local.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Build verification:**
   ```bash
   npm run build
   # Should complete with no errors
   ```

2. **Extension load verification:**
   - Open chrome://extensions
   - Enable Developer mode
   - Click "Load unpacked"
   - Select `.output/chrome-mv3` directory
   - Extension "Browserlet" should appear in list

3. **Service worker verification:**
   - Click "service worker" link on extension card
   - Console should show "[Browserlet] Service worker started"
   - In console, run:
     ```javascript
     chrome.runtime.sendMessage({type: 'PING'}, console.log)
     // Should log: {success: true, data: {status: 'ok', timestamp: ...}}
     ```

4. **Storage persistence verification:**
   - In service worker console:
     ```javascript
     chrome.storage.local.get('appState', console.log)
     // Should show appState with version, firstInstall, lastActivity
     ```
</verification>

<success_criteria>
- WXT project builds without errors
- Extension loads in Chrome without errors
- Service worker starts and logs to console
- PING message returns success response
- App state persists in chrome.storage.local
- Type definitions compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
