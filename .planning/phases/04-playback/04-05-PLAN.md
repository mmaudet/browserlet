---
phase: 04-playback
plan: 05
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - entrypoints/content/playback/sessionDetector.ts
autonomous: true

must_haves:
  truths:
    - "Extension detects when user is not logged in"
    - "Detection uses multiple indicators (URL patterns, presence/absence of elements)"
    - "Script can pause for manual authentication"
  artifacts:
    - path: "entrypoints/content/playback/sessionDetector.ts"
      provides: "Session/authentication state detection"
      exports: ["checkSessionActive", "SessionDetector"]
  key_links:
    - from: "entrypoints/content/playback/sessionDetector.ts"
      to: "entrypoints/content/playback/semanticResolver.ts"
      via: "Element resolution for indicators"
      pattern: "import.*resolveElement.*from.*semanticResolver"
---

<objective>
Create session detector for authentication state detection.

Purpose: Legacy ERPs often have session timeouts. The session detector identifies when the user is logged out (redirected to login page, session indicator missing) so the script can pause for manual authentication. This covers requirements AUTH-01, AUTH-02, AUTH-03.

Output:
- `entrypoints/content/playback/sessionDetector.ts` - Session state detection with multiple indicators
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-playback/04-RESEARCH.md

# Types and dependencies
@entrypoints/content/playback/types.ts
@entrypoints/content/playback/semanticResolver.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session detector module</name>
  <files>entrypoints/content/playback/sessionDetector.ts</files>
  <action>
Create `entrypoints/content/playback/sessionDetector.ts` with:

1. **Import SessionCheckConfig** from playback/types.ts

2. **checkUrlPatterns(patterns: string[] | undefined): boolean**
   - If no patterns defined, return true (assume authenticated)
   - Check current URL against each pattern
   - Patterns use wildcards: "*/login*", "*/signin*", "*/auth/*"
   - Convert pattern to regex: pattern.replace(/\*/g, '.*')
   - If ANY pattern matches current URL, return false (on login page = not authenticated)
   - Return true if no patterns match

3. **checkIndicatorPresent(indicatorConfig: { hints: SemanticHint[] } | undefined): boolean**
   - If no indicator defined, return true (no check = assume authenticated)
   - Use resolveElement to find element
   - Check isElementVisible
   - Return true if element found and visible
   - Return false otherwise

4. **checkAbsenceIndicator(absenceConfig: { hints: SemanticHint[] } | undefined): boolean**
   - If no absence_indicator defined, return true (no check = assume authenticated)
   - Use resolveElement to find element (e.g., login form)
   - If element NOT found or NOT visible, return true (login form absent = authenticated)
   - Return false if element IS visible (login form present = not authenticated)

5. **checkSessionActive(config: SessionCheckConfig): boolean**
   - Check URL patterns first (fastest)
   - Check presence indicator
   - Check absence indicator
   - Return true only if ALL checks pass
   - Any check returning false means not authenticated

Import resolveElement from semanticResolver.
Import isElementVisible from utils/hints/dom.
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/sessionDetector.ts` - no errors.
  </verify>
  <done>
Session detection uses three strategies: URL patterns (login pages), presence indicators (user avatar), absence indicators (login form). All three must pass for authenticated state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SessionDetector class with waiting</name>
  <files>entrypoints/content/playback/sessionDetector.ts</files>
  <action>
Add to `entrypoints/content/playback/sessionDetector.ts`:

1. **SessionDetector class:**
   ```typescript
   export class SessionDetector {
     private config: SessionCheckConfig | undefined;
     private onAuthRequired: (() => void) | null = null;
     private isWaiting = false;

     constructor(config?: SessionCheckConfig) {
       this.config = config;
     }

     // Set callback for when auth is required
     onAuthenticationRequired(callback: () => void): void {
       this.onAuthRequired = callback;
     }

     // Check if session is active
     isAuthenticated(): boolean {
       if (!this.config) return true; // No config = skip check
       return checkSessionActive(this.config);
     }

     // Start waiting for authentication
     async waitForAuthentication(pollIntervalMs: number = 2000): Promise<void> {
       if (this.isWaiting) return;
       this.isWaiting = true;

       // Notify that auth is required
       this.onAuthRequired?.();

       // Poll until authenticated
       while (!this.isAuthenticated() && this.isWaiting) {
         await new Promise(r => setTimeout(r, pollIntervalMs));
       }

       this.isWaiting = false;
     }

     // Stop waiting (for cancellation)
     stopWaiting(): void {
       this.isWaiting = false;
     }

     // Update config (for runtime changes)
     setConfig(config: SessionCheckConfig): void {
       this.config = config;
     }
   }
   ```

2. **Add default login page patterns:**
   ```typescript
   export const DEFAULT_LOGIN_PATTERNS = [
     '*/login*',
     '*/signin*',
     '*/sign-in*',
     '*/auth/*',
     '*/authenticate*',
     '*/session/new*',
   ];
   ```

Export both checkSessionActive function and SessionDetector class.
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/sessionDetector.ts` - no errors.
  </verify>
  <done>
SessionDetector class provides stateful session monitoring with polling. waitForAuthentication pauses execution until user logs in. DEFAULT_LOGIN_PATTERNS covers common login URL patterns.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for session detector</name>
  <files>entrypoints/content/playback/sessionDetector.test.ts</files>
  <action>
Create `entrypoints/content/playback/sessionDetector.test.ts` with:

1. **checkUrlPatterns tests:**
   - No patterns returns true
   - URL matching pattern returns false (on login page)
   - URL not matching pattern returns true
   - Wildcard patterns work correctly

2. **checkIndicatorPresent tests:**
   - No config returns true
   - Element found and visible returns true
   - Element not found returns false
   - Element found but hidden returns false

3. **checkAbsenceIndicator tests:**
   - No config returns true
   - Login form NOT found returns true (authenticated)
   - Login form found and visible returns false (not authenticated)

4. **checkSessionActive tests:**
   - All checks pass returns true
   - URL pattern fails returns false
   - Indicator check fails returns false
   - Absence check fails returns false

5. **SessionDetector class tests:**
   - isAuthenticated returns correct state
   - waitForAuthentication polls until authenticated
   - stopWaiting cancels polling
   - onAuthenticationRequired callback is called

Use vi.mock for resolveElement and isElementVisible.
Use vi.useFakeTimers for polling tests.
  </action>
  <verify>
Run `npm test -- entrypoints/content/playback/sessionDetector.test.ts` - all tests pass.
  </verify>
  <done>
Unit tests cover URL pattern matching, indicator presence/absence, combined checks, and SessionDetector class behavior. Mocking used for DOM dependencies.
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit entrypoints/content/playback/sessionDetector.ts`
2. Unit tests: `npm test -- entrypoints/content/playback/sessionDetector.test.ts`
3. Exports include checkSessionActive, SessionDetector, DEFAULT_LOGIN_PATTERNS
</verification>

<success_criteria>
- [ ] sessionDetector.ts exports checkSessionActive and SessionDetector
- [ ] checkSessionActive uses three detection strategies
- [ ] URL patterns detect login pages with wildcards
- [ ] Indicator checks use semantic resolver
- [ ] SessionDetector.waitForAuthentication polls with configurable interval
- [ ] DEFAULT_LOGIN_PATTERNS covers common patterns
- [ ] Unit tests pass for all detection strategies
</success_criteria>

<output>
After completion, create `.planning/phases/04-playback/04-05-SUMMARY.md`
</output>
