---
phase: 04-playback
plan: 07
type: execute
wave: 5
depends_on: ["04-06"]
files_modified:
  - entrypoints/content/index.ts
  - entrypoints/sidepanel/stores/execution.ts
  - entrypoints/sidepanel/components/ExecutionView.ts
  - utils/types.ts
autonomous: false

must_haves:
  truths:
    - "User can execute a BSL script from Side Panel"
    - "Execution progress displays in real-time with step count"
    - "User can stop execution at any time"
    - "Execution errors show clear messages with step info"
    - "Results are stored in execution history"
  artifacts:
    - path: "entrypoints/content/index.ts"
      provides: "Message handler for EXECUTE_SCRIPT and STOP_EXECUTION"
      contains: "PlaybackManager"
    - path: "entrypoints/sidepanel/stores/execution.ts"
      provides: "Real execution integration"
      contains: "EXECUTE_SCRIPT"
    - path: "entrypoints/sidepanel/components/ExecutionView.ts"
      provides: "Stop button and progress display"
      contains: "stopExecution"
  key_links:
    - from: "entrypoints/sidepanel/stores/execution.ts"
      to: "chrome.tabs.sendMessage"
      via: "Message to content script"
      pattern: "chrome\\.tabs\\.sendMessage"
    - from: "entrypoints/content/index.ts"
      to: "entrypoints/content/playback/index.ts"
      via: "PlaybackManager import"
      pattern: "import.*PlaybackManager.*from.*playback"
---

<objective>
Wire PlaybackManager to Side Panel UI for end-to-end script execution.

Purpose: Connect all playback infrastructure to the user interface. Users can start execution from the Side Panel, see real-time progress, stop execution, and view results. This completes the Phase 4 feature set.

Output:
- Updated content script with playback message handlers
- Updated execution store with real script execution
- Updated ExecutionView with stop functionality
- E2E verification of complete playback flow
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-playback/04-RESEARCH.md

# Playback infrastructure
@entrypoints/content/playback/index.ts

# Existing wiring to update
@entrypoints/content/index.ts
@entrypoints/sidepanel/stores/execution.ts
@entrypoints/sidepanel/components/ExecutionView.ts
@utils/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add playback message types and handlers to content script</name>
  <files>utils/types.ts, entrypoints/content/index.ts</files>
  <action>
1. **Update utils/types.ts:**
   Add new message types:
   ```typescript
   export type MessageType =
     | 'PING'
     | 'GET_STATE'
     | 'SET_STATE'
     | 'STORAGE_CHANGED'
     | 'START_RECORDING'
     | 'STOP_RECORDING'
     | 'RECORDING_STATE_CHANGED'
     | 'ACTION_CAPTURED'
     // New playback messages
     | 'EXECUTE_SCRIPT'
     | 'STOP_EXECUTION'
     | 'EXECUTION_PROGRESS'
     | 'EXECUTION_COMPLETED'
     | 'EXECUTION_FAILED'
     | 'AUTH_REQUIRED';
   ```

2. **Update entrypoints/content/index.ts:**
   - Import PlaybackManager from './playback'
   - Create singleton instance at module level
   - Add message handlers for EXECUTE_SCRIPT and STOP_EXECUTION

   ```typescript
   import { PlaybackManager } from './playback';

   // Module-level singleton (persists across messages)
   let playbackManager: PlaybackManager | null = null;

   function getPlaybackManager(): PlaybackManager {
     if (!playbackManager) {
       playbackManager = new PlaybackManager();
       playbackManager.onEvent((event) => {
         // Forward events to sidepanel
         chrome.runtime.sendMessage({
           type: event.type === 'progress' ? 'EXECUTION_PROGRESS' :
                 event.type === 'auth_required' ? 'AUTH_REQUIRED' :
                 event.type === 'error' ? 'EXECUTION_FAILED' : 'STATE_CHANGED',
           payload: event
         }).catch(() => {}); // Ignore if no listener
       });
     }
     return playbackManager;
   }
   ```

3. **Add message handlers in the existing listener:**
   ```typescript
   case 'EXECUTE_SCRIPT': {
     const { content } = message.payload as { content: string };
     const manager = getPlaybackManager();
     // Execute async, send result when done
     manager.execute(content).then((result) => {
       chrome.runtime.sendMessage({
         type: result.status === 'completed' ? 'EXECUTION_COMPLETED' : 'EXECUTION_FAILED',
         payload: result
       }).catch(() => {});
     });
     return { success: true };
   }

   case 'STOP_EXECUTION': {
     getPlaybackManager().stop();
     return { success: true };
   }
   ```
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/index.ts` - no errors.
Run `npx tsc --noEmit utils/types.ts` - no errors.
  </verify>
  <done>
Content script handles EXECUTE_SCRIPT and STOP_EXECUTION messages. PlaybackManager singleton forwards progress events to runtime for Side Panel.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update execution store for real playback</name>
  <files>entrypoints/sidepanel/stores/execution.ts</files>
  <action>
Update `entrypoints/sidepanel/stores/execution.ts`:

1. **Import parseSteps for step counting:**
   ```typescript
   import { parseSteps } from '../../../utils/yaml/stepParser';
   ```

2. **Update startExecution to send EXECUTE_SCRIPT:**
   ```typescript
   export async function startExecution(script: Script): Promise<void> {
     // Parse script to get accurate step count
     const parsed = parseSteps(script.content);
     const stepCount = parsed.steps.length;

     isExecuting.val = true;
     currentScript.val = script;
     currentStep.val = 0;
     totalSteps.val = stepCount;
     executionStatus.val = 'running';
     executionResults.val = [];
     executionError.val = null;

     // Create execution record
     const record = await addExecutionRecord({
       scriptId: script.id,
       scriptName: script.name,
       startedAt: Date.now(),
       status: 'running',
       currentStep: 0,
       totalSteps: stepCount
     });
     currentRecordId.val = record.id;

     // Send to content script for execution
     const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
     if (tab?.id) {
       await chrome.tabs.sendMessage(tab.id, {
         type: 'EXECUTE_SCRIPT',
         payload: { content: script.content }
       });
     }
   }
   ```

3. **Add runtime message listener for progress updates:**
   ```typescript
   // Listen for execution events from content script
   chrome.runtime.onMessage.addListener((message) => {
     switch (message.type) {
       case 'EXECUTION_PROGRESS':
         const { step, totalSteps: total } = message.payload;
         currentStep.val = step;
         totalSteps.val = total;
         // Update record
         if (currentRecordId.val && currentScript.val) {
           updateExecutionRecord(currentScript.val.id, currentRecordId.val, {
             currentStep: step,
             status: 'running'
           });
         }
         break;

       case 'EXECUTION_COMPLETED':
         completeExecution(message.payload.results);
         break;

       case 'EXECUTION_FAILED':
         failExecution(message.payload.error || 'Execution failed');
         break;

       case 'AUTH_REQUIRED':
         executionStatus.val = 'waiting_auth';
         break;
     }
   });
   ```

4. **Update stopExecution to send STOP_EXECUTION:**
   ```typescript
   export async function stopExecution(): Promise<void> {
     // Send stop message to content script
     const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
     if (tab?.id) {
       await chrome.tabs.sendMessage(tab.id, { type: 'STOP_EXECUTION' });
     }

     isExecuting.val = false;
     executionStatus.val = 'stopped';

     if (currentRecordId.val && currentScript.val) {
       await updateExecutionRecord(currentScript.val.id, currentRecordId.val, {
         status: 'stopped',
         completedAt: Date.now()
       });
     }
   }
   ```
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/sidepanel/stores/execution.ts` - no errors.
  </verify>
  <done>
Execution store sends EXECUTE_SCRIPT to content script with parsed step count. Listens for progress/completion/error events. Stop button sends STOP_EXECUTION.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ExecutionView with stop button and auth state</name>
  <files>entrypoints/sidepanel/components/ExecutionView.ts</files>
  <action>
Update `entrypoints/sidepanel/components/ExecutionView.ts`:

1. **Import stopExecution:**
   ```typescript
   import { ..., stopExecution } from '../stores/execution';
   ```

2. **Add stop button during execution:**
   In the running state section, add a stop button:
   ```typescript
   // If running, show stop button
   () => executionStatus.val === 'running' || executionStatus.val === 'waiting_auth' ?
     button({
       class: 'stop-btn',
       onclick: () => stopExecution()
     }, chrome.i18n.getMessage('stopExecution') || 'Stop')
   : null
   ```

3. **Add waiting_auth state display:**
   ```typescript
   // Show auth required message
   () => executionStatus.val === 'waiting_auth' ?
     div({ class: 'auth-required' },
       p(chrome.i18n.getMessage('authRequired') || 'Authentication required. Please log in manually.'),
       p(chrome.i18n.getMessage('authContinue') || 'Execution will resume automatically after login.')
     )
   : null
   ```

4. **Add i18n keys (will be added to public/_locales/*/messages.json):**
   - stopExecution: "Stop" / "Arreter"
   - authRequired: "Authentication required..." / "Authentification requise..."
   - authContinue: "Execution will resume..." / "L'execution reprendra..."

5. **Add CSS for stop button:**
   In the component styles or global CSS:
   ```css
   .stop-btn {
     background-color: #dc3545;
     color: white;
     border: none;
     padding: 8px 16px;
     border-radius: 4px;
     cursor: pointer;
   }
   .stop-btn:hover {
     background-color: #c82333;
   }
   .auth-required {
     background-color: #fff3cd;
     border: 1px solid #ffc107;
     padding: 12px;
     border-radius: 4px;
     margin: 8px 0;
   }
   ```
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/sidepanel/components/ExecutionView.ts` - no errors.
  </verify>
  <done>
ExecutionView shows stop button during execution. Auth required state displays user-friendly message. New i18n keys added for internationalization.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete playback system:
- PlaybackManager orchestrating script execution
- Semantic resolver with weighted multi-hint scoring
- All 8 BSL actions (click, type, select, extract, wait_for, navigate, scroll, hover)
- Session detection for authentication pauses
- Humanized delays for bot detection avoidance
- Side Panel integration with stop functionality
  </what-built>
  <how-to-verify>
1. Load extension in Chrome: `npm run dev`, open chrome://extensions, load from .output/chrome-mv3-dev

2. Create or import a test BSL script with steps like:
   ```yaml
   name: Test Script
   steps:
     - action: navigate
       value: "https://example.com"
     - action: click
       target:
         hints:
           - type: role
             value: link
           - type: text_contains
             value: "More information"
     - action: wait_for
       target:
         hints:
           - type: role
             value: heading
       timeout: "5s"
   ```

3. Open Side Panel, select the script, click Run

4. Verify:
   - [ ] Progress bar updates as steps execute
   - [ ] Current step number shows correctly
   - [ ] Stop button appears during execution
   - [ ] Clicking Stop halts execution immediately
   - [ ] Execution completes successfully on valid script
   - [ ] Error shows step number on failure
   - [ ] Results appear in execution history

5. Test error handling:
   - Script with invalid target (element not found) shows clear error
   - Error includes step number and hint match details
  </how-to-verify>
  <resume-signal>Type "approved" if playback works correctly, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. TypeScript compilation passes for all modified files
2. npm run dev builds without errors
3. Extension loads in Chrome
4. E2E test: execute a script, verify progress, stop, completion
</verification>

<success_criteria>
- [ ] EXECUTE_SCRIPT message triggers PlaybackManager.execute
- [ ] STOP_EXECUTION message triggers PlaybackManager.stop
- [ ] Progress events update Side Panel in real-time
- [ ] Stop button halts execution immediately
- [ ] Errors include step index and descriptive message
- [ ] Auth required state shows user-friendly message
- [ ] E2E verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/04-playback/04-07-SUMMARY.md`
</output>
