---
phase: 04-playback
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - entrypoints/content/playback/semanticResolver.ts
autonomous: true

must_haves:
  truths:
    - "Resolver finds elements using weighted multi-hint scoring"
    - "Elements are only returned if confidence exceeds 0.7 threshold"
    - "Smart waiting uses MutationObserver with timeout fallback"
    - "Resolver returns detailed match info (confidence, matched/failed hints)"
  artifacts:
    - path: "entrypoints/content/playback/semanticResolver.ts"
      provides: "Element resolution from semantic hints"
      exports: ["resolveElement", "waitForElement", "HINT_WEIGHTS"]
  key_links:
    - from: "entrypoints/content/playback/semanticResolver.ts"
      to: "utils/hints/dom.ts"
      via: "DOM utility imports"
      pattern: "import.*from.*utils/hints/dom"
    - from: "entrypoints/content/playback/semanticResolver.ts"
      to: "MutationObserver"
      via: "Smart waiting implementation"
      pattern: "new MutationObserver"
---

<objective>
Create semantic resolver for finding DOM elements using multi-hint weighted scoring and smart waiting.

Purpose: This is the core of resilient automation. Unlike fragile CSS/XPath selectors, semantic hints survive DOM restructuring. The resolver is the bridge between BSL scripts and actual page elements.

Output:
- `entrypoints/content/playback/semanticResolver.ts` - Multi-hint element resolution with MutationObserver waiting
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-playback/04-RESEARCH.md

# Types from Plan 01
@entrypoints/content/playback/types.ts

# Existing DOM utilities to reuse
@utils/hints/dom.ts
@utils/hints/text.ts
@entrypoints/content/recording/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create semantic resolver with weighted scoring</name>
  <files>entrypoints/content/playback/semanticResolver.ts</files>
  <action>
Create `entrypoints/content/playback/semanticResolver.ts` with:

1. **HINT_WEIGHTS constant** (from research, validated by POC):
   ```typescript
   export const HINT_WEIGHTS: Record<HintType, number> = {
     data_attribute: 1.0,  // Most reliable
     role: 1.0,
     type: 1.0,
     aria_label: 0.9,
     name: 0.9,
     id: 0.85,            // Filtered for auto-generated in recording
     text_contains: 0.8,
     placeholder_contains: 0.7,
     near_label: 0.6,     // Less reliable in tables
     class_contains: 0.5, // Often minified
   };
   ```

2. **getInitialCandidates(hints: SemanticHint[]): Element[]**
   - Find first hint with best selectability (role, type, name, id)
   - Use document.querySelectorAll with appropriate selector
   - For role: `[role="${value}"]` or tag-based fallback
   - For type: `[type="${value}"]`
   - For id: `#${value}`
   - Fallback: get all interactive elements

3. **matchHint(element: Element, hint: SemanticHint): boolean**
   - Switch on hint.type
   - role: check element.getAttribute('role') or implicit role via getElementRole()
   - id: element.id === hint.value
   - text_contains: element.textContent includes normalized hint.value
   - type: element.getAttribute('type') === hint.value
   - name: element.getAttribute('name') === hint.value
   - aria_label: element.getAttribute('aria-label') === hint.value
   - placeholder_contains: element.getAttribute('placeholder')?.includes()
   - near_label: findAssociatedLabel().textContent includes hint.value
   - class_contains: element.classList.contains(hint.value)
   - data_attribute: element.getAttribute(hint.value.name) === hint.value.value

4. **resolveElement(hints: SemanticHint[]): ResolverResult**
   - Get initial candidates
   - Score each candidate against all hints
   - Normalize score: score / maxPossibleScore
   - Return best match if confidence >= 0.7
   - Return null element with failedHints if no match

Import from utils/hints/dom.ts: getElementRole, isElementVisible, findAssociatedLabel
Import from utils/hints/text.ts: normalizeText
Import SemanticHint from recording/types.ts
Import ResolverResult from playback/types.ts
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/semanticResolver.ts` - no errors.
  </verify>
  <done>
Semantic resolver uses weighted scoring across 10 hint types. Candidates are filtered by first reliable hint, then scored against all hints. Only elements with >= 70% confidence are returned.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add smart waiting with MutationObserver</name>
  <files>entrypoints/content/playback/semanticResolver.ts</files>
  <action>
Add to `entrypoints/content/playback/semanticResolver.ts`:

1. **waitForElement(hints: SemanticHint[], timeoutMs: number = 10000): Promise<ResolverResult>**
   - Try immediate resolution first
   - If found and visible, return immediately
   - Otherwise, set up MutationObserver on document.body
   - Observer config: { childList: true, subtree: true, attributes: true, attributeFilter: ['class', 'style', 'hidden', 'aria-hidden'] }
   - On each mutation, try resolveElement again
   - If found and visible, disconnect observer, clear timeout, resolve
   - Set up timeout fallback that disconnects observer and rejects with descriptive error
   - Error message should include: timeout value, hint summary for debugging

2. **isElementInteractable(element: Element): boolean**
   - Use isElementVisible from utils/hints/dom.ts
   - Additionally check:
     - Not disabled: !element.hasAttribute('disabled')
     - Not aria-disabled: element.getAttribute('aria-disabled') !== 'true'
     - Has dimensions (getBoundingClientRect width/height > 0)
   - Return true only if all checks pass

Integration:
- waitForElement checks isElementInteractable, not just isElementVisible
- This ensures elements are ready for interaction
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/semanticResolver.ts` - no errors.
  </verify>
  <done>
Smart waiting uses MutationObserver to detect DOM changes. Elements must be visible AND interactable. Timeout provides clear error with hint summary for debugging.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for resolver</name>
  <files>entrypoints/content/playback/semanticResolver.test.ts</files>
  <action>
Create `entrypoints/content/playback/semanticResolver.test.ts` with:

1. **HINT_WEIGHTS tests:**
   - Verify weights for all 10 hint types
   - data_attribute, role, type should be 1.0 (highest)
   - class_contains should be 0.5 (lowest)

2. **matchHint tests:**
   - Test each hint type matching correctly
   - Test hint type not matching (returns false)
   - Test data_attribute with object value format

3. **resolveElement tests:**
   - Mock DOM with elements
   - Element with multiple matching hints returns high confidence
   - Element with partial matches returns appropriate confidence
   - No matching element returns null with failedHints populated
   - Confidence below 0.7 returns null element

4. **waitForElement tests:**
   - Use vi.useFakeTimers()
   - Immediate match resolves immediately
   - Mutation-triggered match resolves after observer fires
   - Timeout rejects with descriptive error

5. **isElementInteractable tests:**
   - Visible, enabled element returns true
   - Hidden element returns false
   - Disabled element returns false
   - aria-disabled element returns false
   - Zero-dimension element returns false

Use happy-dom or jsdom for DOM mocking. Follow existing test patterns.
  </action>
  <verify>
Run `npm test -- entrypoints/content/playback/semanticResolver.test.ts` - all tests pass.
  </verify>
  <done>
Unit tests cover hint matching, weighted scoring, confidence threshold, MutationObserver waiting, and interactability checks. Tests use DOM mocking for isolation.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit entrypoints/content/playback/semanticResolver.ts`
2. Unit tests: `npm test -- entrypoints/content/playback/semanticResolver.test.ts`
3. Verify HINT_WEIGHTS matches research recommendations
</verification>

<success_criteria>
- [ ] semanticResolver.ts exports resolveElement, waitForElement, HINT_WEIGHTS
- [ ] resolveElement uses weighted scoring with 0.7 confidence threshold
- [ ] waitForElement uses MutationObserver with timeout fallback
- [ ] All 10 hint types have correct weights and matching logic
- [ ] isElementInteractable checks visibility, disabled state, dimensions
- [ ] Unit tests pass for scoring, waiting, and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/04-playback/04-03-SUMMARY.md`
</output>
