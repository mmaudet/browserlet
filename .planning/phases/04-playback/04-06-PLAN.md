---
phase: 04-playback
plan: 06
type: execute
wave: 4
depends_on: ["04-01", "04-02", "04-03", "04-04", "04-05"]
files_modified:
  - entrypoints/content/playback/index.ts
autonomous: true

must_haves:
  truths:
    - "PlaybackManager orchestrates step-by-step script execution"
    - "User can stop execution at any time via AbortController"
    - "Execution reports progress after each step"
    - "Errors include step index and descriptive message"
    - "Session checks pause execution when authentication required"
  artifacts:
    - path: "entrypoints/content/playback/index.ts"
      provides: "PlaybackManager orchestrator"
      exports: ["PlaybackManager"]
  key_links:
    - from: "entrypoints/content/playback/index.ts"
      to: "entrypoints/content/playback/actionExecutor.ts"
      via: "ActionExecutor import"
      pattern: "import.*ActionExecutor.*from.*actionExecutor"
    - from: "entrypoints/content/playback/index.ts"
      to: "entrypoints/content/playback/sessionDetector.ts"
      via: "SessionDetector import"
      pattern: "import.*SessionDetector.*from.*sessionDetector"
    - from: "entrypoints/content/playback/index.ts"
      to: "entrypoints/content/playback/humanizer.ts"
      via: "humanizedWait import"
      pattern: "import.*humanizedWait.*from.*humanizer"
---

<objective>
Create PlaybackManager orchestrator that coordinates all playback modules.

Purpose: The PlaybackManager is the entry point for script execution. It parses scripts, executes steps sequentially, handles errors gracefully, manages session detection, and provides stop functionality. This covers EXEC-02, EXEC-06, EXEC-07.

Output:
- `entrypoints/content/playback/index.ts` - Central orchestrator integrating all playback modules
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-playback/04-RESEARCH.md

# All playback modules
@entrypoints/content/playback/types.ts
@entrypoints/content/playback/humanizer.ts
@entrypoints/content/playback/semanticResolver.ts
@entrypoints/content/playback/actionExecutor.ts
@entrypoints/content/playback/sessionDetector.ts

# Existing patterns
@entrypoints/content/recording/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlaybackManager class skeleton</name>
  <files>entrypoints/content/playback/index.ts</files>
  <action>
Create `entrypoints/content/playback/index.ts` with:

1. **Imports:**
   - parseSteps, parseTimeout from utils/yaml/stepParser
   - PlaybackState, ExecutionResult, ParsedScript, BSLStep from ./types
   - ActionExecutor from ./actionExecutor
   - SessionDetector from ./sessionDetector
   - humanizedWait, HumanizerConfig, DEFAULT_CONFIG from ./humanizer
   - waitForElement from ./semanticResolver

2. **PlaybackEventHandler type:**
   ```typescript
   export type PlaybackEventHandler = (event: {
     type: 'state_changed' | 'progress' | 'auth_required' | 'error';
     state?: PlaybackState;
     step?: number;
     totalSteps?: number;
     error?: string;
   }) => void;
   ```

3. **PlaybackManager class skeleton:**
   ```typescript
   export class PlaybackManager {
     private state: PlaybackState = 'idle';
     private currentStep = 0;
     private script: ParsedScript | null = null;
     private abortController: AbortController | null = null;
     private results: Map<string, unknown> = new Map();

     private actionExecutor: ActionExecutor;
     private sessionDetector: SessionDetector;
     private eventHandler: PlaybackEventHandler | null = null;
     private config: HumanizerConfig;

     constructor(config: HumanizerConfig = DEFAULT_CONFIG) {
       this.config = config;
       this.actionExecutor = new ActionExecutor(config);
       this.sessionDetector = new SessionDetector();
     }

     // Public API methods (to be implemented)
     onEvent(handler: PlaybackEventHandler): void { ... }
     getState(): PlaybackState { ... }
     getCurrentStep(): number { ... }
     getResults(): Record<string, unknown> { ... }
     async execute(yamlContent: string): Promise<ExecutionResult> { ... }
     stop(): void { ... }
   }
   ```
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/index.ts` - no errors (may have incomplete implementation).
  </verify>
  <done>
PlaybackManager skeleton created with proper imports and class structure. Public API defined for execute, stop, event handling, and state access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement execute method with step loop</name>
  <files>entrypoints/content/playback/index.ts</files>
  <action>
Implement the core execution logic in PlaybackManager:

1. **execute(yamlContent: string): Promise<ExecutionResult>**
   ```typescript
   async execute(yamlContent: string): Promise<ExecutionResult> {
     // Setup
     this.abortController = new AbortController();
     this.script = parseSteps(yamlContent);
     this.sessionDetector.setConfig(this.script.session_check);
     this.state = 'running';
     this.currentStep = 0;
     this.results.clear();

     this.emit('state_changed');
     this.emit('progress');

     try {
       // Execute steps sequentially
       for (let i = 0; i < this.script.steps.length; i++) {
         // Check for abort
         if (this.abortController.signal.aborted) {
           return { status: 'stopped', step: i };
         }

         this.currentStep = i;
         this.emit('progress');

         // Check session before each step (except navigate)
         const step = this.script.steps[i];
         if (step.action !== 'navigate') {
           await this.checkSession();
         }

         // Execute step
         await this.executeStep(step);

         // Humanized delay between steps
         await humanizedWait(this.config);
       }

       return {
         status: 'completed',
         results: Object.fromEntries(this.results)
       };
     } catch (error) {
       const message = error instanceof Error ? error.message : String(error);
       this.emit('error', message);
       return {
         status: 'failed',
         step: this.currentStep,
         error: `Step ${this.currentStep + 1}: ${message}`
       };
     } finally {
       this.state = 'idle';
       this.abortController = null;
       this.emit('state_changed');
     }
   }
   ```

2. **stop(): void**
   ```typescript
   stop(): void {
     if (this.abortController) {
       this.abortController.abort();
       this.state = 'stopped';
       this.emit('state_changed');
     }
     this.sessionDetector.stopWaiting();
   }
   ```

3. **emit helper:**
   ```typescript
   private emit(type: string, error?: string): void {
     if (!this.eventHandler) return;
     this.eventHandler({
       type: type as any,
       state: this.state,
       step: this.currentStep,
       totalSteps: this.script?.steps.length ?? 0,
       error
     });
   }
   ```
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/index.ts` - no errors.
  </verify>
  <done>
Execute method runs steps sequentially with abort checking, session validation, humanized delays, and proper error handling with step index in messages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement executeStep and session checking</name>
  <files>entrypoints/content/playback/index.ts</files>
  <action>
Add step execution and session checking:

1. **executeStep(step: BSLStep): Promise<void>**
   ```typescript
   private async executeStep(step: BSLStep): Promise<void> {
     // Resolve target element if needed
     let element: Element | undefined;
     if (step.target && step.action !== 'wait_for') {
       const timeoutMs = parseTimeout(step.timeout);
       const result = await waitForElement(step.target.hints, timeoutMs);

       if (!result.element) {
         // Try fallback selector
         if (step.target.fallback_selector) {
           element = document.querySelector(step.target.fallback_selector) ?? undefined;
         }
         if (!element) {
           throw new Error(
             `Element not found: ${step.target.intent || 'unknown'}. ` +
             `Matched hints: [${result.matchedHints.join(', ')}]. ` +
             `Failed hints: [${result.failedHints.join(', ')}]`
           );
         }
       } else {
         element = result.element;
       }
     }

     // Execute action
     const actionResult = await this.actionExecutor.execute(step, element);

     // Store extracted data
     if (step.output?.variable && actionResult !== undefined) {
       this.results.set(step.output.variable, actionResult);
     }

     // Special handling for navigate: wait for page load
     if (step.action === 'navigate') {
       await this.waitForPageLoad();
     }
   }
   ```

2. **checkSession(): Promise<void>**
   ```typescript
   private async checkSession(): Promise<void> {
     if (!this.sessionDetector.isAuthenticated()) {
       this.state = 'waiting_auth';
       this.emit('auth_required');
       this.emit('state_changed');

       await this.sessionDetector.waitForAuthentication();

       this.state = 'running';
       this.emit('state_changed');
     }
   }
   ```

3. **waitForPageLoad(): Promise<void>**
   ```typescript
   private waitForPageLoad(): Promise<void> {
     return new Promise((resolve) => {
       if (document.readyState === 'complete') {
         resolve();
         return;
       }
       window.addEventListener('load', () => resolve(), { once: true });
     });
   }
   ```

4. **Re-export all types and modules for convenience:**
   ```typescript
   export * from './types';
   export { humanizedWait, HumanizerConfig, DEFAULT_CONFIG } from './humanizer';
   export { resolveElement, waitForElement, HINT_WEIGHTS } from './semanticResolver';
   export { ActionExecutor } from './actionExecutor';
   export { SessionDetector, checkSessionActive } from './sessionDetector';
   ```
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/index.ts` - no errors.
All modules re-exported for convenient import.
  </verify>
  <done>
executeStep resolves elements with semantic hints and fallback selectors. Error messages include hint match info. Session checking pauses execution when auth required. Page load waiting for navigate actions.
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit entrypoints/content/playback/index.ts`
2. Exports: PlaybackManager class and all type re-exports
3. All modules integrated: actionExecutor, sessionDetector, humanizer, semanticResolver
</verification>

<success_criteria>
- [ ] PlaybackManager.execute parses and runs scripts step-by-step
- [ ] PlaybackManager.stop aborts execution immediately
- [ ] Progress events emitted after each step
- [ ] Error messages include step index and hint match details
- [ ] Session detection pauses execution when auth required
- [ ] All playback modules re-exported from index.ts
- [ ] No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-playback/04-06-SUMMARY.md`
</output>
