---
phase: 04-playback
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - entrypoints/content/playback/actionExecutor.ts
autonomous: true

must_haves:
  truths:
    - "All 8 BSL actions execute correctly (click, type, select, extract, wait_for, navigate, scroll, hover)"
    - "Actions dispatch proper event sequences for framework compatibility"
    - "Type action enters text character-by-character with humanized delays"
    - "Extract action returns element content or attribute values"
  artifacts:
    - path: "entrypoints/content/playback/actionExecutor.ts"
      provides: "DOM action execution for all 8 BSL actions"
      exports: ["ActionExecutor", "executeClick", "executeType", "executeSelect", "executeExtract", "executeScroll", "executeHover"]
  key_links:
    - from: "entrypoints/content/playback/actionExecutor.ts"
      to: "entrypoints/content/playback/humanizer.ts"
      via: "Typing delay imports"
      pattern: "import.*typeCharacterDelay.*from.*humanizer"
    - from: "entrypoints/content/playback/actionExecutor.ts"
      to: "entrypoints/content/playback/semanticResolver.ts"
      via: "Element resolution imports"
      pattern: "import.*waitForElement.*from.*semanticResolver"
---

<objective>
Create action executor implementing all 8 BSL actions with proper DOM event dispatching.

Purpose: Execute actual DOM interactions that mimic real user behavior. Proper event sequences ensure compatibility with React, Vue, Angular, and legacy jQuery apps. This covers requirements ACT-01 through ACT-08.

Output:
- `entrypoints/content/playback/actionExecutor.ts` - Complete action execution for all 8 BSL action types
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-playback/04-RESEARCH.md

# Dependencies from prior plans
@entrypoints/content/playback/types.ts
@entrypoints/content/playback/humanizer.ts
@entrypoints/content/playback/semanticResolver.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create action executor with click, type, select actions</name>
  <files>entrypoints/content/playback/actionExecutor.ts</files>
  <action>
Create `entrypoints/content/playback/actionExecutor.ts` with:

1. **executeClick(element: Element): Promise<void>** (ACT-01)
   - scrollIntoView({ behavior: 'smooth', block: 'center' })
   - Wait 100ms for scroll to complete (use scrollSettleDelay)
   - Focus element if HTMLElement
   - Calculate center coordinates from getBoundingClientRect()
   - Dispatch event sequence:
     - MouseEvent('mousedown', { bubbles: true, cancelable: true, clientX, clientY })
     - MouseEvent('mouseup', { bubbles: true, cancelable: true, clientX, clientY })
     - MouseEvent('click', { bubbles: true, cancelable: true, clientX, clientY })

2. **executeType(element: Element, text: string, config: HumanizerConfig): Promise<void>** (ACT-02)
   - Validate element is HTMLInputElement or HTMLTextAreaElement
   - Focus element
   - Clear existing value: element.value = ''
   - For each character:
     - KeyboardEvent('keydown', { key: char, bubbles: true })
     - element.value += char
     - InputEvent('input', { bubbles: true, data: char })
     - KeyboardEvent('keyup', { key: char, bubbles: true })
     - await typeCharacterDelay(config)
   - Dispatch Event('change', { bubbles: true }) at end
   - Dispatch Event('blur', { bubbles: true }) to trigger validation

3. **executeSelect(element: Element, optionValue: string): Promise<void>** (ACT-03)
   - Validate element is HTMLSelectElement
   - Focus element
   - Find option by value OR by text content
   - Set element.value to option.value
   - Dispatch Event('change', { bubbles: true })

Import humanizer functions and config types.
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/actionExecutor.ts` - no errors.
  </verify>
  <done>
click, type, select actions implemented with proper event sequences. Type action uses humanized character-by-character input. Select finds options by value or text.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add extract, wait_for, navigate actions</name>
  <files>entrypoints/content/playback/actionExecutor.ts</files>
  <action>
Add to `entrypoints/content/playback/actionExecutor.ts`:

1. **executeExtract(element: Element, transform?: string): Promise<unknown>** (ACT-04)
   - Get raw value based on element type:
     - Input/textarea: element.value
     - Select: element.options[element.selectedIndex].text
     - Other: element.textContent
   - If transform specified:
     - 'trim': value.trim()
     - 'number': parseFloat(value)
     - 'lowercase': value.toLowerCase()
     - 'json': JSON.parse(value)
     - attribute:name: element.getAttribute(name)
   - Return extracted value

2. **executeWaitFor(hints: SemanticHint[], timeoutMs: number): Promise<Element>** (ACT-05)
   - Delegate to waitForElement from semanticResolver
   - Return the resolved element
   - Throws if timeout (handled by waitForElement)

3. **executeNavigate(url: string): Promise<void>** (ACT-06)
   - Set window.location.href = url
   - Return immediately (navigation is async by nature)
   - Note: PlaybackManager handles post-navigation waiting

Import waitForElement from semanticResolver.
Import SemanticHint type.
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/actionExecutor.ts` - no errors.
  </verify>
  <done>
extract supports multiple transforms (trim, number, attribute). wait_for delegates to semantic resolver. navigate triggers page load.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add scroll, hover actions and ActionExecutor class</name>
  <files>entrypoints/content/playback/actionExecutor.ts</files>
  <action>
Add to `entrypoints/content/playback/actionExecutor.ts`:

1. **executeScroll(element: Element): Promise<void>** (ACT-07)
   - scrollIntoView({ behavior: 'smooth', block: 'center' })
   - Wait for scroll completion using scrollSettleDelay
   - Alternative: scroll to coordinates if element has x/y properties

2. **executeHover(element: Element): Promise<void>** (ACT-08)
   - Calculate center coordinates
   - Dispatch MouseEvent sequence:
     - 'mouseenter' (bubbles: false, cancelable: false)
     - 'mouseover' (bubbles: true)
     - 'mousemove' (bubbles: true)
   - Do NOT dispatch mouseleave (hover persists)

3. **ActionExecutor class** (wrapper for all actions):
   ```typescript
   export class ActionExecutor {
     constructor(private config: HumanizerConfig = DEFAULT_CONFIG) {}

     async execute(step: BSLStep, element?: Element): Promise<unknown> {
       switch (step.action) {
         case 'click': return executeClick(element!);
         case 'type': return executeType(element!, step.value!, this.config);
         case 'select': return executeSelect(element!, step.value!);
         case 'extract': return executeExtract(element!, step.output?.transform);
         case 'wait_for': return executeWaitFor(step.target!.hints, parseTimeout(step.timeout));
         case 'navigate': return executeNavigate(step.value!);
         case 'scroll': return executeScroll(element!);
         case 'hover': return executeHover(element!);
       }
     }
   }
   ```

Export all individual functions AND the ActionExecutor class.
  </action>
  <verify>
Run `npx tsc --noEmit entrypoints/content/playback/actionExecutor.ts` - no errors.
All 8 action functions are exported.
ActionExecutor class wraps all actions.
  </verify>
  <done>
All 8 BSL actions implemented. scroll uses smooth scrollIntoView. hover dispatches proper mouse events. ActionExecutor class provides unified interface for PlaybackManager.
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit entrypoints/content/playback/actionExecutor.ts`
2. Exports: File exports all 8 execute* functions plus ActionExecutor class
3. All actions match BSL spec: click, type, select, extract, wait_for, navigate, scroll, hover
</verification>

<success_criteria>
- [ ] All 8 BSL actions have dedicated execute* functions
- [ ] executeClick dispatches mousedown -> mouseup -> click sequence
- [ ] executeType uses character-by-character input with humanized delays
- [ ] executeSelect finds options by value or text content
- [ ] executeExtract supports transform options (trim, number, attribute:*)
- [ ] executeNavigate triggers page navigation
- [ ] ActionExecutor class wraps all actions with config
- [ ] No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-playback/04-04-SUMMARY.md`
</output>
