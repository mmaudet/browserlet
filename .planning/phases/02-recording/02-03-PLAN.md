---
phase: 02-recording
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - entrypoints/content/recording/eventCapture.ts
  - entrypoints/content/recording/navigationCapture.ts
  - entrypoints/content/recording/index.ts
autonomous: true

must_haves:
  truths:
    - "Click events on any element are captured with semantic hints"
    - "Input/typing events are captured with the entered value"
    - "Navigation events (page loads, SPA route changes) are captured"
    - "Recording can be started and stopped programmatically"
    - "Visual feedback shows on hover and captured elements"
  artifacts:
    - path: "entrypoints/content/recording/eventCapture.ts"
      provides: "EventCapture class that listens for click and input events"
      exports: ["EventCapture"]
    - path: "entrypoints/content/recording/navigationCapture.ts"
      provides: "NavigationCapture class that captures page navigations"
      exports: ["NavigationCapture"]
    - path: "entrypoints/content/recording/index.ts"
      provides: "RecordingManager that orchestrates all recording components"
      exports: ["RecordingManager"]
  key_links:
    - from: "entrypoints/content/recording/index.ts"
      to: "entrypoints/content/recording/eventCapture.ts"
      via: "imports and uses EventCapture"
      pattern: "new EventCapture"
    - from: "entrypoints/content/recording/index.ts"
      to: "entrypoints/content/recording/visualFeedback.ts"
      via: "imports and uses HighlightOverlay"
      pattern: "new HighlightOverlay"
    - from: "entrypoints/content/recording/eventCapture.ts"
      to: "entrypoints/content/recording/hintGenerator.ts"
      via: "imports generateHints"
      pattern: "import.*generateHints"
---

<objective>
Implement event capture system and recording orchestrator. Captures clicks, typing, and navigation with semantic hints, coordinated through a central RecordingManager.

Purpose: This is the core recording logic - intercepting user interactions, generating semantic hints, and storing captured actions. The manager coordinates visual feedback, event capture, and state management.

Output: Working RecordingManager that can start/stop recording, capture user interactions with hints, and provide visual feedback.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-recording/02-RESEARCH.md

# Dependencies from previous plans
@entrypoints/content/recording/types.ts
@entrypoints/content/recording/hintGenerator.ts
@entrypoints/content/recording/visualFeedback.ts
@entrypoints/content/recording/styles.ts
@utils/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create event capture module</name>
  <files>
    entrypoints/content/recording/eventCapture.ts
  </files>
  <action>
Create entrypoints/content/recording/eventCapture.ts that captures click and input events.

```typescript
import { CapturedAction, ActionType } from './types';
import { generateHints } from './hintGenerator';

export type EventCallback = (action: CapturedAction) => void;

/**
 * Captures DOM events (click, input, submit) using event delegation.
 * Uses capture phase to intercept events before they reach target handlers.
 */
export class EventCapture {
  private isActive = false;
  private callback: EventCallback | null = null;
  private cleanupFns: (() => void)[] = [];

  // Debounce input events to avoid capturing every keystroke
  private inputDebounceMap = new Map<Element, number>();
  private readonly INPUT_DEBOUNCE_MS = 500;

  /**
   * Start capturing events.
   * @param callback - Called when an action is captured
   */
  start(callback: EventCallback): void {
    if (this.isActive) return;

    this.isActive = true;
    this.callback = callback;

    // Use capture phase to intercept events early
    const clickHandler = this.handleClick.bind(this);
    const inputHandler = this.handleInput.bind(this);
    const submitHandler = this.handleSubmit.bind(this);

    document.addEventListener('click', clickHandler, { capture: true, passive: true });
    document.addEventListener('input', inputHandler, { capture: true, passive: true });
    document.addEventListener('submit', submitHandler, { capture: true });

    // Store cleanup functions
    this.cleanupFns.push(
      () => document.removeEventListener('click', clickHandler, { capture: true }),
      () => document.removeEventListener('input', inputHandler, { capture: true }),
      () => document.removeEventListener('submit', submitHandler, { capture: true })
    );
  }

  /**
   * Stop capturing events and clean up.
   */
  stop(): void {
    if (!this.isActive) return;

    this.isActive = false;
    this.callback = null;

    // Run all cleanup functions
    this.cleanupFns.forEach(fn => fn());
    this.cleanupFns = [];

    // Clear debounce timers
    this.inputDebounceMap.forEach(timer => clearTimeout(timer));
    this.inputDebounceMap.clear();
  }

  /**
   * Check if capture is active.
   */
  get active(): boolean {
    return this.isActive;
  }

  private handleClick(event: MouseEvent): void {
    if (!this.isActive || !this.callback) return;

    const target = event.target as Element;
    if (!target || !this.isInteractiveElement(target)) return;

    // Skip our own overlay elements
    if (target.hasAttribute('data-browserlet-overlay')) return;

    const action = this.createAction('click', target);
    this.callback(action);
  }

  private handleInput(event: Event): void {
    if (!this.isActive || !this.callback) return;

    const target = event.target as HTMLInputElement | HTMLTextAreaElement;
    if (!target) return;

    // Debounce input events
    const existingTimer = this.inputDebounceMap.get(target);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }

    const timer = window.setTimeout(() => {
      if (!this.isActive || !this.callback) return;

      const action = this.createAction('input', target, {
        value: this.getSanitizedValue(target)
      });
      this.callback(action);

      this.inputDebounceMap.delete(target);
    }, this.INPUT_DEBOUNCE_MS);

    this.inputDebounceMap.set(target, timer);
  }

  private handleSubmit(event: Event): void {
    if (!this.isActive || !this.callback) return;

    const form = event.target as HTMLFormElement;
    if (!form) return;

    const action = this.createAction('submit', form);
    this.callback(action);
  }

  private createAction(
    type: ActionType,
    element: Element,
    extra: Partial<CapturedAction> = {}
  ): CapturedAction {
    return {
      type,
      timestamp: Date.now(),
      url: window.location.href,
      hints: generateHints(element),
      isIframe: window !== window.top,
      frameId: this.getFrameId(),
      ...extra
    };
  }

  /**
   * Check if an element is worth capturing (interactive elements).
   */
  private isInteractiveElement(element: Element): boolean {
    const tagName = element.tagName.toLowerCase();
    const interactiveTags = ['a', 'button', 'input', 'select', 'textarea', 'label'];

    if (interactiveTags.includes(tagName)) return true;

    // Check for role attribute
    const role = element.getAttribute('role');
    if (role && ['button', 'link', 'checkbox', 'radio', 'menuitem', 'tab'].includes(role)) {
      return true;
    }

    // Check for click handlers or tabindex
    if (element.hasAttribute('onclick') || element.hasAttribute('tabindex')) {
      return true;
    }

    // Check for cursor: pointer style (common for custom clickable elements)
    const style = window.getComputedStyle(element);
    if (style.cursor === 'pointer') return true;

    return false;
  }

  /**
   * Get sanitized input value (mask passwords).
   */
  private getSanitizedValue(input: HTMLInputElement | HTMLTextAreaElement): string {
    // Don't capture password values
    if (input instanceof HTMLInputElement && input.type === 'password') {
      return '[MASKED]';
    }
    return input.value;
  }

  /**
   * Generate a unique frame identifier.
   */
  private getFrameId(): string | undefined {
    if (window === window.top) return undefined;
    // Use URL + timestamp for iframe identification
    return `${window.location.href}-${performance.now()}`;
  }
}
```

Key implementation details:
- Uses capture phase (`capture: true`) to intercept events before target handlers
- Uses `passive: true` for click/input to not block scrolling
- Debounces input events (500ms) to capture final value, not every keystroke
- Masks password field values for security
- Skips non-interactive elements (no noise from random div clicks)
- Detects iframe context
  </action>
  <verify>
    npx tsc --noEmit
  </verify>
  <done>
    eventCapture.ts exports EventCapture class with start(callback), stop(), active getter.
    Captures click, input, and submit events.
    Type checking passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create navigation capture module</name>
  <files>
    entrypoints/content/recording/navigationCapture.ts
  </files>
  <action>
Create entrypoints/content/recording/navigationCapture.ts that captures navigation events including SPA route changes.

```typescript
import { CapturedAction } from './types';

export type NavigationCallback = (action: CapturedAction) => void;

/**
 * Captures navigation events including:
 * - Traditional page loads (beforeunload)
 * - SPA navigation (History API: pushState, replaceState)
 * - Back/forward navigation (popstate)
 */
export class NavigationCapture {
  private isActive = false;
  private callback: NavigationCallback | null = null;
  private cleanupFns: (() => void)[] = [];

  // Store original methods for monkey-patching
  private originalPushState: typeof history.pushState | null = null;
  private originalReplaceState: typeof history.replaceState | null = null;

  /**
   * Start capturing navigation events.
   * @param callback - Called when a navigation is captured
   */
  start(callback: NavigationCallback): void {
    if (this.isActive) return;

    this.isActive = true;
    this.callback = callback;

    // 1. Traditional navigation
    const beforeUnloadHandler = (event: BeforeUnloadEvent) => {
      this.captureNavigation('Traditional navigation', window.location.href);
    };
    window.addEventListener('beforeunload', beforeUnloadHandler);
    this.cleanupFns.push(() => window.removeEventListener('beforeunload', beforeUnloadHandler));

    // 2. SPA navigation - History API monkey-patching
    this.patchHistoryAPI();

    // 3. Back/forward navigation
    const popstateHandler = () => {
      this.captureNavigation('Back/forward navigation', window.location.href);
    };
    window.addEventListener('popstate', popstateHandler);
    this.cleanupFns.push(() => window.removeEventListener('popstate', popstateHandler));

    // 4. Hash changes (for hash-based routing)
    const hashChangeHandler = () => {
      this.captureNavigation('Hash change', window.location.href);
    };
    window.addEventListener('hashchange', hashChangeHandler);
    this.cleanupFns.push(() => window.removeEventListener('hashchange', hashChangeHandler));
  }

  /**
   * Stop capturing navigation events and restore original behavior.
   */
  stop(): void {
    if (!this.isActive) return;

    this.isActive = false;
    this.callback = null;

    // Restore original History API methods
    this.restoreHistoryAPI();

    // Run all cleanup functions
    this.cleanupFns.forEach(fn => fn());
    this.cleanupFns = [];
  }

  /**
   * Check if capture is active.
   */
  get active(): boolean {
    return this.isActive;
  }

  /**
   * Monkey-patch history.pushState and history.replaceState.
   */
  private patchHistoryAPI(): void {
    this.originalPushState = history.pushState.bind(history);
    this.originalReplaceState = history.replaceState.bind(history);

    const self = this;

    history.pushState = function(state: unknown, unused: string, url?: string | URL | null) {
      const targetUrl = url ? new URL(url.toString(), window.location.href).href : window.location.href;
      self.captureNavigation('SPA navigation (pushState)', targetUrl);
      return self.originalPushState!(state, unused, url);
    };

    history.replaceState = function(state: unknown, unused: string, url?: string | URL | null) {
      const targetUrl = url ? new URL(url.toString(), window.location.href).href : window.location.href;
      self.captureNavigation('SPA navigation (replaceState)', targetUrl);
      return self.originalReplaceState!(state, unused, url);
    };

    this.cleanupFns.push(() => this.restoreHistoryAPI());
  }

  /**
   * Restore original History API methods.
   */
  private restoreHistoryAPI(): void {
    if (this.originalPushState) {
      history.pushState = this.originalPushState;
      this.originalPushState = null;
    }
    if (this.originalReplaceState) {
      history.replaceState = this.originalReplaceState;
      this.originalReplaceState = null;
    }
  }

  /**
   * Create and emit a navigation action.
   */
  private captureNavigation(description: string, targetUrl: string): void {
    if (!this.isActive || !this.callback) return;

    const action: CapturedAction = {
      type: 'navigate',
      timestamp: Date.now(),
      url: window.location.href,
      targetUrl,
      hints: [], // Navigation actions don't have element hints
      isIframe: window !== window.top,
    };

    this.callback(action);
  }
}
```

Key implementation details:
- Monkey-patches History API (pushState/replaceState) to capture SPA navigations
- Properly restores original methods on stop()
- Handles traditional navigation, SPA navigation, back/forward, and hash changes
- Creates proper URL from relative paths
  </action>
  <verify>
    npx tsc --noEmit
  </verify>
  <done>
    navigationCapture.ts exports NavigationCapture class with start(callback), stop(), active getter.
    Captures SPA navigations via History API monkey-patching.
    Type checking passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create RecordingManager orchestrator</name>
  <files>
    entrypoints/content/recording/index.ts
  </files>
  <action>
Create entrypoints/content/recording/index.ts that orchestrates all recording components.

```typescript
import { CapturedAction, RecordingState, RecordingSession } from './types';
import { EventCapture } from './eventCapture';
import { NavigationCapture } from './navigationCapture';
import { HighlightOverlay, RecordingIndicator } from './visualFeedback';
import { generateHints } from './hintGenerator';

export type RecordingEventHandler = (event: {
  type: 'state_changed' | 'action_captured';
  state?: RecordingState;
  action?: CapturedAction;
  session?: RecordingSession;
}) => void;

/**
 * Central orchestrator for recording functionality.
 * Coordinates event capture, navigation capture, visual feedback, and state management.
 */
export class RecordingManager {
  private state: RecordingState = 'idle';
  private session: RecordingSession | null = null;

  private eventCapture: EventCapture;
  private navigationCapture: NavigationCapture;
  private overlay: HighlightOverlay;
  private indicator: RecordingIndicator;

  private eventHandler: RecordingEventHandler | null = null;
  private hoverCleanup: (() => void) | null = null;

  constructor() {
    this.eventCapture = new EventCapture();
    this.navigationCapture = new NavigationCapture();
    this.overlay = new HighlightOverlay();
    this.indicator = new RecordingIndicator();
  }

  /**
   * Set event handler for recording events.
   */
  onEvent(handler: RecordingEventHandler): void {
    this.eventHandler = handler;
  }

  /**
   * Get current recording state.
   */
  getState(): RecordingState {
    return this.state;
  }

  /**
   * Get current recording session (if recording).
   */
  getSession(): RecordingSession | null {
    return this.session;
  }

  /**
   * Get captured actions from current session.
   */
  getActions(): CapturedAction[] {
    return this.session?.actions ?? [];
  }

  /**
   * Start recording user interactions.
   */
  start(): void {
    if (this.state === 'recording') return;

    // Create new session
    this.session = {
      id: this.generateSessionId(),
      startTime: Date.now(),
      actions: [],
      startUrl: window.location.href
    };

    this.state = 'recording';

    // Start visual feedback
    this.indicator.show();
    this.setupHoverHighlight();

    // Start capture modules
    this.eventCapture.start((action) => this.handleAction(action));
    this.navigationCapture.start((action) => this.handleAction(action));

    this.emit('state_changed');
  }

  /**
   * Stop recording and return captured session.
   */
  stop(): RecordingSession | null {
    if (this.state === 'idle') return null;

    // Stop capture modules
    this.eventCapture.stop();
    this.navigationCapture.stop();

    // Stop visual feedback
    this.indicator.hide();
    this.overlay.hide();
    this.cleanupHoverHighlight();

    // Finalize session
    if (this.session) {
      this.session.endTime = Date.now();
    }

    const result = this.session;
    this.session = null;
    this.state = 'idle';

    this.emit('state_changed');
    return result;
  }

  /**
   * Pause recording (keep session, stop capture).
   */
  pause(): void {
    if (this.state !== 'recording') return;

    this.eventCapture.stop();
    this.navigationCapture.stop();
    this.cleanupHoverHighlight();

    this.state = 'paused';
    this.emit('state_changed');
  }

  /**
   * Resume recording from paused state.
   */
  resume(): void {
    if (this.state !== 'paused') return;

    this.setupHoverHighlight();
    this.eventCapture.start((action) => this.handleAction(action));
    this.navigationCapture.start((action) => this.handleAction(action));

    this.state = 'recording';
    this.emit('state_changed');
  }

  /**
   * Destroy the manager and clean up all resources.
   */
  destroy(): void {
    this.stop();
    this.eventHandler = null;
  }

  /**
   * Handle a captured action.
   */
  private handleAction(action: CapturedAction): void {
    if (this.state !== 'recording' || !this.session) return;

    this.session.actions.push(action);

    // Show captured feedback briefly
    // (We can't highlight navigation actions as they have no element)
    if (action.type !== 'navigate') {
      // The actual element is not stored in action, so we rely on mouseover
      // highlighting. The "captured" state flash happens on click.
    }

    this.emit('action_captured', action);
  }

  /**
   * Set up hover highlighting during recording.
   */
  private setupHoverHighlight(): void {
    const mousemoveHandler = (event: MouseEvent) => {
      const target = event.target as Element;
      if (!target) return;

      // Skip our own elements
      if (target.hasAttribute('data-browserlet-overlay') ||
          target.hasAttribute('data-browserlet-indicator')) {
        return;
      }

      // Only highlight interactive elements
      if (this.isInteractiveElement(target)) {
        this.overlay.show(target, 'hover');
      } else {
        this.overlay.hide();
      }
    };

    const mousedownHandler = (event: MouseEvent) => {
      const target = event.target as Element;
      if (!target) return;
      if (target.hasAttribute('data-browserlet-overlay')) return;

      // Flash captured state
      if (this.isInteractiveElement(target)) {
        this.overlay.show(target, 'captured');
        // Return to hover state after brief flash
        setTimeout(() => {
          if (this.state === 'recording') {
            this.overlay.setState('hover');
          }
        }, 200);
      }
    };

    const mouseoutHandler = () => {
      this.overlay.hide();
    };

    document.addEventListener('mousemove', mousemoveHandler, { passive: true });
    document.addEventListener('mousedown', mousedownHandler, { passive: true });
    document.addEventListener('mouseout', mouseoutHandler, { passive: true });

    this.hoverCleanup = () => {
      document.removeEventListener('mousemove', mousemoveHandler);
      document.removeEventListener('mousedown', mousedownHandler);
      document.removeEventListener('mouseout', mouseoutHandler);
    };
  }

  /**
   * Clean up hover highlighting.
   */
  private cleanupHoverHighlight(): void {
    if (this.hoverCleanup) {
      this.hoverCleanup();
      this.hoverCleanup = null;
    }
    this.overlay.hide();
  }

  /**
   * Check if element is interactive (same logic as EventCapture).
   */
  private isInteractiveElement(element: Element): boolean {
    const tagName = element.tagName.toLowerCase();
    const interactiveTags = ['a', 'button', 'input', 'select', 'textarea', 'label'];

    if (interactiveTags.includes(tagName)) return true;

    const role = element.getAttribute('role');
    if (role && ['button', 'link', 'checkbox', 'radio', 'menuitem', 'tab'].includes(role)) {
      return true;
    }

    if (element.hasAttribute('onclick') || element.hasAttribute('tabindex')) {
      return true;
    }

    const style = window.getComputedStyle(element);
    if (style.cursor === 'pointer') return true;

    return false;
  }

  /**
   * Emit event to handler.
   */
  private emit(type: 'state_changed' | 'action_captured', action?: CapturedAction): void {
    if (!this.eventHandler) return;

    this.eventHandler({
      type,
      state: this.state,
      action,
      session: this.session ?? undefined
    });
  }

  /**
   * Generate a unique session ID.
   */
  private generateSessionId(): string {
    return `rec-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  }
}

// Re-export types for convenience
export type { CapturedAction, RecordingState, RecordingSession, SemanticHint, HintType } from './types';
export { generateHints } from './hintGenerator';
```

Key implementation details:
- Orchestrates EventCapture, NavigationCapture, and visual feedback
- Supports start/stop/pause/resume lifecycle
- Maintains session with all captured actions
- Hover highlighting shows "hover" state, click shows "captured" flash
- Event handler pattern for notifying external code (service worker)
- Proper cleanup to avoid memory leaks
  </action>
  <verify>
    npx tsc --noEmit && npm run build
  </verify>
  <done>
    entrypoints/content/recording/index.ts exports RecordingManager class.
    RecordingManager has start(), stop(), pause(), resume(), getState(), getActions(), onEvent() methods.
    All sub-modules are properly orchestrated.
    Build succeeds.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes (no type errors)
- `npm run build` completes successfully
- eventCapture.ts exports EventCapture class
- navigationCapture.ts exports NavigationCapture class
- index.ts (recording) exports RecordingManager class
- RecordingManager integrates visual feedback (overlay + indicator)
- Event capture uses capture phase for reliability
- Navigation capture handles SPA routes via History API patching
</verification>

<success_criteria>
1. EventCapture captures click, input, and submit events with semantic hints
2. NavigationCapture captures traditional and SPA navigations
3. RecordingManager orchestrates all components with clean lifecycle
4. Visual feedback shows hover state and captured flash
5. Input values are debounced and password values are masked
6. Build completes successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-recording/02-03-SUMMARY.md`
</output>
