---
phase: 02-recording
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - entrypoints/content/recording/visualFeedback.ts
  - entrypoints/content/recording/styles.ts
autonomous: true

must_haves:
  truths:
    - "Overlay highlights element without affecting page layout"
    - "Overlay uses maximum z-index to appear above all page content"
    - "Overlay position updates when element moves (scroll/resize)"
    - "Overlay can be shown and hidden programmatically"
  artifacts:
    - path: "entrypoints/content/recording/visualFeedback.ts"
      provides: "HighlightOverlay class with show/hide/update methods"
      exports: ["HighlightOverlay"]
    - path: "entrypoints/content/recording/styles.ts"
      provides: "CSS constants for recording overlay styling"
      exports: ["OVERLAY_STYLES", "RECORDING_INDICATOR_STYLES"]
  key_links:
    - from: "entrypoints/content/recording/visualFeedback.ts"
      to: "entrypoints/content/recording/styles.ts"
      via: "imports OVERLAY_STYLES"
      pattern: "import.*OVERLAY_STYLES.*from.*styles"
---

<objective>
Create visual feedback system for recording mode: an overlay that highlights elements as the user hovers/clicks without affecting page layout.

Purpose: Visual feedback is critical UX - users need to see which element will be captured before clicking. The overlay must be non-intrusive (no layout shifts) and reliable (highest z-index, updates on scroll).

Output: HighlightOverlay class that can show/hide/update position of a highlight overlay on any DOM element.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-recording/02-RESEARCH.md

# Research recommends absolute positioning with max z-index, pointer-events: none
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create styles constants</name>
  <files>
    entrypoints/content/recording/styles.ts
  </files>
  <action>
Create entrypoints/content/recording/styles.ts with CSS constants for recording visual feedback.

```typescript
/**
 * Style constants for recording visual feedback.
 * Using CSS-in-JS strings to avoid external CSS file requirements.
 */

// Maximum safe z-index value
export const MAX_Z_INDEX = 2147483647;

// Highlight overlay styles
export const OVERLAY_STYLES = {
  base: `
    position: absolute;
    pointer-events: none;
    box-sizing: border-box;
    z-index: ${MAX_Z_INDEX};
    transition: all 0.1s ease-out;
  `,
  // Hover state - subtle highlight
  hover: `
    border: 2px solid rgba(66, 133, 244, 0.8);
    background-color: rgba(66, 133, 244, 0.1);
    border-radius: 2px;
  `,
  // Click/captured state - strong highlight
  captured: `
    border: 2px solid rgba(76, 175, 80, 0.9);
    background-color: rgba(76, 175, 80, 0.15);
    border-radius: 2px;
  `,
  // Error state - element not found
  error: `
    border: 2px solid rgba(244, 67, 54, 0.8);
    background-color: rgba(244, 67, 54, 0.1);
    border-radius: 2px;
  `,
} as const;

// Recording indicator badge (shows "REC" in corner)
export const RECORDING_INDICATOR_STYLES = {
  container: `
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: ${MAX_Z_INDEX};
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background-color: rgba(244, 67, 54, 0.95);
    color: white;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 12px;
    font-weight: 600;
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    pointer-events: none;
  `,
  dot: `
    width: 8px;
    height: 8px;
    background-color: white;
    border-radius: 50%;
    animation: pulse 1.5s ease-in-out infinite;
  `,
  // Keyframes need to be injected separately
  keyframes: `
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
  `,
} as const;

// Utility function to create style element
export function injectStyles(css: string, id: string): HTMLStyleElement {
  // Remove existing style element if present
  const existing = document.getElementById(id);
  if (existing) {
    existing.remove();
  }

  const style = document.createElement('style');
  style.id = id;
  style.textContent = css;
  document.head.appendChild(style);
  return style;
}
```

Use only inline styles and CSS-in-JS to avoid external CSS dependencies. Colors match Google's Material Design palette for familiarity.
  </action>
  <verify>
    npx tsc --noEmit
  </verify>
  <done>
    styles.ts exports OVERLAY_STYLES, RECORDING_INDICATOR_STYLES, MAX_Z_INDEX, injectStyles function.
    Type checking passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HighlightOverlay class</name>
  <files>
    entrypoints/content/recording/visualFeedback.ts
  </files>
  <action>
Create entrypoints/content/recording/visualFeedback.ts with the HighlightOverlay class.

```typescript
import { OVERLAY_STYLES, RECORDING_INDICATOR_STYLES, injectStyles } from './styles';

export type OverlayState = 'hover' | 'captured' | 'error';

/**
 * Non-intrusive overlay for highlighting DOM elements during recording.
 * Uses absolute positioning to avoid affecting page layout.
 */
export class HighlightOverlay {
  private overlay: HTMLDivElement | null = null;
  private currentElement: Element | null = null;
  private resizeObserver: ResizeObserver | null = null;
  private scrollHandler: (() => void) | null = null;

  /**
   * Show highlight overlay on the given element.
   * @param element - The DOM element to highlight
   * @param state - Visual state (hover, captured, error)
   */
  show(element: Element, state: OverlayState = 'hover'): void {
    // Hide any existing overlay
    this.hide();

    this.currentElement = element;

    // Create overlay element
    this.overlay = document.createElement('div');
    this.overlay.setAttribute('data-browserlet-overlay', 'true');
    this.overlay.style.cssText = OVERLAY_STYLES.base + OVERLAY_STYLES[state];

    // Position over element
    this.updatePosition();

    // Append to body
    document.body.appendChild(this.overlay);

    // Set up position tracking
    this.setupPositionTracking();
  }

  /**
   * Hide the overlay and clean up.
   */
  hide(): void {
    if (this.overlay) {
      this.overlay.remove();
      this.overlay = null;
    }

    this.currentElement = null;
    this.cleanupPositionTracking();
  }

  /**
   * Update overlay visual state without repositioning.
   */
  setState(state: OverlayState): void {
    if (this.overlay) {
      this.overlay.style.cssText = OVERLAY_STYLES.base + OVERLAY_STYLES[state];
      this.updatePosition(); // Ensure position is correct
    }
  }

  /**
   * Check if overlay is currently visible.
   */
  isVisible(): boolean {
    return this.overlay !== null;
  }

  /**
   * Update overlay position to match current element bounds.
   */
  private updatePosition(): void {
    if (!this.overlay || !this.currentElement) return;

    const rect = this.currentElement.getBoundingClientRect();

    // Use scrollX/scrollY for absolute positioning relative to document
    this.overlay.style.top = `${rect.top + window.scrollY}px`;
    this.overlay.style.left = `${rect.left + window.scrollX}px`;
    this.overlay.style.width = `${rect.width}px`;
    this.overlay.style.height = `${rect.height}px`;
  }

  /**
   * Set up listeners to track element position changes.
   */
  private setupPositionTracking(): void {
    // Track scroll
    this.scrollHandler = () => this.updatePosition();
    window.addEventListener('scroll', this.scrollHandler, { passive: true });
    window.addEventListener('resize', this.scrollHandler, { passive: true });

    // Track element size changes
    if (this.currentElement) {
      this.resizeObserver = new ResizeObserver(() => this.updatePosition());
      this.resizeObserver.observe(this.currentElement);
    }
  }

  /**
   * Clean up position tracking listeners.
   */
  private cleanupPositionTracking(): void {
    if (this.scrollHandler) {
      window.removeEventListener('scroll', this.scrollHandler);
      window.removeEventListener('resize', this.scrollHandler);
      this.scrollHandler = null;
    }

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }
}

/**
 * Recording indicator that shows "REC" badge in corner of page.
 */
export class RecordingIndicator {
  private container: HTMLDivElement | null = null;
  private styleElement: HTMLStyleElement | null = null;

  /**
   * Show the recording indicator.
   */
  show(): void {
    if (this.container) return; // Already visible

    // Inject keyframes
    this.styleElement = injectStyles(
      RECORDING_INDICATOR_STYLES.keyframes,
      'browserlet-recording-keyframes'
    );

    // Create container
    this.container = document.createElement('div');
    this.container.setAttribute('data-browserlet-indicator', 'true');
    this.container.style.cssText = RECORDING_INDICATOR_STYLES.container;

    // Create pulsing dot
    const dot = document.createElement('div');
    dot.style.cssText = RECORDING_INDICATOR_STYLES.dot;

    // Create text
    const text = document.createElement('span');
    text.textContent = 'REC';

    this.container.appendChild(dot);
    this.container.appendChild(text);
    document.body.appendChild(this.container);
  }

  /**
   * Hide the recording indicator.
   */
  hide(): void {
    if (this.container) {
      this.container.remove();
      this.container = null;
    }

    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }

  /**
   * Check if indicator is currently visible.
   */
  isVisible(): boolean {
    return this.container !== null;
  }
}
```

Key implementation details:
- Uses `pointer-events: none` so overlay doesn't interfere with clicks
- Uses `scrollX/scrollY` for proper absolute positioning in scrollable pages
- ResizeObserver handles element size changes
- Scroll/resize handlers update position in real-time
- Both classes include proper cleanup to avoid memory leaks
  </action>
  <verify>
    npx tsc --noEmit && npm run build
  </verify>
  <done>
    visualFeedback.ts exports HighlightOverlay and RecordingIndicator classes.
    HighlightOverlay has show(element, state), hide(), setState(state), isVisible() methods.
    RecordingIndicator has show(), hide(), isVisible() methods.
    Build succeeds.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes (no type errors)
- `npm run build` completes successfully
- entrypoints/content/recording/styles.ts exports OVERLAY_STYLES, RECORDING_INDICATOR_STYLES
- entrypoints/content/recording/visualFeedback.ts exports HighlightOverlay, RecordingIndicator
- HighlightOverlay uses absolute positioning (not fixed, to handle scrolling correctly)
- HighlightOverlay uses z-index 2147483647 (max safe value)
- HighlightOverlay has pointer-events: none
</verification>

<success_criteria>
1. styles.ts defines CSS constants for overlay and recording indicator
2. HighlightOverlay class can show/hide highlight on any element
3. Overlay position updates on scroll and resize
4. Overlay uses max z-index and doesn't affect layout (pointer-events: none)
5. RecordingIndicator shows pulsing "REC" badge
6. Build completes successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-recording/02-02-SUMMARY.md`
</output>
