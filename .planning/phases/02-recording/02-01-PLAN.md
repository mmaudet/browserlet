---
phase: 02-recording
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - utils/types.ts
  - entrypoints/content/recording/types.ts
  - entrypoints/content/recording/hintGenerator.ts
  - utils/hints/dom.ts
  - utils/hints/text.ts
autonomous: true

must_haves:
  truths:
    - "Recording types define CapturedAction, RecordingState, and SemanticHint structures"
    - "Hint generator extracts 10 semantic hint types from DOM elements"
    - "Hint generation completes in under 50ms for simple elements"
  artifacts:
    - path: "entrypoints/content/recording/types.ts"
      provides: "CapturedAction, RecordingState, SemanticHint type definitions"
      exports: ["CapturedAction", "RecordingState", "SemanticHint", "HintType"]
    - path: "entrypoints/content/recording/hintGenerator.ts"
      provides: "generateHints function that extracts semantic hints from DOM elements"
      exports: ["generateHints"]
    - path: "utils/hints/dom.ts"
      provides: "DOM utilities for role detection, label finding, visibility checks"
      exports: ["getElementRole", "findAssociatedLabel", "isElementVisible", "getNearbyText"]
    - path: "utils/hints/text.ts"
      provides: "Text normalization and comparison utilities"
      exports: ["normalizeText", "getVisibleText", "containsText"]
  key_links:
    - from: "entrypoints/content/recording/hintGenerator.ts"
      to: "utils/hints/dom.ts"
      via: "imports getElementRole, findAssociatedLabel"
      pattern: "import.*from.*utils/hints/dom"
    - from: "entrypoints/content/recording/hintGenerator.ts"
      to: "utils/hints/text.ts"
      via: "imports normalizeText, getVisibleText"
      pattern: "import.*from.*utils/hints/text"
---

<objective>
Create recording infrastructure: types for captured actions and semantic hints, plus hint generator ported from POC semantic-resolver.

Purpose: Establish the data structures and hint extraction logic that all recording tasks depend on. The hint generator is the core differentiator - extracting semantic attributes (role, aria-label, text, data-attributes) instead of fragile XPath selectors.

Output: TypeScript types for recording state and captured actions, plus working hint generator that extracts 10 semantic hint types from DOM elements.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-recording/02-RESEARCH.md

# Existing infrastructure
@utils/types.ts
@entrypoints/content/index.ts

# POC code to port (reference for implementation)
# Port from: /Users/mmaudet/work/poc-semantic-resolver/src/types.ts
# Port from: /Users/mmaudet/work/poc-semantic-resolver/src/hints/evaluators.ts
# Port from: /Users/mmaudet/work/poc-semantic-resolver/src/utils/dom.ts
# Port from: /Users/mmaudet/work/poc-semantic-resolver/src/utils/text.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recording types and extend message types</name>
  <files>
    utils/types.ts
    entrypoints/content/recording/types.ts
  </files>
  <action>
1. Update utils/types.ts:
   - Add new MessageTypes: 'START_RECORDING', 'STOP_RECORDING', 'RECORDING_STATE_CHANGED', 'ACTION_CAPTURED'
   - Add RecordingState to AppState interface: recordingState: 'idle' | 'recording' | 'paused'
   - Add recordedActions: CapturedAction[] to AppState

2. Create entrypoints/content/recording/types.ts with:

```typescript
// Recording state machine
export type RecordingState = 'idle' | 'recording' | 'paused';

// Semantic hint types (10 types from POC)
export type HintType =
  | 'role'
  | 'text_contains'
  | 'type'
  | 'name'
  | 'placeholder_contains'
  | 'aria_label'
  | 'near_label'
  | 'class_contains'
  | 'data_attribute'
  | 'id';

// Captured semantic hint
export interface SemanticHint {
  type: HintType;
  value: string | { name: string; value: string }; // data_attribute uses object
}

// Action types that can be recorded
export type ActionType = 'click' | 'input' | 'navigate' | 'submit';

// A single captured user action
export interface CapturedAction {
  type: ActionType;
  timestamp: number;
  url: string;
  hints: SemanticHint[];
  // For input actions
  value?: string;
  // For navigation
  targetUrl?: string;
  // Frame context
  frameId?: string;
  isIframe: boolean;
}

// Recording session metadata
export interface RecordingSession {
  id: string;
  startTime: number;
  endTime?: number;
  actions: CapturedAction[];
  startUrl: string;
}
```

Ensure all exports are properly typed with no `any` types.
  </action>
  <verify>
    npx tsc --noEmit
  </verify>
  <done>
    Recording types compile without errors, MessageType union includes recording messages, AppState includes recordingState and recordedActions fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Port hint utilities from POC</name>
  <files>
    utils/hints/dom.ts
    utils/hints/text.ts
  </files>
  <action>
1. Create utils/hints/dom.ts by porting from POC /Users/mmaudet/work/poc-semantic-resolver/src/utils/dom.ts:

```typescript
// IMPLICIT_ROLES mapping (tag -> role)
// INPUT_TYPE_ROLES mapping (input type -> role)
// getElementRole(element: Element): string | null
// isElementVisible(element: Element): boolean
// findAssociatedLabel(element: Element): HTMLLabelElement | null
// getNearbyText(element: Element, maxLevels?: number): string[]
```

Port the code exactly from POC, adapting only:
- Remove ResolverConfig imports (not needed for recording)
- Remove collectCandidates and filterCandidatesByRole (those are for playback/resolution)
- Keep: IMPLICIT_ROLES, INPUT_TYPE_ROLES, getElementRole, isElementVisible, findAssociatedLabel, getNearbyText

2. Create utils/hints/text.ts by porting from POC /Users/mmaudet/work/poc-semantic-resolver/src/utils/text.ts:

```typescript
// normalizeText(text: string | null | undefined, removeAccents?: boolean): string
// getVisibleText(element: Element): string
// getTextPreview(element: Element, maxLength?: number): string
// containsText(haystack: string, needle: string): boolean
```

Port the code exactly from POC, removing fuzzyMatch and matchesPattern (not needed for recording phase - those are for resolution).

Both files should be pure utility functions with no side effects.
  </action>
  <verify>
    npx tsc --noEmit && npm run build
  </verify>
  <done>
    utils/hints/dom.ts exports getElementRole, isElementVisible, findAssociatedLabel, getNearbyText.
    utils/hints/text.ts exports normalizeText, getVisibleText, getTextPreview, containsText.
    Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create hint generator</name>
  <files>
    entrypoints/content/recording/hintGenerator.ts
  </files>
  <action>
Create entrypoints/content/recording/hintGenerator.ts that generates semantic hints from a DOM element.

```typescript
import { SemanticHint, HintType } from './types';
import { getElementRole, findAssociatedLabel, getNearbyText } from '../../../utils/hints/dom';
import { getVisibleText, normalizeText } from '../../../utils/hints/text';

/**
 * Generate semantic hints from a DOM element.
 * Returns an array of hints that can be used to relocate the element later.
 * Target: complete in <50ms for simple elements.
 */
export function generateHints(element: Element): SemanticHint[] {
  const hints: SemanticHint[] = [];

  // 1. Role (ARIA or implicit)
  const role = getElementRole(element);
  if (role) {
    hints.push({ type: 'role', value: role });
  }

  // 2. ID (if present and looks stable - not auto-generated)
  const id = element.getAttribute('id');
  if (id && !looksAutoGenerated(id)) {
    hints.push({ type: 'id', value: id });
  }

  // 3. Text content (truncated to 100 chars)
  const text = getVisibleText(element);
  if (text && text.length > 0 && text.length <= 100) {
    hints.push({ type: 'text_contains', value: normalizeText(text) });
  }

  // 4. Type attribute (input/button)
  const type = element.getAttribute('type');
  if (type) {
    hints.push({ type: 'type', value: type });
  }

  // 5. Name attribute
  const name = element.getAttribute('name');
  if (name) {
    hints.push({ type: 'name', value: name });
  }

  // 6. Aria-label
  const ariaLabel = element.getAttribute('aria-label');
  if (ariaLabel) {
    hints.push({ type: 'aria_label', value: ariaLabel });
  }

  // 7. Placeholder
  const placeholder = element.getAttribute('placeholder');
  if (placeholder) {
    hints.push({ type: 'placeholder_contains', value: placeholder });
  }

  // 8. Near label (associated <label> element)
  const label = findAssociatedLabel(element);
  if (label && label.textContent) {
    hints.push({ type: 'near_label', value: normalizeText(label.textContent) });
  }

  // 9. Class contains (only semantic-looking classes, skip utility classes)
  const semanticClasses = getSemanticClasses(element);
  if (semanticClasses.length > 0) {
    hints.push({ type: 'class_contains', value: semanticClasses[0] });
  }

  // 10. Data attributes (data-testid, data-cy, data-action, etc.)
  for (const attr of element.attributes) {
    if (attr.name.startsWith('data-') && isSemanticDataAttribute(attr.name)) {
      hints.push({
        type: 'data_attribute',
        value: { name: attr.name, value: attr.value }
      });
    }
  }

  return hints;
}

/**
 * Check if an ID looks auto-generated (contains random strings, UUIDs, etc.)
 */
function looksAutoGenerated(id: string): boolean {
  // UUID pattern
  if (/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i.test(id)) return true;
  // Random alphanumeric (8+ chars with mixed case/numbers)
  if (/^[a-zA-Z0-9]{8,}$/.test(id) && /\d/.test(id) && /[a-zA-Z]/.test(id)) return true;
  // Starts with common auto-gen prefixes
  if (/^(ember|react|vue|ng-|:r|__)/i.test(id)) return true;
  return false;
}

/**
 * Get semantic-looking classes (skip utility classes like Tailwind)
 */
function getSemanticClasses(element: Element): string[] {
  const semanticClasses: string[] = [];
  const skipPatterns = [
    /^(flex|grid|block|inline|hidden)/, // Layout
    /^(p|m|w|h|min-|max-)-/, // Spacing/sizing
    /^(text-|font-|bg-|border-)/, // Styling
    /^(hover:|focus:|active:)/, // States
    /^(sm:|md:|lg:|xl:)/, // Responsive
  ];

  for (const className of element.classList) {
    const isUtility = skipPatterns.some(p => p.test(className));
    if (!isUtility && className.length > 2) {
      semanticClasses.push(className);
    }
  }

  return semanticClasses;
}

/**
 * Check if a data attribute is semantic (useful for selection)
 */
function isSemanticDataAttribute(name: string): boolean {
  const semanticPrefixes = [
    'data-testid',
    'data-test-id',
    'data-cy',
    'data-qa',
    'data-action',
    'data-component',
    'data-id',
    'data-name',
    'data-value',
  ];
  return semanticPrefixes.some(prefix => name.startsWith(prefix));
}
```

The generateHints function should be synchronous and fast (<50ms for typical elements).
  </action>
  <verify>
    npx tsc --noEmit && npm run build
  </verify>
  <done>
    generateHints function compiles and exports from entrypoints/content/recording/hintGenerator.ts.
    Function extracts 10 hint types: role, id, text_contains, type, name, aria_label, placeholder_contains, near_label, class_contains, data_attribute.
    Build succeeds.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes (no type errors)
- `npm run build` completes successfully
- Files exist: utils/types.ts (updated), entrypoints/content/recording/types.ts, entrypoints/content/recording/hintGenerator.ts, utils/hints/dom.ts, utils/hints/text.ts
- MessageType includes START_RECORDING, STOP_RECORDING, RECORDING_STATE_CHANGED, ACTION_CAPTURED
- generateHints function is exported and callable
</verification>

<success_criteria>
1. Recording types are defined and exported (CapturedAction, RecordingState, SemanticHint)
2. Message types extended for recording communication
3. AppState includes recordingState and recordedActions
4. Hint utilities ported from POC compile without errors
5. generateHints extracts 10 semantic hint types from DOM elements
6. Build completes successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-recording/02-01-SUMMARY.md`
</output>
