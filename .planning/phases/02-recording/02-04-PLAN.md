---
phase: 02-recording
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - entrypoints/content/index.ts
  - entrypoints/background/messaging.ts
  - entrypoints/background/storage.ts
  - entrypoints/sidepanel/main.ts
  - entrypoints/sidepanel/index.html
  - wxt.config.ts
autonomous: true

must_haves:
  truths:
    - "User can click Start Recording button in Side Panel to begin recording"
    - "User can click Stop Recording button to end recording"
    - "Recording state syncs between content script and side panel via service worker"
    - "Captured actions are saved to chrome.storage.local"
    - "Content script runs in all frames including iframes"
  artifacts:
    - path: "entrypoints/sidepanel/index.html"
      provides: "Side panel UI with Start/Stop recording controls"
      contains: "Start Recording"
    - path: "entrypoints/sidepanel/main.ts"
      provides: "Side panel logic for recording controls"
      contains: "START_RECORDING"
    - path: "entrypoints/background/messaging.ts"
      provides: "Message handlers for recording commands"
      contains: "START_RECORDING"
    - path: "wxt.config.ts"
      provides: "Content script configuration with allFrames: true"
      contains: "allFrames"
  key_links:
    - from: "entrypoints/sidepanel/main.ts"
      to: "entrypoints/background/messaging.ts"
      via: "chrome.runtime.sendMessage START_RECORDING"
      pattern: "sendMessage.*START_RECORDING"
    - from: "entrypoints/background/messaging.ts"
      to: "entrypoints/content/index.ts"
      via: "chrome.tabs.sendMessage to content script"
      pattern: "tabs\\.sendMessage"
    - from: "entrypoints/content/index.ts"
      to: "entrypoints/content/recording/index.ts"
      via: "imports RecordingManager"
      pattern: "import.*RecordingManager"
---

<objective>
Wire up recording controls: Side Panel UI, service worker message handling, content script integration, and iframe support via allFrames configuration.

Purpose: Connect all the recording components through the Chrome extension messaging system. User initiates recording from Side Panel, service worker routes commands, content script executes recording, and state syncs back to UI.

Output: Working recording flow from Side Panel button click to captured actions stored in chrome.storage.local, with iframe support.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-recording/02-RESEARCH.md

# Existing infrastructure
@entrypoints/background/messaging.ts
@entrypoints/background/storage.ts
@entrypoints/content/index.ts
@entrypoints/sidepanel/main.ts
@entrypoints/sidepanel/index.html
@utils/types.ts
@wxt.config.ts

# Dependencies from previous plans
@entrypoints/content/recording/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable iframe injection and update message handlers</name>
  <files>
    wxt.config.ts
    entrypoints/background/messaging.ts
    entrypoints/background/storage.ts
    utils/types.ts
  </files>
  <action>
1. Update wxt.config.ts to enable allFrames for content script:

In the config, ensure the content script is injected into all frames. WXT handles this via the content script definition. Check if allFrames needs to be added to the defineContentScript call or wxt.config.ts manifest section.

```typescript
// wxt.config.ts - add to manifest if needed
export default defineConfig({
  manifest: {
    // ... existing config
  },
  // WXT handles allFrames via defineContentScript in the content script file
});
```

Actually, update the content script in entrypoints/content/index.ts to add allFrames: true to defineContentScript (this will be done in Task 2).

2. Update utils/types.ts to add the recording message types (if not already done in Plan 01):

Ensure MessageType includes:
```typescript
export type MessageType =
  | 'PING'
  | 'GET_STATE'
  | 'SET_STATE'
  | 'STORAGE_CHANGED'
  | 'START_RECORDING'
  | 'STOP_RECORDING'
  | 'RECORDING_STATE_CHANGED'
  | 'ACTION_CAPTURED';
```

Update AppState to include recording state:
```typescript
export interface AppState {
  version: string;
  firstInstall: number;
  lastActivity: number;
  recordingState: 'idle' | 'recording' | 'paused';
  recordedActions: CapturedAction[];
}
```

Import CapturedAction from recording types or define a simplified version here:
```typescript
// Simplified captured action for storage (avoid circular imports)
export interface StoredAction {
  type: 'click' | 'input' | 'navigate' | 'submit';
  timestamp: number;
  url: string;
  hints: Array<{ type: string; value: string | { name: string; value: string } }>;
  value?: string;
  targetUrl?: string;
  isIframe: boolean;
}
```

3. Update entrypoints/background/storage.ts:

Update getDefaultState() to include recording fields:
```typescript
function getDefaultState(): AppState {
  return {
    version: '1.0.0',
    firstInstall: Date.now(),
    lastActivity: Date.now(),
    recordingState: 'idle',
    recordedActions: []
  };
}
```

Add helper functions for recording state:
```typescript
export async function setRecordingState(state: 'idle' | 'recording' | 'paused'): Promise<AppState> {
  return setState({ recordingState: state });
}

export async function addRecordedAction(action: StoredAction): Promise<void> {
  const state = await getState();
  const actions = [...state.recordedActions, action];
  await setState({ recordedActions: actions, lastActivity: Date.now() });
}

export async function clearRecordedActions(): Promise<void> {
  await setState({ recordedActions: [], recordingState: 'idle' });
}
```

4. Update entrypoints/background/messaging.ts:

Add message handlers for recording commands:
```typescript
case 'START_RECORDING': {
  // Update state
  const updated = await setRecordingState('recording');

  // Broadcast to all tabs to start recording
  const tabs = await chrome.tabs.query({});
  for (const tab of tabs) {
    if (tab.id) {
      try {
        await chrome.tabs.sendMessage(tab.id, { type: 'START_RECORDING' });
      } catch {
        // Tab might not have content script
      }
    }
  }

  return { success: true, data: updated };
}

case 'STOP_RECORDING': {
  const updated = await setRecordingState('idle');

  // Broadcast to all tabs to stop recording
  const tabs = await chrome.tabs.query({});
  for (const tab of tabs) {
    if (tab.id) {
      try {
        await chrome.tabs.sendMessage(tab.id, { type: 'STOP_RECORDING' });
      } catch {
        // Tab might not have content script
      }
    }
  }

  return { success: true, data: updated };
}

case 'ACTION_CAPTURED': {
  const action = message.payload as StoredAction;
  await addRecordedAction(action);
  return { success: true };
}
```

Import the new storage functions at the top.
  </action>
  <verify>
    npx tsc --noEmit
  </verify>
  <done>
    Types include recording message types and AppState includes recordingState and recordedActions.
    Storage has helper functions for recording state.
    Message handlers route START_RECORDING, STOP_RECORDING, ACTION_CAPTURED.
    Type checking passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate RecordingManager in content script</name>
  <files>
    entrypoints/content/index.ts
  </files>
  <action>
Update entrypoints/content/index.ts to:
1. Add allFrames: true to defineContentScript
2. Initialize RecordingManager
3. Handle START_RECORDING and STOP_RECORDING messages
4. Send ACTION_CAPTURED messages to service worker

```typescript
import { sendMessageSafe } from './messaging';
import { isContextValid } from '../../utils/context-check';
import { RecordingManager, CapturedAction } from './recording';

// Singleton instance
let recordingManager: RecordingManager | null = null;

export default defineContentScript({
  matches: ['<all_urls>'],
  allFrames: true,  // KEY: Inject into all iframes

  main() {
    console.log('[Browserlet] Content script loaded on:', window.location.href);

    // Initialize recording manager
    recordingManager = new RecordingManager();

    // Set up event handler to forward actions to service worker
    recordingManager.onEvent(async (event) => {
      if (event.type === 'action_captured' && event.action) {
        try {
          await sendMessageSafe({
            type: 'ACTION_CAPTURED',
            payload: event.action
          });
        } catch (error) {
          console.error('[Browserlet] Failed to send action:', error);
        }
      }
    });

    // Verify communication with service worker
    verifyConnection();

    // Listen for messages from service worker
    chrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {
      handleServiceWorkerMessage(message)
        .then(sendResponse)
        .catch((error) => sendResponse({ success: false, error: error.message }));
      return true; // Will respond asynchronously
    });
  },
});

async function verifyConnection(): Promise<void> {
  try {
    const response = await sendMessageSafe({ type: 'PING' });
    if (response.success) {
      console.log('[Browserlet] Service worker connection verified');

      // Check if recording is already active (page refresh during recording)
      const stateResponse = await sendMessageSafe({ type: 'GET_STATE' });
      if (stateResponse.success && stateResponse.data) {
        const state = stateResponse.data as { recordingState?: string };
        if (state.recordingState === 'recording' && recordingManager) {
          console.log('[Browserlet] Resuming recording after page load');
          recordingManager.start();
        }
      }
    } else {
      console.warn('[Browserlet] Service worker responded with error:', response.error);
    }
  } catch (error) {
    console.error('[Browserlet] Failed to connect to service worker:', error);
  }
}

interface ServiceWorkerMessage {
  type: string;
  payload?: unknown;
}

async function handleServiceWorkerMessage(message: ServiceWorkerMessage): Promise<unknown> {
  // Check context validity before processing
  if (!isContextValid()) {
    return { success: false, error: 'Extension context invalidated' };
  }

  switch (message.type) {
    case 'PING':
      return { success: true, data: { status: 'ok', url: window.location.href } };

    case 'STORAGE_CHANGED':
      console.log('[Browserlet] Storage changed:', message.payload);
      return { success: true };

    case 'START_RECORDING':
      if (recordingManager) {
        recordingManager.start();
        console.log('[Browserlet] Recording started');
      }
      return { success: true };

    case 'STOP_RECORDING':
      if (recordingManager) {
        const session = recordingManager.stop();
        console.log('[Browserlet] Recording stopped, actions:', session?.actions.length ?? 0);
      }
      return { success: true };

    default:
      return { success: false, error: `Unknown message type: ${message.type}` };
  }
}
```

Key changes:
- Added `allFrames: true` to defineContentScript
- Created RecordingManager singleton
- Handle START_RECORDING and STOP_RECORDING messages
- Forward captured actions to service worker via ACTION_CAPTURED
- Resume recording on page refresh if already recording
  </action>
  <verify>
    npx tsc --noEmit && npm run build
  </verify>
  <done>
    Content script has allFrames: true.
    Content script initializes RecordingManager.
    Content script handles START_RECORDING and STOP_RECORDING messages.
    Captured actions are forwarded to service worker.
    Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add recording controls to Side Panel</name>
  <files>
    entrypoints/sidepanel/index.html
    entrypoints/sidepanel/main.ts
  </files>
  <action>
1. Update entrypoints/sidepanel/index.html to add recording controls:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Browserlet</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 16px;
      background: #f5f5f5;
      min-height: 100vh;
    }

    .header {
      margin-bottom: 20px;
    }

    h1 {
      font-size: 20px;
      font-weight: 600;
      color: #333;
    }

    .status {
      margin-bottom: 20px;
      padding: 12px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .status-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      font-size: 13px;
    }

    .status-label {
      color: #666;
    }

    .status-value {
      font-weight: 500;
      color: #333;
    }

    .status-value.recording {
      color: #f44336;
    }

    .status-value.connected {
      color: #4caf50;
    }

    .controls {
      margin-bottom: 20px;
    }

    .btn {
      width: 100%;
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn-primary {
      background: #4285f4;
      color: white;
    }

    .btn-primary:hover {
      background: #3367d6;
    }

    .btn-primary:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .btn-danger {
      background: #f44336;
      color: white;
    }

    .btn-danger:hover {
      background: #d32f2f;
    }

    .actions-section {
      background: white;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .actions-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .actions-title {
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }

    .actions-count {
      font-size: 12px;
      color: #666;
      background: #eee;
      padding: 2px 8px;
      border-radius: 12px;
    }

    .actions-list {
      max-height: 300px;
      overflow-y: auto;
      font-size: 12px;
    }

    .action-item {
      padding: 8px;
      border-bottom: 1px solid #f0f0f0;
      color: #555;
    }

    .action-item:last-child {
      border-bottom: none;
    }

    .action-type {
      font-weight: 500;
      color: #333;
      text-transform: uppercase;
      font-size: 10px;
    }

    .action-details {
      margin-top: 4px;
      color: #888;
      word-break: break-all;
    }

    .empty-state {
      text-align: center;
      padding: 24px;
      color: #999;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Browserlet</h1>
  </div>

  <div class="status">
    <div class="status-row">
      <span class="status-label">Service Worker</span>
      <span id="sw-status" class="status-value">Checking...</span>
    </div>
    <div class="status-row">
      <span class="status-label">Recording</span>
      <span id="recording-status" class="status-value">Idle</span>
    </div>
  </div>

  <div class="controls">
    <button id="record-btn" class="btn btn-primary">Start Recording</button>
  </div>

  <div class="actions-section">
    <div class="actions-header">
      <span class="actions-title">Captured Actions</span>
      <span id="actions-count" class="actions-count">0</span>
    </div>
    <div id="actions-list" class="actions-list">
      <div class="empty-state">No actions recorded yet</div>
    </div>
  </div>

  <script src="./main.ts" type="module"></script>
</body>
</html>
```

2. Update entrypoints/sidepanel/main.ts to handle recording controls:

```typescript
// Elements
const swStatusEl = document.getElementById('sw-status')!;
const recordingStatusEl = document.getElementById('recording-status')!;
const recordBtnEl = document.getElementById('record-btn')! as HTMLButtonElement;
const actionsCountEl = document.getElementById('actions-count')!;
const actionsListEl = document.getElementById('actions-list')!;

// State
let isRecording = false;

// Initialize
init();

async function init() {
  // Check service worker connection
  try {
    const response = await chrome.runtime.sendMessage({ type: 'PING' });
    if (response.success) {
      swStatusEl.textContent = 'Connected';
      swStatusEl.classList.add('connected');
    } else {
      swStatusEl.textContent = 'Error';
    }
  } catch (error) {
    swStatusEl.textContent = 'Disconnected';
  }

  // Load initial state
  await loadState();

  // Set up event listeners
  recordBtnEl.addEventListener('click', toggleRecording);

  // Listen for storage changes
  chrome.storage.onChanged.addListener((changes, areaName) => {
    if (areaName === 'local' && changes.appState) {
      updateUI(changes.appState.newValue);
    }
  });
}

async function loadState() {
  try {
    const response = await chrome.runtime.sendMessage({ type: 'GET_STATE' });
    if (response.success && response.data) {
      updateUI(response.data);
    }
  } catch (error) {
    console.error('Failed to load state:', error);
  }
}

function updateUI(state: {
  recordingState?: 'idle' | 'recording' | 'paused';
  recordedActions?: Array<{
    type: string;
    timestamp: number;
    url: string;
    hints: Array<{ type: string; value: unknown }>;
    value?: string;
  }>;
}) {
  // Update recording status
  isRecording = state.recordingState === 'recording';

  if (isRecording) {
    recordingStatusEl.textContent = 'Recording';
    recordingStatusEl.classList.add('recording');
    recordBtnEl.textContent = 'Stop Recording';
    recordBtnEl.classList.remove('btn-primary');
    recordBtnEl.classList.add('btn-danger');
  } else {
    recordingStatusEl.textContent = 'Idle';
    recordingStatusEl.classList.remove('recording');
    recordBtnEl.textContent = 'Start Recording';
    recordBtnEl.classList.remove('btn-danger');
    recordBtnEl.classList.add('btn-primary');
  }

  // Update actions list
  const actions = state.recordedActions || [];
  actionsCountEl.textContent = actions.length.toString();

  if (actions.length === 0) {
    actionsListEl.innerHTML = '<div class="empty-state">No actions recorded yet</div>';
  } else {
    actionsListEl.innerHTML = actions
      .slice(-20) // Show last 20 actions
      .reverse() // Most recent first
      .map(action => {
        const hint = action.hints[0];
        const hintText = hint ? `${hint.type}: ${typeof hint.value === 'string' ? hint.value : JSON.stringify(hint.value)}` : '';
        const valueText = action.value ? ` = "${action.value.substring(0, 30)}${action.value.length > 30 ? '...' : ''}"` : '';

        return `
          <div class="action-item">
            <span class="action-type">${action.type}</span>
            <div class="action-details">${hintText}${valueText}</div>
          </div>
        `;
      })
      .join('');
  }
}

async function toggleRecording() {
  recordBtnEl.disabled = true;

  try {
    if (isRecording) {
      await chrome.runtime.sendMessage({ type: 'STOP_RECORDING' });
    } else {
      // Clear previous actions when starting new recording
      await chrome.runtime.sendMessage({
        type: 'SET_STATE',
        payload: { recordedActions: [] }
      });
      await chrome.runtime.sendMessage({ type: 'START_RECORDING' });
    }
  } catch (error) {
    console.error('Failed to toggle recording:', error);
  } finally {
    recordBtnEl.disabled = false;
  }
}
```

Key features:
- Start/Stop recording button
- Recording status indicator
- Live action list (shows last 20 actions)
- Syncs with chrome.storage.onChanged
- Clears actions when starting new recording
  </action>
  <verify>
    npx tsc --noEmit && npm run build
  </verify>
  <done>
    Side Panel has Start/Stop Recording button.
    Side Panel displays recording status and captured actions count.
    Side Panel syncs with storage changes.
    Build succeeds.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes (no type errors)
- `npm run build` completes successfully
- wxt.config.ts or content script has allFrames: true
- Message types include START_RECORDING, STOP_RECORDING, ACTION_CAPTURED
- AppState includes recordingState and recordedActions
- Side Panel has recording controls
- Content script handles recording messages
- Service worker routes recording commands to content script
</verification>

<success_criteria>
1. Content script injects into iframes (allFrames: true)
2. Side Panel displays Start/Stop Recording button
3. Clicking Start sends START_RECORDING to service worker
4. Service worker broadcasts to all content scripts
5. Content script starts RecordingManager
6. Captured actions are forwarded to service worker
7. Actions are stored in chrome.storage.local
8. Side Panel updates to show recorded actions
9. Build completes successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-recording/02-04-SUMMARY.md`
</output>
